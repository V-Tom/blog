<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Frontend on TOM&#39;s zone</title>
    <link>https://hasaki.xyz/tags/frontend/</link>
    <description>Recent content in Frontend on TOM&#39;s zone</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ZH-CN</language>
    <copyright>Early 2016 ~ 2020 &amp;copy; TOM&#39;s Zone</copyright>
    <lastBuildDate>Wed, 23 Oct 2019 14:01:30 +0800</lastBuildDate>
    
	<atom:link href="https://hasaki.xyz/tags/frontend/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>转载：这可能是最通俗的 React Fiber(时间分片) 打开方式</title>
      <link>https://hasaki.xyz/blog/2019-10-23-%E8%BD%AC%E8%BD%BD%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E9%80%9A%E4%BF%97%E7%9A%84-react-fiber%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87-%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 23 Oct 2019 14:01:30 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2019-10-23-%E8%BD%AC%E8%BD%BD%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E9%80%9A%E4%BF%97%E7%9A%84-react-fiber%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87-%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/</guid>
      <description>本文全文来自转载文章 这可能是最通俗的 React Fiber(时间分片) 打开方式
 读者可以直接去查看原文，如果原文链接丢失，可以下载这个 PDF 备份</description>
    </item>
    
    <item>
      <title>使用 Rust 编写 WebAssembly </title>
      <link>https://hasaki.xyz/blog/2019-07-20-%E4%BD%BF%E7%94%A8-rust-%E7%BC%96%E5%86%99-webassembly-/</link>
      <pubDate>Sat, 20 Jul 2019 15:42:40 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2019-07-20-%E4%BD%BF%E7%94%A8-rust-%E7%BC%96%E5%86%99-webassembly-/</guid>
      <description>老规矩，列出本机器环境
 system_profiler SPSoftwareDataType : macOS 10.14.3 (18D42) Darwin 18.2.0 cargo --version cargo 1.38.0-nightly (e3563dbdc 2019-07-16) rustc --version rustc 1.38.0-nightly (311376d30 2019-07-18) wasm-pack -V wasm-pack 0.8.1 clang --version x86_64-apple-darwin18.2.0 posix LVVM Apple LLVM version 10.0.0 (clang-1000.10.44.4)  JavaScript 历史 JavaScript 于 1995 年问世，它的设计初衷并不是为了执行起来快，在前 10 个年头，它的执行速度也确实不快。被人们广为传播的“性能大战”在 2008 年打响。许多浏览器引入了 Just-in-time 编译器，也叫 JIT。JavaScript 代码的运行渐渐变快
随着性能的提升，JavaScript 可以应用于后端开发的 Node.js。性能的提升使得 JavaScript 的应用范围得到很大的扩展。
现在通过 WebAssembly，JavaScript 的性能可以再次提速。
JIT 计算机使用的是机器语言，也就是 010101 二进制，而我们编写的 JavaScript 代码是基于人类的认知而设计出来的高级编程语言，所以需要引擎把把人类的语言转换成机器能看懂的语言。
这就像电影《降临》中，人类和外星人的互相交流一样
在代码的世界中，通常有两种方式来翻译机器语言：解释器和编译器。
 如果是通过解释器，翻译是一行行地边解释边执行 编译器是把源代码整个编译成目标代码，执行时不再需要编译器，直接在支持目标代码的平台上运行。  这两种翻译的方式都各有利弊。</description>
    </item>
    
    <item>
      <title>使用Swift开发React Native组件</title>
      <link>https://hasaki.xyz/blog/2018-03-23-%E4%BD%BF%E7%94%A8swift%E5%BC%80%E5%8F%91react-native%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Fri, 23 Mar 2018 14:28:25 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2018-03-23-%E4%BD%BF%E7%94%A8swift%E5%BC%80%E5%8F%91react-native%E7%BB%84%E4%BB%B6/</guid>
      <description>本人只是一个前端，偶尔写一点其他语言来拓展开发技能。
因业务当中使用到 RN，所以对如何实现 RN custom module 也比较感兴趣并简单学习实现了一些功能。本文可能有些地方可能比较浅显或者有错误，还望读者海涵并指正。
 环境准备 由于 swift 的断崖式升级以及 RN 不同版本，所以下面的例子可能会存在一些误差。本机环境为：
 RN：0.45.1 swift：4.1 Xcode：9.3 OS：high sierra 10.13.4  CocoaPods CocoaPods是专门为 iOS 工程提供对第三方库的依赖的管理工具，通过 CocoaPods ，我们可以更方便地管理每个第三方库的版本，而且不需要我们做太多的配置。直观、集中和自动化地管理我们项目的第三方库。
我们都有这样的经历，当我们添加第三方库的时候，需要导入一堆相关依赖库，更新的时候也要删掉重新导入然后再配置。当我们需要更新某个第三方库的时候，我们又要手动移除该库，导入新的库，然后再配置。这些是很麻烦且没有意义的工作。
安装 CocoaPods 需要用到 gem 。gem 是 RubyGems 的缩写，属于 ruby 上的包管理工具。
这里建议切换国内镜像源地址，当然你也可以加上 -p 参数来配置 proxy
gem sources --remove https://rubygems.org/ &amp;amp;&amp;amp; gem sources -a https://gems.ruby-china.org/  将 RubyGems 升级到最新版本，不然有可能导致配置 CocoaPods 失败。
sudo gem update --system  可以使用下面命令来查看替换镜像位置是否成功：
gem sources -l  结果应该是：</description>
    </item>
    
    <item>
      <title>React Native ART 介绍与实践</title>
      <link>https://hasaki.xyz/blog/2017-12-13-react-native-art/</link>
      <pubDate>Wed, 13 Dec 2017 15:29:40 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2017-12-13-react-native-art/</guid>
      <description>React Native ART 由来 React-Art  是 Reactjs 团队基于 Art（一个兼容各个浏览器SVG绘制的API封装）开发的模块，让 React 开发者能使用 jsx 语法绘制 svg。
React Native 团队分别在0.10.0和0.18.0也添加了iOS和Android平台对 react-art 的支持，官网文档至今对其只字未提。本文旨在介绍安静躺在 react-native/Libraries/ 里的ART，并展示一些实践结果。
在React Native中ART是个非常重要的库，它让非常酷炫的绘图及动画变成了可能。但是可能是知道的人真的不多导致文档及少中文更少。很多都是把英文的参数列表翻译过来，也没有案例。
为什么用 ART React Native 本身自带的 &amp;lt;Image&amp;gt; 有很多缺陷：
首先是不支持 SVG 格式的资源，目前的解决方案有通过 ReactNative-SVG 进行实现，但是这个库需要更改客户端bundle文件，带来一定的风险。
其次是 Image decoding can take more than a frame-worth of time，图片的解码由于不在主线程中进行，所以不能确保所有图片和内容在同一帧内出现，使用 &amp;lt;Image&amp;gt;标签的制作的组件里的图（比如icon）可能是三三两两“闪现”出来的，让人怀疑是个webview，体验远不如原生，尤其是在开发环境下最为明显。
其次就是不能支持矢量图形，必须放置 @2x 或者 @3x 对应的图片。
ART能干什么 俗话说，库如其名，背负着如此具有“艺术感”名字的ART生来就是为了绘制矢量图的，或者说是 画UI的，ART可以解决上诉的所有缺陷。
在我看来，或者说我目前业务需求用到的功能：
 ART 可以解决上诉 &amp;lt;Image&amp;gt; 的缺陷：解码和矢量图形 ART 可以实现 UI 上的一些渐变，比如渐变按钮，渐变背景或者底色。以及一些交互性较强的动画——画UI ART 另外一个场景就是简单数据可视化。  使用 ART  本文使用的 RN版本为0.</description>
    </item>
    
    <item>
      <title>React 模式，技巧，技巧和窍门</title>
      <link>https://hasaki.xyz/blog/2017-11-02-react-%E6%A8%A1%E5%BC%8F%E6%8A%80%E5%B7%A7%E6%8A%80%E5%B7%A7%E5%92%8C%E7%AA%8D%E9%97%A8/</link>
      <pubDate>Thu, 02 Nov 2017 15:29:40 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2017-11-02-react-%E6%A8%A1%E5%BC%8F%E6%8A%80%E5%B7%A7%E6%8A%80%E5%B7%A7%E5%92%8C%E7%AA%8D%E9%97%A8/</guid>
      <description>这篇文章整理了学习 React 过程中以及实际开发应用当中一些模式，技巧，技巧和窍门。
大部门内容是基于 React 框架下面产生的一些内容，有很大的局限性，但是确实带来了新的理念和开发方式，仁者见仁智者见智，多学习一点内容总归对职业生涯有好处。
 本篇文章还在持续更新中，如果有错误烦请指正。
 Normally React 一些常见的关于 React 需要了解的内容，就简单列举如下。下面只会列到本人认为比较值得重视的部分进行详细陈述。
 语法层面——基础入门
  JSX 语法、React 基本内容等 Derocator 或者 async await 等常见 ES6、ES7 的内容 React Lists and Keys   常用层面——日常开发必备
  smart component and dumb component container component and presentation component stateless component Events handler bind this：bind this 或者 Derocator 或者 proposal-class-public-fields-declarations Conditionals render in JSX 或者 IIFE render in JSX 或者 methods render in JSX Dynamic router 以及 Dynamic component，甚至于 Dynamic redux injection HOC Render props 16.</description>
    </item>
    
    <item>
      <title>前端性能检测和错误捕捉</title>
      <link>https://hasaki.xyz/blog/2017-09-12-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E5%92%8C%E9%94%99%E8%AF%AF%E6%8D%95%E6%8D%89/</link>
      <pubDate>Tue, 12 Sep 2017 15:29:40 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2017-09-12-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E5%92%8C%E9%94%99%E8%AF%AF%E6%8D%95%E6%8D%89/</guid>
      <description>在复杂的网络环境和浏览器环境下，自测、QA 测试以及 Code Review 都是不够的，如果对页面稳定性和准确性要求较高，就必须有一套完善的代码异常监控体系好的产品，这样才能很好的得到用户的反馈从而不断的迭代改进我们的产品。
而且复杂的用户终端设备，也需要通过性能监控发现部分前端性能瓶颈，以便进行优化；通过错误日志收集，及时获得前端的运行时错误
收集错误异常  错误异常分为 web 错误异常和React-native 错误异常
 web 错误异常 总体来说：平时收集日志的手段，可以归类为两个方面，一个是逻辑中的错误判断，为主动判断，如try...catch；一个是利用语言给我们提供的捷径，暴力式获取错误信息，如 window.onerror；当然也存在另外一种错误，那就是Promise unhandlerejection
try…catch 判断一个代码段中可能存在的错误：
try { doSomeThing(); // code... } catch (e) { // send format error Reporter.send(format(e)); }  window.onerror 这个用来捕获全局错误：
window.onerror = function() { // send format error var errInfo = format(arguments); Reporter.send(errInfo); return true; };  在上面的函数中返回 return true，错误便不会暴露到控制台中。下面是它的参数信息：
/** * @param {String} errorMessage 错误信息 * @param {String} scriptURI 出错的文件 * @param {Long} lineNumber 出错代码的行号 * @param {Long} columnNumber 出错代码的列号 * @param {Object} errorObj 错误的详细信息，Anything */ window.</description>
    </item>
    
    <item>
      <title>译文:Understanding ASTs by Building Your Own Babel Plugin</title>
      <link>https://hasaki.xyz/blog/2017-08-13-%E8%AF%91%E6%96%87understanding-asts-by-building-your-own-babel-plugin/</link>
      <pubDate>Sun, 13 Aug 2017 15:29:40 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2017-08-13-%E8%AF%91%E6%96%87understanding-asts-by-building-your-own-babel-plugin/</guid>
      <description>原文地址
Language Overview  We want to design a plugin that will allow us to use regular object and array literals, which will be transformed into persistent data structures using Mori
 我们想要设计一个插件：它将允许我们通过使用常规对象和数值文本，可以使用Mori转化为持久性的数据结构。
 We want to write code like this:
 我们要写这样的代码：
var foo = { a: 1 }; var baz = foo.a = 2; foo.a === 1; baz.a === 2;   And transform it into code like this:</description>
    </item>
    
    <item>
      <title>前端的10000个小时</title>
      <link>https://hasaki.xyz/blog/2017-03-24-%E5%89%8D%E7%AB%AF%E7%9A%8410000%E4%B8%AA%E5%B0%8F%E6%97%B6/</link>
      <pubDate>Fri, 24 Mar 2017 15:29:40 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2017-03-24-%E5%89%8D%E7%AB%AF%E7%9A%8410000%E4%B8%AA%E5%B0%8F%E6%97%B6/</guid>
      <description>我又开始扯淡了
 本篇文章出自原文，深有感触，有删改。
 10000小时定律 著名的10000小时定律，我想大家都不陌生，『要成为某个领域的专家，需要10000小时』，这个定律来源于《异类》的作者，格拉德威尔。
作为一个程序员，每天工作10小时，每周工作五天，大约4年就能达到10000小时，那是不是每个程序员认真工作，勤勤恳恳的过完4年他就能成为专家呢？答案是显而易见的。
首先10000小时只是必要条件，并非充分条件，也就是说，即使你花了这10000小时，可能也没什么用，再次简单的工作重复10000小时并不能给你带来什么提高，自然也就成不了专家
 一万小时定律 并非适合所有领域，即使有很强意志力，也很难在某些领域成为世界顶级，这里只是强调在某些领域去努力、去花费很大的精力。我觉得，这需要 实力与运气共同作用的结果
 简单的工作重复10000小时 吴军老师在《智能时代》一书中提过一个这样的观点：
 在未来的智能时代，真正受益于技术进步的个人可能不超过人口的2%。
 之后他又补充了一句：
 坦率的讲，仅仅会写几行 JavaScript 的人不属于我说的2%的行列，这些人恰恰在未来是要被计算机淘汰的。
 当时看到这里，我其实十分不解，吴军老师是不是太久没撸码了，现在 JavaScript 这么火，Node 那么牛掰，什么 React Native，Grunt，Gulp，Webpack，Vue，Weex，微信小程序等等，这些都是风生水起啊，怎么 JavaScript 就跪了呢？还有，我们高大上的前端工作怎么就挤不进这 2% 呢？
后来仔细想想，这里定义的是『仅仅会写几行 JavaScript 』，事实上，如果10000小时都花在改界面，修改 DOM，改个色值，切个图，替换下图标这种简单重复的工作里面，当然挤不进这 2% 。事实上，要学的东西远远不够，前端要有危机意识。
再来看，前端工作怎么就挤不进 2% 的人呢？ 2% 看起来还挺多，可是想想，每种职业都有其 2% ， 搬砖的有搬砖的 2%，写程序的有些程序的 2%，总不可能写程序的去抢搬砖的活儿吧。能不能挤进这 2% 要看是否善于使用智能工具，很不幸，我发现一些热门的技术的发起都和前端没啥关系，什么数字化，VR/AR，基因测序，大数据，机器学习，人工智能……
说到这里，智能手机的飞速发展带起了移动互联网，但是这波红利被终端开发给占了一大半，直到近两年，手机性能提升才让前端开始发力。为什么 PhoneGap （现已改名 Cordova）搞了那么久没什么人用，React Native 才出了没多久就已经炙手可热。除了 React Native 师出名门，还因为它的出现是为了解决终端开发效率低以及更新审核慢的问题。
好吧，前端不那么容易称为 2%，那我们还是继续付出10000小时，争取做个专家吧。
那么简单的重复不足以称为专家，那对于前端来说应该要怎么做呢？我的想法是『跨界』，不满足于做前端，而是去更多的学习终端，学习后端的知识，带来思维的转变和编程能力的提高。
 当然也可以去阅读那些框架的源码，比如React,Koa等等，去思考和借鉴一下它们的架构和内部实现，去看看算法方面的内容来提高自己的逻辑思维能力
 跨界 看看现在非常热门的 JavaScript 编译器 Babel，其作者 Sebastian McKenzie 写出这样一个编译器，必须具有很强的编程能力和熟悉编译原理、AST。这样一个人虽然写的是 JavaScript，但是已经不是一个前端了，而是大神。</description>
    </item>
    
  </channel>
</rss>