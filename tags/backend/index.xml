<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backend on TOM&#39;s zone</title>
    <link>https://hasaki.xyz/tags/backend/</link>
    <description>Recent content in Backend on TOM&#39;s zone</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ZH-CN</language>
    <copyright>Early 2016 ~ 2020 &amp;copy; TOM&#39;s Zone</copyright>
    <lastBuildDate>Tue, 12 Nov 2019 13:09:31 +0800</lastBuildDate>
    
	<atom:link href="https://hasaki.xyz/tags/backend/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>云原生基础及调研</title>
      <link>https://hasaki.xyz/blog/2019-12-12-%E4%BA%91%E5%8E%9F%E7%94%9F%E5%9F%BA%E7%A1%80%E5%8F%8A%E8%B0%83%E7%A0%94/</link>
      <pubDate>Tue, 12 Nov 2019 13:09:31 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2019-12-12-%E4%BA%91%E5%8E%9F%E7%94%9F%E5%9F%BA%E7%A1%80%E5%8F%8A%E8%B0%83%E7%A0%94/</guid>
      <description>老规矩，列出本机器环境
 system_profiler SPSoftwareDataType : macOS 10.14.1 (18B75) Darwin 18.2.0 docker -v : Docker version 19.03.5, build 633a0ea Docker desktop GUI : 2.1.0.5(40693) stable kubectl version : 根据 Docker desktop GUI 而定  概念 提到云原生（Cloud Native）可能部分人会陌生，但是如果说 Serverless 相信很多人就知道了，实际上两者并不等价。Serverless 是一种理念或者服务交付形态，目标是屏蔽硬件和运维细节。
而云原生则是实现此类目标的一种规范以及基础设施。
再进一步，介于 Docker 天然的隔离性和高效等特点，以及 Kubernetes 成为事实意义上的 Docker 编排标准，凡是见到云原生或者 Serverless 的地方，几乎都可以认为是基于 Docker + Kubernetes 的一种实践。
单个点展开讲太枯燥，索性我们从历史的角度看看为什么会有云原生。
Docker 先申明下，Docker 是一种容器技术（具体可深入 namespaces 和 cgroups），而不是虚拟化技术，真正的虚拟化比较常见的是 Xen 和 KVM，可能有同学要举手了：老师，那我们经常用的 VirtualBox 和 VMware 算虚拟化么？当然算！不过大多数情况下，它们用在桌面虚拟化领域
可能大家之前经常遇到这样的场景：为什么在我这可以运行在你那就不行了？为什么刚刚可以运行现在就不行了？最终解决下来，大多是环境不一致导致的问题。这里的环境除了开发环境还包括操作系统。
所以一般给别人代码的时候还需要告诉别人此代码可运行的操作系统版本，所依赖的各种软件的版本，甚至目录、磁盘、内存、CPU 都有要求！</description>
    </item>
    
    <item>
      <title>Serverless 入门</title>
      <link>https://hasaki.xyz/blog/2019-04-12-serverless-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 12 Apr 2019 12:52:40 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2019-04-12-serverless-%E5%85%A5%E9%97%A8/</guid>
      <description>老规矩，列出本机器环境
 serverless -v 1.46.0 node -v v10.15.0 system_profiler SPSoftwareDataType : macOS 10.14.3 (18D42) Darwin 18.2.0 云平台 aws vsCode for editor  什么是 Serverless Serverless 是一种架构模式。
根据 CNCF 的定义，Serverless 是指构建和运行不需要服务器管理的应用程序的概念。(serverless-overview)
 Serverless computing refers to the concept of building and running applications that do not require server management. &amp;mdash; CNCF
 简单来讲，Serverless 指的是在构建 Web 应用程序的时候，而不用担心如何配置服务器，但是这并不意味着应用程序不会在服务器上运行，而是说服务器的管理都可以尽可能地交给相应的云平台，从而最大程度地减轻开发人员的部署与配置工作。与之对应的一个名词可能就是 Function As a Service（FAAS），由 AWS Lambda 这个命名上就能想到，当我们在构建 Serverless 架构时，实际上我们是在写一个个的 Function 即函数而已
云计算发展模式 云计算有常用的三种模式，如下图：
云计算的三种模型是 PaaS，SaaS（软件即服务）和 IaaS（基础架构即服务）。</description>
    </item>
    
    <item>
      <title>gRPC 浅谈与实践</title>
      <link>https://hasaki.xyz/blog/2019-03-04--grpc-%E6%B5%85%E8%B0%88%E4%B8%8E%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 04 Mar 2019 11:32:40 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2019-03-04--grpc-%E6%B5%85%E8%B0%88%E4%B8%8E%E5%AE%9E%E8%B7%B5/</guid>
      <description>由于不同的环境下面的例子可能会存在一些误差，下面列出本机环境：
 Docker -v ：Docker version 18.09.1, build 4c52b90 docker-compose -v ：docker-compose version 1.23.2, build 1110ad01 go version : go version go1.12.4 darwin/amd64 system_profiler SPSoftwareDataType : macOS 10.14.3 (18D42) Darwin 18.2.0 IDE golang latest  RPC RPC 全名为 Remote procedure call ,直译过来就是 远程过程调用 ，也就是说两台服务器 A，B，一个应用部署在 A 服务器上，想要调用 B 服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。
调用的基本流程可以看下图：
RPC 的协议可以简单分成两大类。
一类是通讯层协议，通讯层协议一般是和业务无关的，它的职责是将业务数据打包后，安全、完整的传输给接受方，HSF、Dubbo、gRPC 这些都是属于通讯层协议。
另一类是应用层协议。约定业务数据和二进制串的转换规则，常见的应用层协议有 Hessian，Protobuf，JSON。
why RPC 为什么 RPC 呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如比如不同的系统间的通讯，甚至不同的组织间的通讯。由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用，
http vs RPC HTTP 调用其实也是一种特殊的 RPC 。RPC 可以基于 HTTP 协议实现，也可以直接在 TCP 协议上实现。</description>
    </item>
    
    <item>
      <title>谈谈 Node.js 的单线程</title>
      <link>https://hasaki.xyz/blog/2018-02-08-%E8%B0%88%E8%B0%88node.js%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Thu, 08 Feb 2018 14:22:25 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2018-02-08-%E8%B0%88%E8%B0%88node.js%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B/</guid>
      <description>本文较长，内容较广，涉及内容也比较多，可能存在一些纰漏，希望读者读到本篇时如果遇到错误请指出，感激不尽。
 前言 从 Node.js 进入人们的视野时，我们所知道的它就由这些关键字组成 事件驱动、非阻塞 I/O、高效、轻量，它在官网中也是这么描述自己的。
 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.
 Node.js 结构 我们可以看到，Node.js 的结构大致分为三个层次：
 Node.js 标准库，这部分是由 Javascript 编写的，即我们使用过程中直接能调用的 API。在源码中的 lib 目录下可以看到。 Node bindings，这一层是 Javascript 与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。实现在 node.cc 这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。 V8：Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript 的关键，它为 Javascript 提供了在非浏览器端运行的环境，它的高效是 Node.</description>
    </item>
    
    <item>
      <title>从jwt到OAuth</title>
      <link>https://hasaki.xyz/blog/2018-01-02-%E4%BB%8Ejwt%E5%88%B0oauth/</link>
      <pubDate>Tue, 02 Jan 2018 11:31:25 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2018-01-02-%E4%BB%8Ejwt%E5%88%B0oauth/</guid>
      <description>JWT JWT 是 JSON Web Token 的缩写，可以简单理解为生产者颁发给消费者一个令牌。参照 JWT 规范 对其所做的描述是：
 JSON Web 令牌（JWT）是一种紧凑的、URL 安全的方式，用来表示要在双方之间传递的“声明”。JWT 中的声明被编码为 JSON 对象，用作 JSON Web 签名（JWS）结构的有效内容或 JSON Web 加密（JWE）结构的明文，使得声明能够被：数字签名、或利用消息认证码（MAC）保护完整性、加密。
 这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。
JWT 的构成 JWT 由三部分构成：
 Header ：头部，即 JOSE Header Claims ：声明，即 JWT Payload Signature ：签名，即 JWT Signature  JWT 由这三部分组成，每一部分都是使用 base64url 编码的，并使用句点（.）连接起来
 这里使用base64url编码而不是普通的 base64，是因为 base64 编码会产生+和/，这两个字符在 URL 中是有特殊意义的，会导致 JWT 不是 URL 安全的。
 头部(JOSE Header) JSOE 是 JSON Object Signing and Encryption，即JSON对象签名与加密的缩写。</description>
    </item>
    
    <item>
      <title>koa 源码简单解读</title>
      <link>https://hasaki.xyz/blog/2016-09-03-koa%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sat, 03 Sep 2016 15:29:40 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2016-09-03-koa%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%A7%A3%E8%AF%BB/</guid>
      <description>Koa 是一个类似于 Express 的 Web开发框架，创始人也都是 TJ
Koa 的主要特点是，使用了ES6 的 Generator 函数，进行了架构的重新设计。Koa 的原理和内部结构很像 Express，但是语法和内部结构进行了升级，最近已经发布了2.x版本，我们来直接看一下2.x版本的koa
创建 Koa 应用 我们可以按照官方的说明很简单的创建一个koa应用
const koa = require(&#39;koa&#39;) const app = new koa() app.listen(3000)  或者可以这样：
var koa = require(&#39;koa&#39;) var http = require(&#39;http&#39;) var app = new koa() http.createServer(app.callback()).listen(4000)  这两种方式是等价的：
第一种方式:listen在内部主动创建一个一个http server并调用实例内部的 callback方法，把返回的handleRequest函数作为创建http server服务的回调函数，然后内部主动去listen。
参考源码 listen方法：
listen() { debug(&#39;listen&#39;); const server = http.createServer(this.callback()); return server.listen.apply(server, arguments); }  第二种方式:主动创建一个http server并主动调用实例的callback方法来生成一个handleRequest函数，最后listen端口号。
我们先以第一种写法作为入口，切入进去来分析源码。
首先实例化了一个koa实例，然后调用了listen方法:
简单解读: koa 本身是没有定义事件处理机制的，其事件处理机制继承自Node 的events模块，本身就是在events模块上继承的一个实例</description>
    </item>
    
  </channel>
</rss>