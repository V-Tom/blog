<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fe on TOM&#39;s zone</title>
    <link>https://hasaki.xyz/tags/fe/</link>
    <description>Recent content in Fe on TOM&#39;s zone</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ZH-CN</language>
    <copyright>Early 2016 ~ 2020 &amp;copy; TOM&#39;s Zone</copyright>
    <lastBuildDate>Mon, 20 Jan 2020 13:21:35 +0800</lastBuildDate>
    
	<atom:link href="https://hasaki.xyz/tags/fe/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>转载：现代浏览器内部揭秘</title>
      <link>https://hasaki.xyz/blog/2020-01-20-%E8%BD%AC%E8%BD%BD%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E6%8F%AD%E7%A7%98/</link>
      <pubDate>Mon, 20 Jan 2020 13:21:35 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2020-01-20-%E8%BD%AC%E8%BD%BD%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E6%8F%AD%E7%A7%98/</guid>
      <description>现代浏览器内部揭秘
 Inside look at modern web browser (part 1) Inside look at modern web browser (part 2) Inside look at modern web browser (part 3) Inside look at modern web browser (part 4)  中字翻译：现代浏览器内部揭秘
 现代浏览器内部揭秘（第一部分） 现代浏览器内部揭秘（第二部分） 现代浏览器内部揭秘（第三部分） 现代浏览器内部揭秘（第四部分）  中字本站 Archive：
 现代浏览器内部揭秘合集  </description>
    </item>
    
    <item>
      <title>javascript 沙箱</title>
      <link>https://hasaki.xyz/blog/2018-04-21-javascript-%E6%B2%99%E7%AE%B1/</link>
      <pubDate>Sat, 21 Apr 2018 17:43:01 +0800</pubDate>
      
      <guid>https://hasaki.xyz/blog/2018-04-21-javascript-%E6%B2%99%E7%AE%B1/</guid>
      <description>在一些业务场景当中，我们提供给用户插入自定义逻辑的能力，类似于沙盒、沙箱，允许执行自定义代码，产生的变化可以随后随时删除。
无论是客户端上的沙箱还是服务器端上的沙箱，我们都要确保安全性，用户自定义的脚本必须收到限制和隔离，不能影响到当前宿主程序。
javascript 本身有很多种方式可以实现沙箱，各有千秋，各有使用的地方。
 eval new Function with proxy Node VM Deno  eval 最简单的方式就是直接使用 eval 执行：
eval(&#39;console.log(&amp;quot;a simple script&amp;quot;);&#39;) // a simple script  eval 只是一个普通的函数，只不过他有一个快速通道通向编译器，可以将 string 变成可执行的代码。
 eval 的特性是如果当前域里面没有，则会向上遍历，一直到最顶层的 global scope：比如 window global ，他还可以访问 closure 内的变量。
 使用 eval 也带来了安全隐患，首先它可以访问和修改它外部作用域中的变量，其次被执行的代码（例如从网络来）可能已被篡改。
global.name = &#39;TOM&#39; eval(&#39;console.log(&amp;quot;i am &amp;quot; + name + &amp;quot; from eval&amp;quot;);&#39;) // i am TOM from eval  并且 eval 可读性较差，调试难度较高，也会轻微增加性能消耗。
对于 eval 开发者是贬褒不一，eval 是魔鬼 以及 eval 不是魔鬼</description>
    </item>
    
  </channel>
</rss>