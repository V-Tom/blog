<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="Keywords" content="">
    <meta name="full-screen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#006cb4">
    <meta name="apple-mobile-web-app-title" content="TOM&#39;s zone">
    <meta name="description" content="TOM&#39;s zone">
    <link rel="dns-prefetch" href="https://hasaki.xyz">
    <link rel="preconnect" href="https://hasaki.xyz">
    <link rel="manifest" href="/sw/manifest.json"/>
<title>React 模式，技巧，技巧和窍门 - TOM&#39;s zone</title>

<meta name="description" content="这篇文章整理了学习 React 过程中以及实际开发应用当中一些模式，技巧，技巧和窍门。
大部门内容是基于 React 框架下面产生的一些内容，有很大的局限性，但是确实带来了新的理念和开发方式，仁者见仁智者见智，多学习一点内容总归对职业生涯有好处。
 本篇文章还在持续更新中，如果有错误烦请指正。
 Normally React 一些常见的关于 React 需要了解的内容，就简单列举如下。下面只会列到本人认为比较值得重视的部分进行详细陈述。
 语法层面——基础入门
  JSX 语法、React 基本内容等 Derocator 或者 async await 等常见 ES6、ES7 的内容 React Lists and Keys   常用层面——日常开发必备
  smart component and dumb component container component and presentation component stateless component Events handler bind this：bind this 或者 Derocator 或者 proposal-class-public-fields-declarations Conditionals render in JSX 或者 IIFE render in JSX 或者 methods render in JSX Dynamic router 以及 Dynamic component，甚至于 Dynamic redux injection HOC Render props 16.">




    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">


    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/ocean.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/javascript.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/python.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/css.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/swift.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/objectivec.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/rust.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/yaml.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/bash.min.js"></script>


    <link rel="stylesheet" href="/css/bundle.min.css"/>
<script src="/js/bundle.js"></script>

<style>
	a { color: #ff8181; }
	blockquote {
		background: rgba(255, 129, 129, .1);
		border-left-color: #ff8181;
		border-right-color: #ff8181; }
	.bar a:hover {
		color: #ff8181;
		text-decoration: none; }
	.sep {
		margin-top: 2rem;
		margin-bottom: 1rem;
		margin-left:0;
		width: 24rem;
		border-top: 2px solid #ff8181; }
    .bar li.active a{
        color:#ff8181;
    }
</style>

</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li>
		
		<li class="active"><a href="/blog/">Blog</a></li>
		<li class=""><a href="/gallery/">Gallery</a></li>
		<li class=""><a href="/life/">Life</a></li></ul>
</nav>

	</div>
</header>
<main class="container">

<article>
    <header><hgroup id="brand">
  <h1>React 模式，技巧，技巧和窍门</h1>
  <h5>
    
    <time datetime="2017-11-02 15:29:40 &#43;0800 CST">Nov 02, 2017</time>
    <span class="no-print">
      -
      
      <a href="/tags/react">React</a>
      
      <a href="/tags/frontend">FrontEnd</a>
      </span>
  </h5>

  <a
    style="margin-top: 1.2rem;display: inline-block;"
    href="https://github.com/V-Tom/blog/blob/hugo/content/blog/2017-11-02-React%20%e6%a8%a1%e5%bc%8f%ef%bc%8c%e6%8a%80%e5%b7%a7%ef%bc%8c%e6%8a%80%e5%b7%a7%e5%92%8c%e7%aa%8d%e9%97%a8/index.md"
    >✨✨✨You can Edit this Article on Github site</a
  >

  <div id="git-update-time">
  ✏️✏️✏️ This article .MD file was last updated at:
  <b>Loading ...</b>
</div>

<script data-name="commits">
  ;(async () => {
    const b = document.querySelector('#git-update-time').querySelector('b')

    if (window.location.href.includes('localhost')) {
      b.innerHTML = 'localhost disable'
      return
    }

    const commits = await fetch(
      'https://api.github.com/repos/V-Tom/blog/commits?sha=hugo&path=content/blog\/2017-11-02-React 模式，技巧，技巧和窍门\/index.md',
    ).then(res => res.json())
    try {
      const time = new Date(commits[0].commit.committer.date)
      b.innerHTML = `${time.getFullYear()}-${time.getMonth() +
        1}-${time.getDate()}`
    } catch (e) {
      b.innerHTML = 'unknown'
    }
  })()
</script>


  
</hgroup>
<hr class="sep" />
</header>
    <section id="markdown">
        

<p>这篇文章整理了学习 <code>React</code> 过程中以及实际开发应用当中一些模式，技巧，技巧和窍门。</p>

<p>大部门内容是基于 <code>React</code> 框架下面产生的一些内容，有很大的局限性，但是确实带来了新的理念和开发方式，仁者见仁智者见智，多学习一点内容总归对职业生涯有好处。</p>

<blockquote>
<p>本篇文章还在持续更新中，如果有错误烦请指正。</p>
</blockquote>

<h3 id="normally-react">Normally React</h3>

<p>一些常见的关于 React 需要了解的内容，就简单列举如下。下面只会列到本人认为比较值得重视的部分进行详细陈述。</p>

<blockquote>
<p>语法层面——基础入门</p>
</blockquote>

<ul>
<li>JSX 语法、React 基本内容等</li>
<li>Derocator 或者 async await 等常见 ES6、ES7 的内容</li>
<li>React Lists and Keys</li>
</ul>

<blockquote>
<p>常用层面——日常开发必备</p>
</blockquote>

<ul>
<li><code>smart component and dumb component</code></li>
<li><code>container component and presentation component</code></li>
<li><code>stateless component</code></li>
<li>Events handler bind this：bind this 或者 Derocator 或者 <a href="https://github.com/tc39/proposal-class-fields">proposal-class-public-fields-declarations</a></li>
<li><code>Conditionals render in JSX</code> 或者 <code>IIFE render in JSX</code> 或者 <code>methods render in JSX</code></li>
<li><code>Dynamic router</code> 以及 <code>Dynamic component</code>，甚至于 <code>Dynamic redux injection</code></li>
<li><code>HOC</code></li>
<li><a href="https://reactjs.org/docs/render-props.html">Render props</a></li>
<li><a href="https://reactjs.org/docs/code-splitting.html">16.6 版本中添加 Lazy, Suspense, memo</a></li>
<li><a href="https://reactjs.org/docs/hooks-intro.html">17 版本中添加 hooks</a></li>
</ul>

<blockquote>
<p>进阶层面——性能优化和业务解耦必备</p>
</blockquote>

<ul>
<li><code>PureRenderMixin</code> 以及 <code>Pure Component</code> 以及 <code>shouldComponentUpdate check</code></li>
<li><code>unstable_rendersubtreeintocontainer</code> 以及 portal</li>
<li>React <code>fiber</code> 更新机制</li>
<li><code>React call return</code></li>
</ul>

<p>虚拟 DOM</p>

<ul>
<li><a href="https://github.com/livoras/blog/issues/13">深度剖析：如何实现一个 Virtual DOM 算法</a></li>
</ul>

<blockquote>
<p>一些周边拓展（含有本人观念</p>
</blockquote>

<ul>
<li>styled components</li>
<li>Redux saga</li>
<li>Recompose</li>
</ul>

<blockquote>
<p>最后强烈建议推荐这个：<a href="https://github.com/semlinker/reactjs-interview-questions">List of top 301 ReactJS Interview Questions &amp; Answers</a></p>
</blockquote>

<h3 id="pure-render-checks">Pure Render Checks</h3>

<pre><code class="language-Jsx">// 坏的例子
class Table extends PureComponent {

  update(e) {
    this.props.update(e.target.value);
  }

  render() {
    return (
      &lt;div&gt;
        {this.props.items.map(i =&gt;
          &lt;Cell
            data={i}
            options={this.props.options || []}
            onChange={this.update.bind(this)}
            onClick={e =&gt; this.props.update(e.target.value)}/&gt;;
           /&gt;
        )}
      &lt;/div&gt;
    );
  }
}

</code></pre>

<p>这种写法的问题在于<code>{this.props.options || []}</code> 这种写法会导致所有的 Cell 都被重新渲染即使只有一个 cell 发生改变。</p>

<p>原因是：每次传入的<code>[]</code>都相当于创建了新的 Array 实例。在 JavaScript 里面，不同的实例是有不同的实体的，所以浅比较在这种情况下总是会返回 false，然后组件就会被重新渲染。</p>

<p>对于<code>onChange</code>，<code>onClick</code>也是一样的问题，也会导致重新渲染。</p>

<pre><code class="language-jsx">// 好的例子
const defaultval = [] // &lt;---  也可以使用defaultProps
class Table extends PureComponent {
  update(e) {
    this.props.update(e.target.value)
  }

  render() {
    return (
      &lt;div&gt;
        {this.props.items.map(i =&gt; (
          &lt;Cell
            data={i}
            options={this.props.options || defaultval}
            onChange={this.update}
            onClick={this.update}
          /&gt;
        ))}
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p>总结就是： <strong>props 上的任何 prop 值尽量只创建一次, 只绑定一次</strong></p>

<p>Reference:</p>

<ul>
<li><a href="https://medium.com/@esamatti/react-js-pure-render-performance-anti-pattern-fb88c101332f">https://medium.com/@esamatti/react-js-pure-render-performance-anti-pattern-fb88c101332f</a></li>
<li><a href="https://github.com/nfour/js-structures/blob/master/guides/react-anti-patterns.md#pure-render-immutability">https://github.com/nfour/js-structures/blob/master/guides/react-anti-patterns.md#pure-render-immutability</a></li>
<li><a href="https://flexport.engineering/optimizing-react-rendering-part-1-9634469dca02">Optimizing React Rendering</a></li>
</ul>

<h3 id="synthetic-events-in-react">Synthetic events in React</h3>

<p>React 在处理事件(event 时), 事实上使用了 <code>SyntheticEvent</code> 对象包裹了原生的 event 对象.</p>

<p>这些 React 自己维护的对象是相互联系的, 意味着如果对于某一个事件, 我们给出了对应的响应函数(handler), 其他的 <code>SyntheticEvent</code> 对象也是可以重用的.这也是 React 提升性能的秘诀之一. 但是这也意味着, 如果想要通过异步的方式访问事件对象是不可能的, 因为出于 reuse 的原因, 事件对象里面的值都被重置了.</p>

<p>下面这段代码会在控制台里面打出 null, 因为事件在 <code>SyntheticEvent</code> 池中被重用了.</p>

<pre><code class="language-Jsx">function handleClick(event) {
  setTimeout(function () {
    console.log(event.target.name);
  }, 1000);
}
</code></pre>

<p>为了避免这种情况, 你需要去保存你关心的事件的属性.</p>

<pre><code class="language-Jsx">function handleClick(event) {
  let name = event.target.name;
  setTimeout(function () {
    console.log(name);
  }, 1000);
}
</code></pre>

<p>Reference:</p>

<ul>
<li><a href="https://medium.com/nick-parsons/react-redux-best-practices-gotchas-56cf61c1c415">React/Redux: Best practices &amp; gotchas</a></li>
<li><a href="https://www.youtube.com/watch?v=dRo_egw7tBc">React events in depth w/ Kent C. Dodds, Ben Alpert, &amp; Dan Abramov</a></li>
</ul>

<h3 id="async-nature-of-setstate">async-nature-of-setState</h3>

<p>在某些情况下，React 框架出于性能优化考虑，可能会将多次 state 更新合并成一次更新。正因为如此，setState 实际上是一个异步的函数。 但是，有一些行为也会阻止 React 框架本身对于多次 state 更新的合并，从而让 state 的更新变得同步化。 比如: eventListeners, Ajax, setTimeout 等等。</p>

<h4 id="详解">详解</h4>

<p>当 setState() 函数执行的时候，函数会创建一个暂态的 state 作为过渡 state，而不是立即修改 <code>this.state</code>。 如果在调用 setState() 函数之后尝试去访问 this.state，你得到的可能还是 setState() 函数执行之前的结果。 在使用 setState() 的情况下，看起来同步执行的代码其实执行顺序是得不到保证的。原因上面也提到过，React 可能会将多次 state 更新合并成一次更新来优化性能。</p>

<p>运行下面这段代码，你会发现当和 <code>addEventListener</code> , <code>setTimeout</code> 函数或者发出 AJAX call 的时候，调用 setState , state 会发生改变。并且 render 函数会在 setState() 函数被触发之后马上被调用。那么到底发生了什么呢？事实上，类似 setTimeout() 函数或者发出 ajax call 的 fetch 函数属于调用浏览器层面的 API，这些函数的执行并不存在与 React 的上下文中，所以 React 并不能够像控制其他存在与其上下文中的函数一样，将多次 state 更新合并成一次。</p>

<p>在上面这些例子中，React 框架之所以在选择在调用 setState 函数之后立即更新 state 而不是采用框架默认的方式，即合并多次 state 更新为一次更新，是因为这些函数调用(fetch,setTimeout 等浏览器层面的 API 调用)并不处于 React 框架的上下文中，React 没有办法对其进行控制。React 在此时采用的策略就是及时更新，确保在这些函数执行之后的其他代码能拿到正确的数据（即更新过的 state)。</p>

<pre><code class="language-Jsx">class TestComponent extends React.Component {

  constructor(props) {
    super(props);
    this.state = {
      dollars: 10
    }
    this.onMouseLeaveHandler = this.onMouseLeaveHandler.bind(this);
    this.onTimeoutHandler = this.onTimeoutHandler.bind(this);
    this.onAjaxCallback = this.onAjaxCallback.bind(this);
    this.onClickHandler = this.onClickHandler.bind(this);
  }

  componentDidMount() {
    // Add custom event via `addEventListener`
    //
    // The list of supported React events does include `mouseleave`
    // via `onMouseLeave` prop
    //
    // However, we are not adding the event the `React way` - this will have
    // effects on how state mutates
    //
    // Check the list here - https://facebook.github.io/react/docs/events.html
    document.getElementById('testButton').addEventListener('mouseleave', this.onMouseLeaveHandler);

    // Add JS timeout
    //
    // Again,outside React `world` - this will also have effects on how state
    // mutates
    setTimeout(this.onTimeoutHandler, 10000);

    // Make AJAX request
    fetch('https://api.github.com/users')
      .then(this.onAjaxCallback);
  }

  onClickHandler = () =&gt; {
    console.log('State before (_onClickHandler): ' + JSON.stringify(this.state));
    this.setState({
      dollars: this.state.dollars + 10
    });
    console.log('State after (_onClickHandler): ' + JSON.stringify(this.state));
  }

  onMouseLeaveHandler = () =&gt; {
    console.log('State before (mouseleave): ' + JSON.stringify(this.state));
    this.setState({
      dollars: this.state.dollars + 20
    });
    console.log('State after (mouseleave): ' + JSON.stringify(this.state));
  }

  onTimeoutHandler = () =&gt; {
    console.log('State before (timeout): ' + JSON.stringify(this.state));
    this.setState({
      dollars: this.state.dollars + 30
    });
    console.log('State after (timeout): ' + JSON.stringify(this.state));
  }

  onAjaxCallback = (err, res) =&gt; {
    if (err) {
      console.log('Error in AJAX call: ' + JSON.stringify(err));
      return;
    }

    console.log('State before (AJAX call): ' + JSON.stringify(this.state));
    this.setState({
      dollars: this.state.dollars + 40
    });
    console.log('State after (AJAX call): ' + JSON.stringify(this.state));
  }

  render() {
    console.log('State in render: ' + JSON.stringify(this.state));

    return (
       &lt;button
         id=&quot;testButton&quot;
         onClick={this.onClickHandler}&gt;
         'Click me'
      &lt;/button&gt;
    );
  }
}

ReactDOM.render(
  &lt;TestComponent /&gt;,
  document.getElementById('app')
);
</code></pre>

<h4 id="解决-setstate-函数异步的办法">解决 setState 函数异步的办法?</h4>

<p>根据 React 官方文档，setState 函数实际上接收两个参数，其中第二个参数类型是一个函数，作为 setState 函数执行后的回调。通过传入回调函数的方式，React 可以保证传入的回调函数一定是在 setState 成功更新 this.state 之后再执行</p>

<pre><code class="language-Jsx">_onClickHandler: function _onClickHandler() {
   console.log('State before (_onClickHandler): ' + JSON.stringify(this.state));
   this.setState({
   dollars: this.state.dollars + 10
   }, () =&gt; {
   console.log('Here state will always be updated to latest version!');
   console.log('State after (_onClickHandler): ' + JSON.stringify(this.state));
   });
}
</code></pre>

<h4 id="更多关于-setstate-的小知识">更多关于 setState 的小知识</h4>

<p>其实 setState 作为一个函数，本身是同步的。只是因为在 setState 的内部实现中，使用了 React updater 的 enqueueState 或者 enqueueCallback 方法，才造成了异步。</p>

<p>下面这段是 React 源码中 setState 的实现:</p>

<pre><code class="language-Jsx">ReactComponent.prototype.setState = function(partialState, callback) {
  invariant(
    typeof partialState === 'object' ||
    typeof partialState === 'function' ||
    partialState == null,
    'setState(...): takes an object of state variables to update or a ' +
    'function which returns an object of state variables.'
  );
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};
</code></pre>

<p>而 updater 的这两个方法，又和 React 底层的 Virtual Dom (虚拟 DOM 树)的 diff 算法有紧密的关系，所以真正决定同步还是异步的其实是 Virtual DOM 的 diff 算法。</p>

<p><img src="./setState.png" alt="./setState.png" /></p>

<p>对着上面的流程图可以简单总结一下：</p>

<ul>
<li>将 setState 传入的 partialState 参数存储在当前组件实例的 state 暂存队列中</li>
<li>判断当前 React 是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中</li>
<li>如果未处于批量更新状态，将批量更新状态标识设置为 true，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中</li>
<li>调用事务的 <code>waper</code> 方法，遍历待更新组件队列依次执行更新。</li>
<li>执行生命周期 <code>componentWillReceiveProps</code></li>
<li>将组件的 state 暂存队列中的 state 进行合并，获得最终要更新的 state 对象，并将队列置为空</li>
<li>执行生命周期 <code>componentShouldUpdate</code>，根据返回值判断是否要继续更新</li>
<li>执行生命周期 <code>componentWillUpdate</code></li>
<li>执行真正的更新，<code>render</code></li>
<li>执行生命周期 <code>componentDidUpdate</code></li>
</ul>

<p>Reference:</p>

<ul>
<li><a href="https://medium.com/@wereHamster/beware-react-setstate-is-asynchronous-ce87ef1a9cf3#.jhdhncws3">https://medium.com/@wereHamster/beware-react-setstate-is-asynchronous-ce87ef1a9cf3#.jhdhncws3</a></li>
<li><a href="https://www.bennadel.com/blog/2893-setstate-state-mutation-operation-may-be-synchronous-in-reactjs.htm">https://www.bennadel.com/blog/2893-setstate-state-mutation-operation-may-be-synchronous-in-reactjs.htm</a></li>
<li><a href="https://juejin.im/post/5c71050ef265da2db27938b5">【React 深入】setState 的执行机制</a></li>
</ul>

<h3 id="passing-a-function-to-setstate">Passing a function to setState</h3>

<p>我们已经提到过, setState 其实是异步的. 因为出于性能优化考虑, React 会将多次 setState 做一次批处理. 于是 setState 并不会在被调用之后立即改变我们的 state. 这就意味着你并不能依赖于在调用 setState 方法之后 state , 因为此时你并不能确认该 state 更新与否.</p>

<p>当然针对这个问题我们也有解决办法:用前一个 state(previous state) 作为需要传入函数的参数,将一个函数作为第二个参数传递给 setState ，这样做能保证你传入的函数需要取到的 state 一定会是被传入的 setState 执行之后的 state 。</p>

<h4 id="问题">问题：</h4>

<pre><code class="language-Jsx">// assuming this.state.count === 0
this.setState({count: this.state.count + 1});
this.setState({count: this.state.count + 1});
this.setState({count: this.state.count + 1});
// this.state.count === 1, not 3
</code></pre>

<h4 id="解决办法">解决办法：</h4>

<pre><code class="language-Jsx">this.setState((prevState, props) =&gt; ({
  count: prevState.count + props.increment
}));
</code></pre>

<h4 id="and-more">and More：</h4>

<pre><code class="language-Jsx">// Passing object
this.setState({ expanded: !this.state.expanded });

// Passing function
this.setState(prevState =&gt; ({ expanded: !prevState.expanded }));
</code></pre>

<p>Reference：</p>

<ul>
<li><a href="https://medium.com/javascript-scene/setstate-gate-abc10a9b2d82">setState() Gate</a></li>
<li><a href="http://stackoverflow.com/questions/43428456/do-i-need-to-use-setstatefunction-overload-in-this-case/43440790#43440790">Do I need to use setState(function) overload in this case?</a></li>
<li><a href="https://medium.freecodecamp.com/functional-setstate-is-the-future-of-react-374f30401b6b">Functional setState is the future of React</a></li>
</ul>

<h3 id="redux-reselect">Redux Reselect</h3>

<p>在 React-Redux 的 connect(mapState)中使用 Reselect, 这能避免频繁的重新渲染的发生。</p>

<p>Reslect 会记录下上一次函数调用的结果并且当再次以相同方式调用时返回相同的结果(而不是创建一个一模一样的新结果). 只有当传入的参数不同时，才会产生新的结果。</p>

<p>Reference:</p>

<ul>
<li><a href="https://medium.com/@esamatti/react-js-pure-render-performance-anti-pattern-fb88c101332f#.cz2ypc2ob">React</a></li>
<li><a href="http://redux.js.org/docs/recipes/ComputingDerivedData.html">Computing Derived Data: Docs</a></li>
</ul>

<h3 id="dependency-injection">Dependency Injection</h3>

<p>在 React 中，想做依赖注入(Dependency Injection)其实相当简单，具体有以下方法：</p>

<ul>
<li>HOC——高阶组件(high-order component)</li>
<li>Context 传递（在最新的 React 官方文档中，Context 已经不太被官方推荐使用了：<a href="https://reactjs.org/docs/context.html#why-not-to-use-context">Why Not To Use Context</a></li>
</ul>

<p>Reference:</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=IKD2-MAkXyQ">What is Dependency Injection?</a></li>
<li><a href="https://www.youtube.com/watch?v=jXhdOTw1q5Q">The Basics of Dependency Injection</a></li>
<li><a href="http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript">Dependency injection in JavaScript</a></li>
<li><a href="https://github.com/krasimir/react-in-patterns/tree/master/patterns/dependency-injection">DI In React</a></li>
</ul>

<h3 id="react-lazy">React Lazy</h3>

<p><code>React Lazy</code> 是 16.6 之后添加的功能。需要配合 <code>react.Suspense</code> 使用。</p>

<p>类似社区实现的 <a href="https://github.com/jamiebuilds/react-loadable">react-loadable</a> ，在之前我们是通过 webpack 的 <code>require.ensure</code> 或者自己封装 <code>import()</code> 来实现，本质上都是 <code>code splitting</code>。</p>

<h3 id="react-hooks">React hooks</h3>

<p><code>Hooks</code> 是 16.7 之后新添加的功能。</p>

<p>React Team 收了 <a href="https://github.com/acdlite/recompose">recompose</a> 演化成了 <code>Hooks</code></p>

<p>简单理解<code>Hooks</code> 是一种函数，该函数允许你“勾住（hook into）”React 状态和来自函数组件的生命周期功能。</p>

<p>Hook 在类内部不起作用，它们允许你无需类就使用 React。</p>

<blockquote>
<p>可以通过取巧的方式实现：hook 里面返回 class component，传入相应的 props</p>
</blockquote>

<h4 id="hooks-种类">hooks 种类</h4>

<p>React 内置了一些 hook，如 <code>useState</code> 当然也可以创建自定义的 <code>Hooks</code> 以在不同的组件当中复用状态。</p>

<p>根据 React 官方给出的文档，Hooks 主要分为以下几种：</p>

<ul>
<li>State Hooks（可以实现 local state 或者 global state</li>
<li>Effect Hooks（可以实现 class 当中的一些 lifecycle</li>
<li>自定义 Hooks（主要用来复用组件逻辑和状态</li>
</ul>

<h4 id="注意事项">注意事项</h4>

<p>官方定义了一些 rules of hooks，也就是使用 hooks 时候需要注意的内容：</p>

<ul>
<li>只能在顶层调用 Hook，不要在循环、条件或嵌套函数中调用 Hook。</li>
<li>仅从 React 功能组件调用 Hook。不要从常规 JavaScript 函数调用 Hook。（还有另一个有效的地方来调用 Hook，即你的自定义 Hook。）</li>
</ul>

<p>官方还提供了 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">linter plugin</a> 来检查并自动执行这些规则</p>

<h4 id="引入的背景">引入的背景</h4>

<p>为什么要引入 <code>Hooks</code> ，大概有以下原因（摘自<a href="https://reactjs.org/docs/hooks-intro.html#motivation">官方文档</a></p>

<ul>
<li>难以在组件之间重用有状态逻辑（组件树 🌲 过于臃肿</li>
<li>复杂的组件变得难以理解（状态逻辑和抽象过多</li>
<li>类让人和机器感到困惑（万恶的 this 和数据流的理解</li>
<li>逐步采用策略（感觉是提供新的 idea，并不是抛弃 class component 的写法</li>
</ul>

<blockquote>
<p>截止至（2018 年 10 月 29 日 15:21:47），社区已经出现了很多关于 hooks 的库和 idea，印象较深的是这个 <a href="https://github.com/streamich/react-use">react-use</a> ，看了一下源码对 hooks 的理解更多了一层</p>
</blockquote>

<p>Reference:</p>

<ul>
<li><a href="https://reactjs.org/docs/hooks-intro.html">offical intro hooks</a></li>
<li><a href="https://github.com/streamich/react-use">github react-use</a></li>
<li><a href="https://github.com/rehooks">github rehooks</a></li>
<li><a href="https://github.com/rehooks/awesome-react-hooks">github awesome react hoos list</a></li>
<li><a href="https://github.com/f/react-hooks-todo-app">github react hooks todo app</a></li>
<li><a href="https://github.com/semlinker/reactjs-interview-questions">List of top 301 ReactJS Interview Questions &amp; Answers</a></li>
</ul>

<h3 id="react-fiber-浅析">React Fiber（浅析）</h3>

<p>React 团队重写了核心算法 <a href="https://reactjs.org/docs/reconciliation.html">Reconciliation</a>，优化在动画、手势等应用中的效果，通常将之前的 <code>reconciler</code> 称为 <code>stack reconciler</code>，重写后的称为 <code>fiber reconciler</code>，简称为 <code>Fiber</code></p>

<blockquote>
<p>关于 <code>React Fiber Reconciliation</code> 可以看<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017</a>，或者看这篇文章<a href="https://juejin.im/post/5ab7b3a2f265da2378403e57">《React Fiber》</a> 用文字版解释了 Link Clark 的视频</p>
</blockquote>

<p>Fiber 也称协程，这个概念在很多语言当中都存在，比如 go 的 <code>Coroutine</code>，还有前端开发者比较熟悉的 ES6 新增的 <code>Generator</code>，协程函数它只是一种控制流程的让出机制，可以中断和恢复函数</p>

<p>React Fiber 的思想和协程的概念是契合的: 🔴React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</p>

<blockquote>
<p>也可以理解 React 实现了<a href="https://github.com/facebook/react/blob/master/packages/scheduler/src/Scheduler.js#L48-L60">Scheduler（调度器）</a>来调度优先级不同的任务（任务包含 JS 的执行、页面的渲染、ui 事件的响应等等）</p>
</blockquote>

<p>具体更详细的介绍可以查看我转载的这篇文章：<a href="/blog/2019-10-23-转载这可能是最通俗的-react-fiber时间分片-打开方式/">转载：这可能是最通俗的-react-fiber 时间分片-打开方式</a></p>

<p>Reference:</p>

<ul>
<li><a href="https://reactjs.org/docs/reconciliation.html">Reconciliation</a></li>
<li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017</a></li>
<li><a href="https://juejin.im/post/5ab7b3a2f265da2378403e57">《React Fiber》</a></li>
<li><a href="https://github.com/facebook/react/blob/master/packages/scheduler/src/Scheduler.js#L48-L60">Scheduler（调度器）</a></li>
<li><a href="https://juejin.im/post/5dadc6045188255a270a0f85">这可能是最通俗的 React Fiber(时间分片) 打开方式</a></li>
</ul>

    </section>
    <nav class="no-print post-nav">
        
        <a class="prev-post" href="https://hasaki.xyz/blog/2017-09-12-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E5%92%8C%E9%94%99%E8%AF%AF%E6%8D%95%E6%8D%89/">
            <img class="icon-text" src="/img/prev.svg"/>前端性能检测和错误捕捉</a>
        
        
        <a class="next-post" href="https://hasaki.xyz/blog/2017-12-13-react-native-art/">React Native ART 介绍与实践<img class="icon-text" src="/img/next.svg"/>
        </a>
        
    </nav>
</article>



<div id="disqus_thread" class="no-print"></div>
<script type="text/javascript">
  'use strict'
  ;(function() {
    if ('localhost' != window.location.hostname) {
      var a = document.querySelector('#disqus_thread')
      new IntersectionObserver(
        function(b) {
          b.forEach(function(d) {
            if (0 < d.intersectionRatio && !a.classList.contains('active')) {
              var e = document.createElement('script')
              ;(e.type = 'text/javascript'), (e.async = !0)
              ;(e.src =
                '//' + 'hasaki-xyz' + '.disqus.com/embed.js'),
                (
                  document.getElementsByTagName('head')[0] ||
                  document.getElementsByTagName('body')[0]
                ).appendChild(e),
                a.classList.add('active')
            }
          })
        },
        { rootMargin: '0px', threshold: 1 },
      ).observe(a)
    }
  })()
</script>

<script type="text/javascript">
  window.customElements.define(
    'back-to-top',
    class BackToTop extends HTMLElement {
      constructor() {
        super()
      }

      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: 'open' })

        shadowRoot.innerHTML = `
          <style>
            :host {
              box-sizing: border-box;
              position: fixed;
              width: 55px;
              height: 55px;
              bottom: 8%;
              right: 3%;
              border-radius: 5px;
              display: flex;
              justify-content: center;
              align-items: center;
              flex-direction: column;
              cursor: pointer;
              will-change: transform;
              transform: translate3d(0, 500px, 0);
              transition: transform 1s ease;
              background: #ff8181;
              border: 1px solid #ff8181;
              color: #fff;
            }
            :host(.show) {
              transform: translate3d(0, 0, 0);
            }
            :host::after,
            :host::before {
              content: '';
              display: block;
              box-sizing: border-box;
              position: relative;
            }
            :host::before {
              width: 8px;
              height: 8px;
              border-top: 2px solid;
              border-left: 2px solid;
              transform: rotate(45deg);
              top: 4px;
            }
            :host::after {
              width: 2px;
              height: 16px;
              top: -4px;
              background: currentColor;
            }
        `

        shadowRoot.host.addEventListener('click', e => {
          window.scrollTo({
            top: 0,
            left: 0,
            behavior: 'smooth',
          })
        })

        const scrollHeight = document.documentElement.scrollHeight

        window.addEventListener('scroll', e => {
          if (document.documentElement.scrollTop > scrollHeight / 4) {
            shadowRoot.host.classList.add('show')
          } else {
            shadowRoot.host.classList.remove('show')
          }
        })
      }
    },
  )
</script>
<back-to-top></back-to-top>


<style rel="catalog">
  #catalog {
    position: fixed;
    min-width: 12vw;
    left: 3vw;
    top: 8vh;
    overflow: auto;
    height: calc(100% - 16vh);
    background:
      linear-gradient(
        white 30%,
        rgba(255, 255, 255, 0)
      ),
      linear-gradient(rgba(255, 255, 255, 0), white 70%) 0 100%,
       
        radial-gradient(
          50% 0,
          farthest-side,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        ),
      radial-gradient(
          50% 100%,
          farthest-side,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        )
        0 100%;
    background:
      linear-gradient(
        white 30%,
        rgba(255, 255, 255, 0)
      ),
      linear-gradient(rgba(255, 255, 255, 0), white 70%) 0 100%,
       
        radial-gradient(
          farthest-side at 50% 0,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        ),
      radial-gradient(
          farthest-side at 50% 100%,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        )
        0 100%;
    background-repeat: no-repeat;
    background-color: white;
    background-size: 100% 40px, 100% 40px, 100% 14px, 100% 14px;

     
    background-attachment: local, local, scroll, scroll;
  }
  @media (max-width: 1280px) {
    #catalog {
      display: none;
    }
  }

  #catalog::-webkit-scrollbar {
    display: none;
  }

  .cl-wrapper {
    position: relative;
  }

  .cl-wrapper ul,
  .cl-wrapper li {
    margin: 0;
    -moz-padding-start: 12px;
    -webkit-padding-start: 12px;
    list-style: none;
  }

  .cl-wrapper li > .cl-link.cl-link-active {
    color: #ff8181;
    transition: 0.5s;
  }

  .cl-wrapper li > .cl-transform.cl-link-active {
    transform: translate(3px);
  }

  .cl-wrapper .cl-link {
    cursor: pointer;
    color: rgba(52, 73, 94, 0.5);
    font-size: 13px;
    transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
  }

  .cl-wrapper .cl-marker {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }

  .cl-wrapper .cl-marker path {
    transition: all 0.3s ease;
  }
</style>
<main id="catalog"></main>
<script rel="catalog">
  void (function() {
    if (
      window.innerWidth < 1024 ||
      /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)
    ) {
      return
    }

    const Catalog = (function() {
      return function(opts) {
        let defaultOpts = {
          linkClass: 'cl-link', 
          linkActiveClass: 'cl-link-active', 
          datasetName: 'data-cata-target', 
          selector: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'], 
          scrollWrapper: null, 
          activeHook: null, 
          topMargin: 0,
          bottomMargin: 0,
          cool: true, 
        }

        const Opt = Object.assign({}, defaultOpts, opts)

        const $content = document.getElementById(Opt.contentEl) 
        const $scroll_wrap = window 
        const $catalog = document.getElementById(Opt.catalogEl) 

        let allCatalogs = $content.querySelectorAll(Opt.selector.join())
        let tree = getCatalogsTree(allCatalogs)

        try {
          $catalog.innerHTML = `<div class='cl-wrapper'>${generateHtmlTree(
            tree,
            { id: -1 },
          )}<svg class="cl-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
            <path stroke="#ff8181" stroke-width="3" fill="transparent" stroke-dasharray="0, 0, 0, 1000" stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)" />
            </svg></div>`
        } catch (e) {
          console.error('error in progress-catalog', e)
        }

        const tocPath = $catalog.querySelector('.cl-marker path')
        let tocItems, pathLength 

        
        window.addEventListener('resize', drawPath)
        $catalog.addEventListener('click', clickHandler)
        Opt.cool && $scroll_wrap.addEventListener('scroll', coolScrollHandler)
        Opt.cool || $scroll_wrap.addEventListener('scroll', simpleScrollHandler)

        setTimeout(drawPath) 

        

        function drawPath() {
          tocItems = [...$catalog.querySelectorAll('li')]
          tocItems = tocItems.map(function(liDom) {
            const anchor = liDom.querySelector(`.${Opt.linkClass}`)
            const target = document.getElementById(
              anchor.getAttribute('data-cata-target'),
            )

            return {
              listItem: liDom,
              anchor: anchor,
              target: target,
            }
          })
          tocItems = tocItems.filter(item => !!item.target)

          const path = []
          let pathIndent

          tocItems &&
            tocItems.forEach(function(item, idx) {
              const { offsetLeft, offsetTop, offsetHeight } = item.anchor,
                x = Opt.cool ? offsetLeft - 5 : offsetLeft,
                y = offsetTop,
                height = offsetHeight

              if (idx === 0) {
                path.push('M', x, y, 'L', x, y + height)
                item.pathStart = 0
              } else {
                if (pathIndent !== x) path.push('L', pathIndent, y) 
                path.push('L', x, y)
                tocPath.setAttribute('d', path.join(' '))
                item.pathStart = tocPath.getTotalLength() || 0
                path.push('L', x, y + height)
              }
              pathIndent = x
              tocPath.setAttribute('d', path.join(' '))
              item.pathEnd = tocPath.getTotalLength()
            })
          pathLength = tocPath.getTotalLength()
          coolScrollHandler()
        }

        

        function coolScrollHandler() {
          const wrapHeight = document.documentElement.offsetHeight
          let pathStart = pathLength,
            pathEnd = 0,
            visibleItems = 0
          tocItems.forEach(function(liItem) {
            const { bottom, top } = liItem.target.getBoundingClientRect(),
              firstChild = liItem.listItem.firstChild
            if (bottom > Opt.topMargin && top < wrapHeight - Opt.bottomMargin) {
              firstChild.classList.remove(Opt.linkActiveClass)
              Opt.cool && firstChild.classList.remove('cl-transform')
            } else {
              pathStart = Math.min(liItem.pathStart, pathStart)
              pathEnd = Math.max(liItem.pathEnd, pathEnd)
              visibleItems += 1
              firstChild.classList.add(Opt.linkActiveClass)
              Opt.cool && firstChild.classList.add('cl-transform')
            }
          })
          if (visibleItems > 0 && pathStart < pathEnd && Opt.cool) {
            tocPath.setAttribute('stroke-dashoffset', '1')
            tocPath.setAttribute(
              'stroke-dasharray',
              `1, ${pathStart}, ${pathEnd - pathStart}, ${pathLength}`,
            )
            tocPath.setAttribute('opacity', '1')
          } else {
            tocPath.setAttribute('opacity', '0')
          }
        }

        

        function simpleScrollHandler(el) {
          let scrollToEl = null
          for (let i = allCatalogs.length - 1; i >= 0; i--) {
            if (allCatalogs[i].offsetTop <= $scroll_wrap.scrollTop) {
              scrollToEl = allCatalogs[i]
              break
            }
          }
          if (scrollToEl) setActiveItem(scrollToEl.id)
          else setActiveItem(null) 
        }

        

        function clickHandler({ target }) {
          const datasetId = target.getAttribute(Opt.datasetName)
          target.classList.contains(Opt.linkClass) &&
            document
              .getElementById(datasetId)
              .scrollIntoView({ behavior: 'smooth', block: 'start' })
        }

        

        function getCatalogsTree(catalogs) {
          let title,
            tagName,
            tree = [],
            treeItem = {},
            parentItem = { id: -1 },
            lastTreeItem = null,
            id

          for (let i = 0; i < catalogs.length; i++) {
            title = catalogs[i].innerText || catalogs[i].textContent
            tagName = catalogs[i].tagName
            id = 'heading-' + i
            catalogs[i].id = id
            treeItem = {
              name: title,
              tagName: tagName,
              id: id,
              level: +getLevel(tagName),
              parent: parentItem,
            }
            if (lastTreeItem) {
              if (getLevel(treeItem.tagName) > getLevel(lastTreeItem.tagName)) {
                treeItem.parent = lastTreeItem
              } else {
                treeItem.parent = findParent(treeItem, lastTreeItem)
              }
            }
            lastTreeItem = treeItem
            tree.push(treeItem)
          }
          return tree
        }

        

        function findParent(currTreeItem, lastTreeItem) {
          let lastTreeParent = lastTreeItem.parent
          while (
            lastTreeParent &&
            getLevel(currTreeItem.tagName) <= getLevel(lastTreeParent.tagName)
          ) {
            lastTreeParent = lastTreeParent.parent
          }
          return lastTreeParent || { id: -1 }
        }

        

        function getLevel(tagName) {
          return tagName ? tagName.slice(1) : 0
        }

        

        function generateHtmlTree(tree, _parent) {
          let ul,
            hasChild = false
          if (tree) {
            ul = `<ul>`
            for (let i = 0; i < tree.length; i++) {
              if (isEqual(tree[i].parent, _parent)) {
                hasChild = true
                ul += `<li><div class='${Opt.linkClass} cl-level-${tree[i].level}' ${Opt.datasetName}='${tree[i].id}'>${tree[i].name}</div>`
                ul += generateHtmlTree(tree, tree[i])
                ul += '</li>'
              }
            }
            ul += `</ul>`
          }
          return hasChild ? ul : ''
        }

        /**
         * 判断是否是相同节点
         */
        function isEqual(node, node2) {
          return (
            node &&
            node2 &&
            typeof node === 'object' &&
            typeof node2 === 'object' &&
            node.id === node2.id
          )
        }

        /**
         *  设置选中的项
         */
        function setActiveItem(id) {
          let catas = [...$catalog.querySelectorAll(`[${Opt.datasetName}]`)]

          catas.forEach(T => {
            if (T.getAttribute(Opt.datasetName) === id) {
              typeof Opt.activeHook === 'function' &&
                !T.classList.contains(Opt.linkActiveClass) &&
                Opt.activeHook.call(this, T) // 执行active钩子
              T.classList.add(Opt.linkActiveClass)
            } else {
              T.classList.remove(Opt.linkActiveClass)
            }
          })
        }
      }
    })()
    window.addEventListener('DOMContentLoaded', function() {
      new Catalog({
        contentEl: 'markdown',
        catalogEl: 'catalog',
      })
    })
  })()
</script>

			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				
<a href="mailto:iamnomand@gmail.com"><img class="icon-social" src="/img/email.svg" alt="Email Me!"/></a>


<a href="https://github.com/v-tom/"><img class="icon-social" src="/img/github.svg" alt="Github"/></a>


<a href="https://twitter.com/iamnomand"><img class="icon-social" src="/img/twitter.svg" alt="Twitter"/></a>

<a href="https://hasaki.xyz/index.xml" target="_blank"><img class="icon-social" src="/img/feed.svg" alt="Feed"></a>

				<p>
					
					
					Early 2016 ~ 2020 &copy; TOM's Zone
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
		<script>hljs.initHighlightingOnLoad();</script>
		
	</body>
</html>


<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-108259988-2"
></script>
<script>
  window.dataLayer = window.dataLayer || []
  function gtag() {
    dataLayer.push(arguments)
  }
  gtag('js', new Date())

  gtag('config', 'UA-108259988-2')
</script>

