<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="Keywords" content="">
    <meta name="full-screen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#006cb4">
    <meta name="apple-mobile-web-app-title" content="TOM&#39;s zone">
    <meta name="description" content="TOM&#39;s zone">
    <link rel="dns-prefetch" href="https://hasaki.xyz">
    <link rel="preconnect" href="https://hasaki.xyz">
    <link rel="manifest" href="/sw/manifest.json"/>
<title>使用 Rust 编写 WebAssembly  - TOM&#39;s zone</title>

<meta name="description" content="老规矩，列出本机器环境
 system_profiler SPSoftwareDataType : macOS 10.14.3 (18D42) Darwin 18.2.0 cargo --version cargo 1.38.0-nightly (e3563dbdc 2019-07-16) rustc --version rustc 1.38.0-nightly (311376d30 2019-07-18) wasm-pack -V wasm-pack 0.8.1 clang --version x86_64-apple-darwin18.2.0 posix LVVM Apple LLVM version 10.0.0 (clang-1000.10.44.4)  JavaScript 历史 JavaScript 于 1995 年问世，它的设计初衷并不是为了执行起来快，在前 10 个年头，它的执行速度也确实不快。被人们广为传播的“性能大战”在 2008 年打响。许多浏览器引入了 Just-in-time 编译器，也叫 JIT。JavaScript 代码的运行渐渐变快
随着性能的提升，JavaScript 可以应用于后端开发的 Node.js。性能的提升使得 JavaScript 的应用范围得到很大的扩展。
现在通过 WebAssembly，JavaScript 的性能可以再次提速。
JIT 计算机使用的是机器语言，也就是 010101 二进制，而我们编写的 JavaScript 代码是基于人类的认知而设计出来的高级编程语言，所以需要引擎把把人类的语言转换成机器能看懂的语言。
这就像电影《降临》中，人类和外星人的互相交流一样
在代码的世界中，通常有两种方式来翻译机器语言：解释器和编译器。
 如果是通过解释器，翻译是一行行地边解释边执行 编译器是把源代码整个编译成目标代码，执行时不再需要编译器，直接在支持目标代码的平台上运行。  这两种翻译的方式都各有利弊。">




    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">


    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/ocean.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/javascript.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/python.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/css.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/swift.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/objectivec.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/rust.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/yaml.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/bash.min.js"></script>


    <link rel="stylesheet" href="/css/bundle.min.css"/>
<script src="/js/bundle.js"></script>

<style>
	a { color: #ff8181; }
	blockquote {
		background: rgba(255, 129, 129, .1);
		border-left-color: #ff8181;
		border-right-color: #ff8181; }
	.bar a:hover {
		color: #ff8181;
		text-decoration: none; }
	.sep {
		margin-top: 2rem;
		margin-bottom: 1rem;
		margin-left:0;
		width: 24rem;
		border-top: 2px solid #ff8181; }
    .bar li.active a{
        color:#ff8181;
    }
</style>

</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li>
		
		<li class="active"><a href="/blog/">Blog</a></li>
		<li class=""><a href="/gallery/">Gallery</a></li>
		<li class=""><a href="/life/">Life</a></li></ul>
</nav>

	</div>
</header>
<main class="container">

<article>
    <header><hgroup id="brand">
  <h1>使用 Rust 编写 WebAssembly </h1>
  <h5>
    
    <time datetime="2019-07-20 15:42:40 &#43;0800 CST">Jul 20, 2019</time>
    <span class="no-print">
      -
      
      <a href="/tags/rust">Rust</a>
      
      <a href="/tags/webassembly">WebAssembly</a>
      
      <a href="/tags/frontend">FrontEnd</a>
      </span>
  </h5>

  <a
    style="margin-top: 1.2rem;display: inline-block;"
    href="https://github.com/V-Tom/blog/blob/hugo/content/blog/2019-07-20-%e4%bd%bf%e7%94%a8%20Rust%20%e7%bc%96%e5%86%99%20WebAssembly%20/index.md"
    >✨✨✨You can Edit this Article on Github site</a
  >

  <div id="git-update-time">
  ✏️✏️✏️ This article .MD file was last updated at:
  <b>Loading ...</b>
</div>

<script data-name="commits">
  ;(async () => {
    const b = document.querySelector('#git-update-time').querySelector('b')

    if (window.location.href.includes('localhost')) {
      b.innerHTML = 'localhost disable'
      return
    }

    const commits = await fetch(
      'https://api.github.com/repos/V-Tom/blog/commits?sha=hugo&path=content/blog\/2019-07-20-使用 Rust 编写 WebAssembly \/index.md',
    ).then(res => res.json())
    try {
      const time = new Date(commits[0].commit.committer.date)
      b.innerHTML = `${time.getFullYear()}-${time.getMonth() +
        1}-${time.getDate()}`
    } catch (e) {
      b.innerHTML = 'unknown'
    }
  })()
</script>


  
</hgroup>
<hr class="sep" />
</header>
    <section id="markdown">
        

<p>老规矩，列出本机器环境</p>

<ul>
<li><code>system_profiler SPSoftwareDataType</code> : macOS 10.14.3 (18D42) Darwin 18.2.0</li>
<li><code>cargo --version</code> cargo 1.38.0-nightly (e3563dbdc 2019-07-16)</li>
<li><code>rustc --version</code> rustc 1.38.0-nightly (311376d30 2019-07-18)</li>
<li><code>wasm-pack -V</code> wasm-pack 0.8.1</li>
<li><code>clang --version</code> x86_64-apple-darwin18.2.0 posix</li>
<li><code>LVVM</code> Apple LLVM version 10.0.0 (clang-1000.10.44.4)</li>
</ul>

<h2 id="javascript-历史">JavaScript 历史</h2>

<p>JavaScript 于 1995 年问世，它的设计初衷并不是为了执行起来快，在前 10 个年头，它的执行速度也确实不快。被人们广为传播的“性能大战”在 2008 年打响。许多浏览器引入了 Just-in-time 编译器，也叫 JIT。JavaScript 代码的运行渐渐变快</p>

<p>随着性能的提升，JavaScript 可以应用于后端开发的 Node.js。性能的提升使得 JavaScript 的应用范围得到很大的扩展。</p>

<p><img src="./jit.png" alt="jit.png" /></p>

<p>现在通过 WebAssembly，JavaScript 的性能可以再次提速。</p>

<p><img src="./after-jit.png" alt="after-jit.png" /></p>

<h2 id="jit">JIT</h2>

<p>计算机使用的是机器语言，也就是 010101 二进制，而我们编写的 JavaScript 代码是基于人类的认知而设计出来的高级编程语言，所以需要引擎把把人类的语言转换成机器能看懂的语言。</p>

<p>这就像电影《降临》中，人类和外星人的互相交流一样</p>

<p><img src="./arrival.png" alt="arrival.png" /></p>

<p>在代码的世界中，通常有两种方式来翻译机器语言：解释器和编译器。</p>

<ul>
<li>如果是通过解释器，翻译是一行行地边解释边执行</li>
<li>编译器是把源代码整个编译成目标代码，执行时不再需要编译器，直接在支持目标代码的平台上运行。</li>
</ul>

<p>这两种翻译的方式都各有利弊。</p>

<p><img src="./interpreter.png" alt="interpreter.png" /></p>

<blockquote>
<p>解释器启动和执行的更快。你不需要等待整个编译过程完成就可以运行你的代码。从第一行开始翻译，就可以依次继续执行了，这样可以很快速的执行代码并看到结果。</p>

<p>可是当你运行同样的代码一次以上的时候，解释器的弊处就显现出来了。比如你执行一个循环，那解释器就不得不一次又一次的进行翻译，这样效率十分低下。</p>
</blockquote>

<p><img src="./compiler.png" alt="compiler.png" /></p>

<blockquote>
<p>编译器的问题则恰好相反。它需要花一些时间对整个源代码进行编译，然后生成目标文件才能在机器上执行。对于有循环的代码执行的很快，因为它不需要重复的去翻译每一次循环。</p>
</blockquote>

<p>而 Just-in-time 编译器：综合了两者的优点，首先可以以解释器的形式去翻译，接着 JIT 监视代码的运行状态，把 hot 代码（重复执行多次的代码）进行优化，生成一个更快速和高效的代码版本出来，并且存储之。</p>

<p>但是为了使执行速度变快，JIT 会增加很多多余的开销，远不如 AOT（Ahead-of-Time ）方式性能好。</p>

<p>而且对于 JavaScript 这种动态数据类型的语言来说，要实现一个完美的 JIT 非常难。因为 JavaScript 中的很多东西都是在运行的时候才能确定的。</p>

<h2 id="llvm">LLVM</h2>

<blockquote>
<p>编译器如何生成汇编的过程可以简单说为：编译器的前端把高级语言翻译到 IR（Intermediate Representation，中间端表达式），编译器的后端把 IR 翻译成目标机器的汇编代码。这里我们着重介绍 LLVM</p>
</blockquote>

<p><a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a>包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。最初被用来取代现有于 GCC 堆栈的程式码产生器，LLVM 目前支援了很多种语言。</p>

<p>提供了完整编译系统的中间层，它会将中间语言 IR 从编译器取出与最佳化，最佳化后的 IR 接着被转换及链结到目标平台的汇编语言。LLVM 可以接受来自 GCC 工具链所编译的 IR，包含它底下现存的编译器。</p>

<p>在 LLVM 的编译当中，存在三个阶段，图片来自 <a href="http://www.aosabook.org/en/llvm.html">asoa book</a>：</p>

<p><img src="./Schema.png" alt="Schema.png" /></p>

<ul>
<li><code>frontend</code> ：解析原始语言并吐出 LLVM 中间表示（IR）代码</li>
<li><code>optimiser</code>：LLVM 的核心是中间端表达式 IR，一种类似汇编的底层语言。IR 是一种强类型的精简指令集（Reduced Instruction Set Computing，RISC），并对目标指令集进行了抽象。</li>
<li><code>backend</code> ：采用 IR 并生成针对特定 CPU 优化的机器代码。</li>
</ul>

<p>我们可以通过 <code>brew install llvm</code> 在 mac 上安装 LVVM，然后通过一个最简单的代码来理解其中的过程，一个命名为 <code>sample.c</code> 的文件：</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
  return 0;
}
</code></pre>

<p><code>frontend</code> 阶段：通过命令 <code>clang -emit-llvm -S sample.c</code> 转换为 LVVM IR，得到以下代码，注意后面的注释是我根据理解添加：</p>

<pre><code class="language-IR">define i32 @main() #0 { // 定义一个命名为 main 并且返回 32 bit 整型的函数
  %1 = alloca i32, align 4 // 在栈上分配 32 位的整型，align 4 保证地址一定是 4 的倍数
  store i32 0, i32* %1, align 4 // 指针
  ret i32 0 // 返回结果
}
</code></pre>

<p>接下来我们可以继续优化这个 IR ，也就是 <code>optimiser</code> 阶段。</p>

<p>我们可以加参数 <code>-Os</code> 来自动完成优化： <code>clang -emit-llvm -S -oS sample.c</code> 得到的 IR 代码为：</p>

<pre><code class="language-IR">define i32 @main() local_unnamed_addr #0 {
  ret i32 0
}
</code></pre>

<p>最后就是 <code>backend</code> 阶段生成对应的机器码，这里我们生成 x86-64 平台的机器码：<code>llc -O3 sample.ll -march=x86-64 -o sample-x86-64.s</code></p>

<blockquote>
<p>在本机环境当中，<code>llc</code> 需要指定 PATH ：<code>export PATH=&quot;/usr/local/opt/llvm/bin:$PATH&quot;</code></p>
</blockquote>

<pre><code class="language-s">	.section	__TEXT,__text,regular,pure_instructions
	.macosx_version_min 10, 14
	.globl	_main                   ## -- Begin function main
	.p2align	4, 0x90
_main:                                  ## @main
	.cfi_startproc
## %bb.0:
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register %rbp
	movl	$0, -4(%rbp)
	xorl	%eax, %eax
	popq	%rbp
	retq
	.cfi_endproc
                                        ## -- End function

.subsections_via_symbols
</code></pre>

<p>也可以生成 ARM 平台的机器码：<code>llc -O3 sample.ll -march=arm -o sample-arm.s</code></p>

<p>在 WebAssembly 成为标准之前，还有一个 <a href="http://asmjs.org/">asm.js</a>。</p>

<p>以及这个通过 LVVM 来实现的伪 Assembly： <a href="https://github.com/ts-llvm/ts-llvm">ts-llvm</a>，以及这个 <a href="https://github.com/ovr/StaticScript">StaticScript</a>，基本实现流程如下：</p>

<p><img src="./how-ts-llvm-works.png" alt="how-ts-llvm-works.png" /></p>

<h2 id="webassembly">WebAssembly</h2>

<blockquote>
<p>WebAssembly not Assembly</p>
</blockquote>

<p><img src="./where-wasm-in-complie.png" alt="where-wasm-in-complie.png" /></p>

<p>我们已经知道了编译器是如何从高级语言翻译到机器码的，上图中 WebAssembly 在什么位置呢？实际上，你可以把它看成另一种 <strong>目标汇编语言</strong> ：可以抽象地理解成它是概念机器的机器语言，而不是实际的物理机器的机器语言。</p>

<p><img src="./wasm-in-complie.png" alt="wasm-in-complie.png" /></p>

<p>假设想从 C 语言到 WebAssembly。</p>

<p>我们就需要 clang 前端来把 C 代码变成 LLVM 中间代码。当变换成了 LLVM IR 时，说明 LLVM 已经理解了代码，它会对代码自动地做一些优化，最后通过后端编译器从 LLVM IR 生成 WebAssembly，</p>

<p><img src="./wasm-complier-toolchain.png" alt="wasm-complier-toolchain.png" /></p>

<h2 id="why-webassembly-fast">why WebAssembly fast</h2>

<p>不论哪种方式，WebAssembly 都更贴近机器码，所以它更快，使它更快的原因有几个：</p>

<ul>
<li>在编译优化代码之前，它不需要提前运行代码以知道变量都是什么类型。</li>
<li>编译器不需要对同样的代码做不同版本的编译。</li>
<li>很多优化在 LLVM 阶段就已经做完了，所以在编译和优化的时候没有太多的优化需要做。</li>
<li>垃圾回收阶段，WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。</li>
</ul>

<h2 id="rust">Rust</h2>

<blockquote>
<p>由于 Rust 对 WebAssembly 的支持度较好，所以例子我们采用 Rust 来实现</p>
</blockquote>

<p>Rust 的安装比较方便：<code>curl https://sh.rustup.rs -sSf | sh</code> 按照提示就可以安装了。</p>

<p>通常需要把~/.cargo/bin 加入\$PATH 里面的。运行下面的命令：</p>

<pre><code class="language-bash">echo PATH=&quot;$PATH:\$HOME/.cargo/bin&quot; &gt;&gt; you_profile &amp;&amp; source your_profile &amp;&amp; rustc --version
</code></pre>

<blockquote>
<p>your profile 根据你的 shell 环境而定，我用的 zsh 因此是 <code>~/.zshrc</code></p>
</blockquote>

<p>通过 rustup 安装了 Rust 之后，很容易更新到最新版本：<code>rustup update</code></p>

<p>值得注意的是，Rust 分为多个版本，对于支持 WebAssembly 的一些特性而言，需要 <code>nightly</code> 版本支持，使用下面的命令切换默认配置为 nightly：</p>

<pre><code class="language-bash">rustup toolchain install nightly
rustup default nightly
</code></pre>

<p>Cargo 是 Rust 的构建系统和包管理器。大多数 Rustacean 们使用 Cargo 来管理他们的 Rust 项目，因为它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库。</p>

<h3 id="简单入门-rust">简单入门 Rust</h3>

<p>我们可以通过 <code>cargo new wasm</code> 来创建一个新项目，它的目录结构看起来应该如此 <code>tree wasm</code>:</p>

<pre><code class="language-txt">wasm
├── Cargo.toml
└── src
    └── main.rs
</code></pre>

<blockquote>
<p><code>Cargo.toml</code> 使用 TOML 格式，这是 Cargo 配置文件，文件 <code>src/main.rs</code> 是项目默认的主入口，首次运行 <code>cargo build</code> 或者 <code>cargo run</code> 时，也会使 Cargo 在项目根目录创建一个新文件：Cargo.lock。这个文件记录项目依赖的实际版本，我们永远不要碰这个文件，让 Cargo 自行处理。</p>
</blockquote>

<p>查看 <code>src/main.rs</code> 可以看到这是一个基础模板代码：</p>

<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>

<p>接下来我们可以使用 <code>cargo run</code> 在一个命令中同时编译并运行生成的可执行文件：</p>

<pre><code class="language-txt">➜  wasm git:(master) ✗ cargo run
   Compiling wasm v0.1.0 (/Users/zhangchi416/Desktop/wasm)
    Finished dev [unoptimized + debuginfo] target(s) in 1.39s
     Running `target/debug/wasm`
Hello, world!
</code></pre>

<p>至此，简单的 Rust 入门算是完成了。</p>

<h3 id="wasm-pack">wasm-pack</h3>

<p>我们需要能够将 Rust 代码编译成 WebAssembly 的工具。这里推荐 <a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a>，可以按照官方文档自行安装：</p>

<pre><code class="language-bash">curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
</code></pre>

<p>它几乎是现在最佳的 WebAssembly 的编译器，上手几乎没有难度。</p>

<p>而且它和 npm 生态联动，使用起来和一些库很相似，尤其是 webpack。并且自动将 Rust 编译，并且产生 js 代码，这个 js 代码是对 wasm 调用的胶水封装，这样对开发者而言，使用起来就像一个普通的 js 包一样。</p>

<p>另外它还可以产生了 ts 的定义文件，方便 IDE 代码提示。</p>

<h2 id="sample-fibonacci">sample fibonacci</h2>

<blockquote>
<p>上面我们说到了 <code>wasm-pack</code> 对前端工程化十分友好，你可以通过 <code>cargo generate --git https://github.com/rustwasm/wasm-pack-template</code> 来生成 wasm-pack 的官方模板，我们这里采用自力更生的 <code>cargo new wasm</code></p>
</blockquote>

<p>继续回到上面的 <code>wasm</code> 文件目录。</p>

<p>首先我们更新 <code>dependencies</code>，并指定 <a href="https://doc.rust-lang.org/reference/linkage.html">crate-type</a> 为 <code>cdylib</code>，即动态链接类型，并指定默认的文件入口。这样<code>Cargo.toml</code> 文件为：</p>

<pre><code class="language-toml">[package]
name = &quot;wasm&quot;
version = &quot;0.1.0&quot;
authors = [&quot;YOUR NAME &lt;YOUR DEFAULT GIT CONFIG EMAIL&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = [&quot;cdylib&quot;]
path = &quot;src/main.rs&quot;

[dependencies]
wasm-bindgen = &quot;0.2.48&quot;
</code></pre>

<blockquote>
<p>如果你的 IDE 支持，更新 dependencies 后一般 IDE 是自动更新，否则需要手动执行 <code>Cargo update</code> 来更新包</p>
</blockquote>

<p><code>Cargo update</code>：</p>

<pre><code class="language-txt">➜  wasm git:(master) ✗ cargo update
    Updating crates.io index
      Adding bumpalo v2.5.0
			......
</code></pre>

<p>并更新 <code>src/main.rs</code> 为：</p>

<pre><code class="language-rs">use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn fibonacci(n: u32) -&gt; u32 {
    match n {
        0 =&gt; 1,
        1 =&gt; 1,
        _ =&gt; fibonacci(n - 1) + fibonacci(n - 2),
    }
}
</code></pre>

<p>上面定义了一个 <code>fibonacci</code> 函数，入参和输出结构都是 <code>u32</code>，下面简单介绍一下 Rust 的写法：</p>

<ul>
<li><code>use</code> 是 Rust 的模块系统当中的一个关键字，用来将路径（模块）引入作用域</li>
<li><code>#[]</code> 是 Rust 过程自定义宏，可以理解为元编程（metaprogramming)，全名是 <a href="https://rustlang-cn.org/office/rust/reference/macros/procedural-macros.html#derive-mode-macros">Derive mode macros</a></li>
<li><code>pub</code> 关键字使函数变为公有，对外可见</li>
<li><code>match</code> 关键字是 Rust 的模式匹配语法</li>
</ul>

<p>接下来编译成 wasm： <code>wasm-pack build --no-typescript --target web --mode normal</code>，这个编译初次会非常慢，可以耐心等待一会：</p>

<pre><code class="language-bash">➜  wasm git:(master) ✗ wasm-pack build --no-typescript --target web --mode normal
[INFO]: 🎯  Checking for the Wasm target...
[INFO]: 🌀  Compiling to Wasm...
   Compiling proc-macro2 v0.4.30
   Compiling unicode-xid v0.1.0
   Compiling wasm-bindgen-shared v0.2.48
   Compiling log v0.4.8
   Compiling syn v0.15.42
   Compiling cfg-if v0.1.9
   Compiling lazy_static v1.3.0
   Compiling bumpalo v2.5.0
   Compiling wasm-bindgen v0.2.48
   Compiling quote v0.6.13
   Compiling wasm-bindgen-backend v0.2.48
   Compiling wasm-bindgen-macro-support v0.2.48
   Compiling wasm-bindgen-macro v0.2.48
   Compiling wasm v0.1.0 (/Users/zhangchi416/Desktop/wasm)
    Finished release [optimized] target(s) in 38.37s
⚠️   [WARN]: origin crate has no README
[INFO]: ⬇️  Installing wasm-bindgen...
[INFO]: Optional fields missing from Cargo.toml: 'description', 'repository', and 'license'. These are not necessary, but recommended
[INFO]: ✨   Done in 38.71s
[INFO]: 📦   Your wasm pkg is ready to publish at ./pkg.
</code></pre>

<p>我们从 log 可以看到已经成功生成了 wasm pkg 在 <code>./pkg</code> 文件目录下：</p>

<pre><code class="language-bash">➜  wasm git:(master) ✗ tree pkg
pkg
├── package.json
├── wasm.js
└── wasm_bg.wasm

0 directories, 3 files
</code></pre>

<ul>
<li><code>wasm.js</code> 为 wasm-pack 自动生成的胶水文件</li>
<li><code>wasm_bg.wasm</code> 为我们的目标 WebAssembly 文件</li>
<li><code>package.json</code> 为 wasm-pack 自动生产符合 webpack 工程化的文件，我们这里不需要用到</li>
</ul>

<p>我们来看一下这个 WebAssembly 文件：</p>

<pre><code class="language-bash">➜  wasm git:(master) ✗ xxd pkg/wasm_bg.wasm
00000000: 0061 736d 0100 0000 0186 8080 8000 0160  .asm...........`
00000010: 017f 017f 0383 8080 8000 0200 0005 8380  ................
00000020: 8080 0001 0011 0796 8080 8000 0206 6d65  ..............me
00000030: 6d6f 7279 0200 0966 6962 6f6e 6163 6369  mory...fibonacci
00000040: 0001 0abc 8080 8000 0233 0101 7f41 0121  .........3...A.!
00000050: 0102 4020 0041 0249 0d00 4101 2101 0340  ..@ .A.I..A.!..@
00000060: 2000 417f 6a10 0020 016a 2101 2000 417e   .A.j.. .j!. .A~
00000070: 6a22 0041 014b 0d00 0b0b 2001 0b06 0020  j&quot;.A.K.... ....
00000080: 0010 000b 0bea 8380 8000 0100 4180 80c0  ............A...
00000090: 000b e003 0000 0000 0000 0000 0000 0000  ................
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000100: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000110: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000120: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000130: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000140: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000150: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000160: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000170: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000180: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000190: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000200: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000210: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000220: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000230: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000240: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000250: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000260: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000270: 0000 0000 00bb 8080 8000 046e 616d 6501  ...........name.
00000280: b080 8080 0002 0022 7761 736d 3a3a 6669  .......&quot;wasm::fi
00000290: 626f 6e61 6363 693a 3a68 3635 3438 3331  bonacci::h654831
000002a0: 3065 3231 3631 3533 3439 0109 6669 626f  0e21615349..fibo
000002b0: 6e61 6363 6900 8c81 8080 0009 7072 6f64  nacci.......prod
000002c0: 7563 6572 7302 086c 616e 6775 6167 6502  ucers..language.
000002d0: 0452 7573 7400 0452 7573 7404 3230 3138  .Rust..Rust.2018
000002e0: 0c70 726f 6365 7373 6564 2d62 7903 0572  .processed-by..r
000002f0: 7573 7463 2531 2e33 382e 302d 6e69 6768  ustc%1.38.0-nigh
00000300: 746c 7920 2833 3131 3337 3664 3330 2032  tly (311376d30 2
00000310: 3031 392d 3037 2d31 3829 0677 616c 7275  019-07-18).walru
00000320: 7305 302e 382e 300c 7761 736d 2d62 696e  s.0.8.0.wasm-bin
00000330: 6467 656e 1230 2e32 2e34 3820 2861 3364  dgen.0.2.48 (a3d
00000340: 6464 3039 3765 29                        dd097e)
</code></pre>

<p>这个文件看起来有点大：</p>

<pre><code class="language-bash">➜  wasm git:(master) ✗ du -sh pkg/wasm_bg.wasm
4.0K	pkg/wasm_bg.wasm
</code></pre>

<blockquote>
<p>我们可以通过一个 C++ 写的工具 <a href="https://github.com/webassembly/binaryen">wasm-opt</a>来继续优化这个 wasm 大小，也可以详细参考这篇文章<a href="https://rustwasm.github.io/book/reference/code-size.html">Shrinking .wasm Code Size</a></p>
</blockquote>

<p>接下来我们在 HTML 当中调用这个 WebAssembly：</p>

<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
  main()

  async function main() {
    // 引入胶水文件
    const wasm = await import('/pkg/wasm.js')
    // 加载 wasm
    await wasm.default('/pkg/wasm_bg.wasm')

    console.log(wasm.fibonacci(40))
  }
&lt;/script&gt;
</code></pre>

<p>并通过 <code>python3 -m http.server 8080</code> 启动本地服务器，在 <code>console</code> 当中等待一会可以看到结果：<code>165580141</code>，你可以在这里<a href="./sample-fibonacci.zip">下载示例代码</a></p>

<h2 id="webidl">WebIDL</h2>

<p><a href="https://heycam.github.io/webidl/">Web Interfaces</a> 作为扩展 JavaScript 对象 - 通常定义在 Web IDL（接口定义语言），是一种声明性语言。</p>

<p>WebIDL 能够提供浏览器的 API 接口给其他语言，这意味着操纵 DOM 不再是 JavaScript 专属。</p>

<p>Rust <code>wasm-bindgen</code> 实现了 <a href="https://github.com/rustwasm/wasm-bindgen/blob/master/crates/web-sys/README.md">web-sys</a>，提供了对浏览器在 Web 上提供的所有 API 的绑定，也就是 WebIDL 的实现，通俗来讲可以操作 DOM</p>

<blockquote>
<p>需要注意的是如果引入所有的 web-sys 绑定将会增加绑定文件的大小。按需引入必要的 API 是比较重要的。</p>
</blockquote>

<p>另外我们也可以了解一下 <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys">js-sys</a>，这是 <code>wasm-bindgen</code> 对项目的 JS 全局 API 进行原始绑定，通俗来讲可以使用 <code>Function</code>、<code>Reflect</code>等 JsValue</p>

<h2 id="sample-console-log">sample console.log</h2>

<p>我们先来根据上面的例子实现一个简单的 WebAssembly 调用 console 的功能。</p>

<p>首先我们实现 WebAssembly 调用 <code>console.log</code> ，实现有<a href="https://rustwasm.github.io/docs/wasm-bindgen/examples/console-log.html">多种多样的方式</a>，可以使用 <code>wasm_bindgen</code> 、<code>macro_rules（宏）</code>以及 <code>web-sys</code>，这里我们采用 <code>web-sys</code></p>

<p>在 <code>Cargo.toml</code> 文件尾部添加下依赖并自动安装依赖：</p>

<pre><code class="language-toml">[dependencies.web-sys]
version = &quot;0.3.4&quot;
features = [
  'console',
]
</code></pre>

<p>更改 <code>src/main.rs</code> 为:</p>

<pre><code class="language-rs">use wasm_bindgen::prelude::*;
use web_sys::console;

#[wasm_bindgen]
pub fn hello() {
    console::log_1(&amp;&quot;Hello Rust using web-sys&quot;.into());
}
</code></pre>

<p>使用 <code>wasm-pack</code> 编译后可以在浏览器当中看到已经输出：<code>Hello Rust using web-sys</code></p>

<blockquote>
<p>你可以在这里<a href="./sample-console.zip">下载当前代码</a></p>
</blockquote>

<h2 id="rust-dom">Rust DOM</h2>

<p>我们接下来根据上面的例子，来实现一个简单的 WebAssembly 调用 canvas 绘图的功能</p>

<p>根据上面的例子，我们已经在 <code>dependencies.web-sys</code> 添加了 <code>console</code>，实现 canvas 绘图需要更多的 <code>feature</code> 并更新依赖：</p>

<pre><code class="language-toml">[dependencies.web-sys]
version = &quot;0.3.4&quot;
features = [
  'Document',
  'Element',
  'HtmlElement',
  'Window',
  'Node',
  'console',
  'CanvasRenderingContext2d',
  'HtmlCanvasElement',
]
</code></pre>

<p>更新 <code>src/main.rs</code>：</p>

<pre><code class="language-rs">use std::f64;
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;
use web_sys;

#[wasm_bindgen]
pub fn canvas() -&gt; Result&lt;(), JsValue&gt; {
    let window = web_sys::window().expect(&quot;no global `window` exists&quot;);
    let document = window.document().expect(&quot;should have a document on window&quot;);
    let body = document.body().expect(&quot;document should have a body&quot;);


    let canvas = document.create_element(&quot;canvas&quot;)?;

    // 添加 canvas 到 DOM 节点
    body.append_child(&amp;canvas)?;

    // 绘制 canvas

    draw_canvas(canvas.dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()
        .map_err(|_| ())
        .unwrap()
    );

    Ok(())
}

fn draw_canvas(canvas: web_sys::HtmlCanvasElement) {
    let context = canvas
        .get_context(&quot;2d&quot;)
        .unwrap()
        .unwrap()
        .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()
        .unwrap();

    context.begin_path();

    // Draw the outer circle.
    context
        .arc(75.0, 75.0, 50.0, 0.0, f64::consts::PI * 2.0)
        .unwrap();

    // Draw the mouth.
    context.move_to(110.0, 75.0);
    context.arc(75.0, 75.0, 35.0, 0.0, f64::consts::PI).unwrap();

    // Draw the left eye.
    context.move_to(65.0, 65.0);
    context
        .arc(60.0, 65.0, 5.0, 0.0, f64::consts::PI * 2.0)
        .unwrap();

    // Draw the right eye.
    context.move_to(95.0, 65.0);
    context
        .arc(90.0, 65.0, 5.0, 0.0, f64::consts::PI * 2.0)
        .unwrap();

    context.stroke();
}

</code></pre>

<p>使用 <code>wasm-pack</code> 编译后可以在浏览器当中看到自动添加了一个 DOM canvas 并绘制了一张笑脸：</p>

<p><img src="./sample-canvas.jpg" alt="sample-canvas.jpg" /></p>

<blockquote>
<p>你可以在这里<a href="./sample-canvas.zip">下载当前代码</a></p>
</blockquote>

<h2 id="rust-react">Rust React</h2>

<p>前面我们可以看到 Rust 已经可以运行 jsValue ，更可以通过 webIDL 操作 DOM ，那么是不是也可以使用 Rust 来写前端页面了？</p>

<p>当然是可以的，这里推荐一个 <a href="https://github.com/DenisKolodin/yew">yew</a> ：Rust 版本的 React</p>

<p>根据官方的例子可以很轻松的实现一个 Rust WebAssembly 版本的 TODO MVC，这里不再一一阐述，读者可以自行线下实现</p>

<h2 id="debug-webassembly-outside-of-browser">debug WebAssembly Outside of Browser</h2>

<p><a href="https://hacks.mozilla.org/2019/09/debugging-webassembly-outside-of-the-browser/">Debugging WebAssembly Outside of the Browser</a></p>

<h2 id="webassembly-in-node">WebAssembly in Node</h2>

<blockquote>
<p>WebAssembly in Node compare with Node Addon ???</p>
</blockquote>

<h2 id="新的银弹">新的银弹？</h2>

<p>WebAssembly 的出现似乎给客户端干掉前端的机会？</p>

<p>其实不然，首先由于 V8 的强大性能，以及 JIT HOT 优化的存在，几乎大部分的应用场景衡算成本（主要是开发成本）后都不需要 WebAssembly</p>

<p>而且现在的 WebAssembly 还不够完美，未来会继续支持线程，异常处理，垃圾收集等。</p>

<p>WebAssembly 应用场景在我看来更多的是：</p>

<ul>
<li>扩展浏览器端视音频处理能力（H.265）</li>
<li>基于 WebAssembly 的高性能 Web 应用 (加密、游戏、挖矿？</li>
</ul>

<blockquote>
<p>Webpack4 已经支持 import wasm 的形式，未来 WebAssembly 将可能直接通过 HTML 标签进行引用</p>
</blockquote>

<p>那现在到底谁在使用 WebAssembly 呢？印象比较深刻的是 <a href="https://blogs.autodesk.com/autocad/autocad-web-app-google-io-2018/">AutoCAD</a> ，更多的可以查看下面的 Twitter：</p>

<p><a href="https://twitter.com/JamesLMilner/status/1151824280914731008">JamesLMilner who is actually using WebAswsembly?</a></p>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/LLVM">LLVM wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intermediate_representation">IR wikipedia</a></li>
<li><a href="http://www.aosabook.org/en/llvm.html">LLVM asoa book</a></li>
<li><a href="https://stackoverflow.com/questions/27447865/understanding-the-simplest-llvm-ir">Understanding the simplest LLVM IR</a></li>
<li><a href="https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/">A cartoon intro to WebAssembly</a></li>
<li><a href="https://rustwasm.github.io/docs/wasm-bindgen/introduction.html">wasm-bindgen</a></li>
<li><a href="https://github.com/rustwasm/wasm-bindgen/blob/master/examples/README.md">wasm-bindgen examples</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly/Rust_to_wasm">MDN Rust_to_wasm</a></li>
<li><a href="https://github.com/yewstack/yew">yew</a></li>
<li><a href="https://blogs.autodesk.com/autocad/autocad-web-app-google-io-2018/">Roundup: The AutoCAD Web App at Google I/O 2018</a></li>
<li><a href="https://dev.to/azure/experimenting-with-web-assembly-and-nodejs-40f4">Experimenting with Web Assembly and Node.js</a></li>
<li><a href="http://mbebenita.github.io/WasmExplorer/">在线 CPP 转 WASM。WasmExplorer:</a>)</li>
<li><a href="https://juejin.im/post/5b76862b51882533380543d4">悄悄掀起 WebAssembly 的神秘面纱</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25800318">WebAssembly 系列</a></li>
</ul>

    </section>
    <nav class="no-print post-nav">
        
        <a class="prev-post" href="https://hasaki.xyz/blog/2019-06-17-%E8%BD%AC%E8%BD%BD%E4%B8%83%E7%89%9B%E4%BA%91%E8%AE%B8%E5%BC%8F%E4%BC%9F%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88/">
            <img class="icon-text" src="/img/prev.svg"/>转载：七牛云许式伟：我所理解的架构是什么</a>
        
        
        <a class="next-post" href="https://hasaki.xyz/blog/2019-08-09-tensor--flow/">Tensor &amp;&amp; flow<img class="icon-text" src="/img/next.svg"/>
        </a>
        
    </nav>
</article>



<div id="disqus_thread" class="no-print"></div>
<script type="text/javascript">
    'use strict';
    (function () {
        if ('localhost' != window.location.hostname) {
            var a = document.querySelector('#disqus_thread');
            new IntersectionObserver(function (b) {
                b.forEach(function (d) {
                    if (0 < d.intersectionRatio && !a.classList.contains('active')) {
                        var e = document.createElement('script');
                        e.type = 'text/javascript', e.async = !0;
                        e.src = '//' + 'hasaki-xyz' + '.disqus.com/embed.js', (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(e), a.classList.add('active')
                    }
                })
            }, {rootMargin: '0px', threshold: 1}).observe(a)
        }
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>


<style rel="catalog">
  #catalog {
    position: fixed;
    min-width: 12vw;
    left: 3vw;
    top: 8vh;
    overflow: auto;
    height: calc(100% - 16vh);
    background:
      linear-gradient(
        white 30%,
        rgba(255, 255, 255, 0)
      ),
      linear-gradient(rgba(255, 255, 255, 0), white 70%) 0 100%,
       
        radial-gradient(
          50% 0,
          farthest-side,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        ),
      radial-gradient(
          50% 100%,
          farthest-side,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        )
        0 100%;
    background:
      linear-gradient(
        white 30%,
        rgba(255, 255, 255, 0)
      ),
      linear-gradient(rgba(255, 255, 255, 0), white 70%) 0 100%,
       
        radial-gradient(
          farthest-side at 50% 0,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        ),
      radial-gradient(
          farthest-side at 50% 100%,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        )
        0 100%;
    background-repeat: no-repeat;
    background-color: white;
    background-size: 100% 40px, 100% 40px, 100% 14px, 100% 14px;

     
    background-attachment: local, local, scroll, scroll;
  }
  @media (max-width: 1280px) {
    #catalog {
      display: none;
    }
  }

  #catalog::-webkit-scrollbar {
    display: none;
  }

  .cl-wrapper {
    position: relative;
  }

  .cl-wrapper ul,
  .cl-wrapper li {
    margin: 0;
    -moz-padding-start: 12px;
    -webkit-padding-start: 12px;
    list-style: none;
  }

  .cl-wrapper li > .cl-link.cl-link-active {
    color: #ff8181;
    transition: 0.5s;
  }

  .cl-wrapper li > .cl-transform.cl-link-active {
    transform: translate(3px);
  }

  .cl-wrapper .cl-link {
    cursor: pointer;
    color: rgba(52, 73, 94, 0.5);
    font-size: 13px;
    transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
  }

  .cl-wrapper .cl-marker {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }

  .cl-wrapper .cl-marker path {
    transition: all 0.3s ease;
  }
</style>
<main id="catalog"></main>
<script rel="catalog">
  void (function() {
    if (
      window.innerWidth < 1024 ||
      /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)
    ) {
      return
    }

    const Catalog = (function() {
      return function(opts) {
        let defaultOpts = {
          linkClass: 'cl-link', 
          linkActiveClass: 'cl-link-active', 
          datasetName: 'data-cata-target', 
          selector: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'], 
          scrollWrapper: null, 
          activeHook: null, 
          topMargin: 0,
          bottomMargin: 0,
          cool: true, 
        }

        const Opt = Object.assign({}, defaultOpts, opts)

        const $content = document.getElementById(Opt.contentEl) 
        const $scroll_wrap = window 
        const $catalog = document.getElementById(Opt.catalogEl) 

        let allCatalogs = $content.querySelectorAll(Opt.selector.join())
        let tree = getCatalogsTree(allCatalogs)

        try {
          $catalog.innerHTML = `<div class='cl-wrapper'>${generateHtmlTree(
            tree,
            { id: -1 },
          )}<svg class="cl-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
            <path stroke="#ff8181" stroke-width="3" fill="transparent" stroke-dasharray="0, 0, 0, 1000" stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)" />
            </svg></div>`
        } catch (e) {
          console.error('error in progress-catalog', e)
        }

        const tocPath = $catalog.querySelector('.cl-marker path')
        let tocItems, pathLength 

        
        window.addEventListener('resize', drawPath)
        $catalog.addEventListener('click', clickHandler)
        Opt.cool && $scroll_wrap.addEventListener('scroll', coolScrollHandler)
        Opt.cool || $scroll_wrap.addEventListener('scroll', simpleScrollHandler)

        setTimeout(drawPath) 

        

        function drawPath() {
          tocItems = [...$catalog.querySelectorAll('li')]
          tocItems = tocItems.map(function(liDom) {
            const anchor = liDom.querySelector(`.${Opt.linkClass}`)
            const target = document.getElementById(
              anchor.getAttribute('data-cata-target'),
            )

            return {
              listItem: liDom,
              anchor: anchor,
              target: target,
            }
          })
          tocItems = tocItems.filter(item => !!item.target)

          const path = []
          let pathIndent

          tocItems &&
            tocItems.forEach(function(item, idx) {
              const { offsetLeft, offsetTop, offsetHeight } = item.anchor,
                x = Opt.cool ? offsetLeft - 5 : offsetLeft,
                y = offsetTop,
                height = offsetHeight

              if (idx === 0) {
                path.push('M', x, y, 'L', x, y + height)
                item.pathStart = 0
              } else {
                if (pathIndent !== x) path.push('L', pathIndent, y) 
                path.push('L', x, y)
                tocPath.setAttribute('d', path.join(' '))
                item.pathStart = tocPath.getTotalLength() || 0
                path.push('L', x, y + height)
              }
              pathIndent = x
              tocPath.setAttribute('d', path.join(' '))
              item.pathEnd = tocPath.getTotalLength()
            })
          pathLength = tocPath.getTotalLength()
          coolScrollHandler()
        }

        

        function coolScrollHandler() {
          const wrapHeight = document.documentElement.offsetHeight
          let pathStart = pathLength,
            pathEnd = 0,
            visibleItems = 0
          tocItems.forEach(function(liItem) {
            const { bottom, top } = liItem.target.getBoundingClientRect(),
              firstChild = liItem.listItem.firstChild
            if (bottom > Opt.topMargin && top < wrapHeight - Opt.bottomMargin) {
              firstChild.classList.remove(Opt.linkActiveClass)
              Opt.cool && firstChild.classList.remove('cl-transform')
            } else {
              pathStart = Math.min(liItem.pathStart, pathStart)
              pathEnd = Math.max(liItem.pathEnd, pathEnd)
              visibleItems += 1
              firstChild.classList.add(Opt.linkActiveClass)
              Opt.cool && firstChild.classList.add('cl-transform')
            }
          })
          if (visibleItems > 0 && pathStart < pathEnd && Opt.cool) {
            tocPath.setAttribute('stroke-dashoffset', '1')
            tocPath.setAttribute(
              'stroke-dasharray',
              `1, ${pathStart}, ${pathEnd - pathStart}, ${pathLength}`,
            )
            tocPath.setAttribute('opacity', '1')
          } else {
            tocPath.setAttribute('opacity', '0')
          }
        }

        

        function simpleScrollHandler(el) {
          let scrollToEl = null
          for (let i = allCatalogs.length - 1; i >= 0; i--) {
            if (allCatalogs[i].offsetTop <= $scroll_wrap.scrollTop) {
              scrollToEl = allCatalogs[i]
              break
            }
          }
          if (scrollToEl) setActiveItem(scrollToEl.id)
          else setActiveItem(null) 
        }

        

        function clickHandler({ target }) {
          const datasetId = target.getAttribute(Opt.datasetName)
          target.classList.contains(Opt.linkClass) &&
            document
              .getElementById(datasetId)
              .scrollIntoView({ behavior: 'smooth', block: 'start' })
        }

        

        function getCatalogsTree(catalogs) {
          let title,
            tagName,
            tree = [],
            treeItem = {},
            parentItem = { id: -1 },
            lastTreeItem = null,
            id

          for (let i = 0; i < catalogs.length; i++) {
            title = catalogs[i].innerText || catalogs[i].textContent
            tagName = catalogs[i].tagName
            id = 'heading-' + i
            catalogs[i].id = id
            treeItem = {
              name: title,
              tagName: tagName,
              id: id,
              level: +getLevel(tagName),
              parent: parentItem,
            }
            if (lastTreeItem) {
              if (getLevel(treeItem.tagName) > getLevel(lastTreeItem.tagName)) {
                treeItem.parent = lastTreeItem
              } else {
                treeItem.parent = findParent(treeItem, lastTreeItem)
              }
            }
            lastTreeItem = treeItem
            tree.push(treeItem)
          }
          return tree
        }

        

        function findParent(currTreeItem, lastTreeItem) {
          let lastTreeParent = lastTreeItem.parent
          while (
            lastTreeParent &&
            getLevel(currTreeItem.tagName) <= getLevel(lastTreeParent.tagName)
          ) {
            lastTreeParent = lastTreeParent.parent
          }
          return lastTreeParent || { id: -1 }
        }

        

        function getLevel(tagName) {
          return tagName ? tagName.slice(1) : 0
        }

        

        function generateHtmlTree(tree, _parent) {
          let ul,
            hasChild = false
          if (tree) {
            ul = `<ul>`
            for (let i = 0; i < tree.length; i++) {
              if (isEqual(tree[i].parent, _parent)) {
                hasChild = true
                ul += `<li><div class='${Opt.linkClass} cl-level-${tree[i].level}' ${Opt.datasetName}='${tree[i].id}'>${tree[i].name}</div>`
                ul += generateHtmlTree(tree, tree[i])
                ul += '</li>'
              }
            }
            ul += `</ul>`
          }
          return hasChild ? ul : ''
        }

        /**
         * 判断是否是相同节点
         */
        function isEqual(node, node2) {
          return (
            node &&
            node2 &&
            typeof node === 'object' &&
            typeof node2 === 'object' &&
            node.id === node2.id
          )
        }

        /**
         *  设置选中的项
         */
        function setActiveItem(id) {
          let catas = [...$catalog.querySelectorAll(`[${Opt.datasetName}]`)]

          catas.forEach(T => {
            if (T.getAttribute(Opt.datasetName) === id) {
              typeof Opt.activeHook === 'function' &&
                !T.classList.contains(Opt.linkActiveClass) &&
                Opt.activeHook.call(this, T) // 执行active钩子
              T.classList.add(Opt.linkActiveClass)
            } else {
              T.classList.remove(Opt.linkActiveClass)
            }
          })
        }
      }
    })()
    window.addEventListener(
      'DOMContentLoaded',
      _ =>
        new Catalog({
          contentEl: 'markdown',
          catalogEl: 'catalog',
        }),
    )
  })()
</script>

			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				
<a href="mailto:iamnomand@gmail.com"><img class="icon-social" src="/img/email.svg" alt="Email Me!"/></a>


<a href="https://github.com/v-tom/"><img class="icon-social" src="/img/github.svg" alt="Github"/></a>


<a href="https://twitter.com/iamnomand"><img class="icon-social" src="/img/twitter.svg" alt="Twitter"/></a>

<a href="https://hasaki.xyz/index.xml" target="_blank"><img class="icon-social" src="/img/feed.svg" alt="Feed"></a>

				<p>
					
					
					Early 2016 ~ 2020 &copy; TOM's Zone
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
		<script>hljs.initHighlightingOnLoad();</script>
		
	</body>
</html>

