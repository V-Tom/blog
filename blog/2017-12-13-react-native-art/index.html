<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="Keywords" content="">
    <meta name="full-screen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#006cb4">
    <meta name="apple-mobile-web-app-title" content="TOM&#39;s zone">
    <meta name="description" content="TOM&#39;s zone">
    <link rel="dns-prefetch" href="https://hasaki.xyz">
    <link rel="preconnect" href="https://hasaki.xyz">
    <link rel="manifest" href="/sw/manifest.json"/>
<title>React Native ART 介绍与实践 - TOM&#39;s zone</title>

<meta name="description" content="React Native ART 由来 React-Art  是 Reactjs 团队基于 Art（一个兼容各个浏览器SVG绘制的API封装）开发的模块，让 React 开发者能使用 jsx 语法绘制 svg。
React Native 团队分别在0.10.0和0.18.0也添加了iOS和Android平台对 react-art 的支持，官网文档至今对其只字未提。本文旨在介绍安静躺在 react-native/Libraries/ 里的ART，并展示一些实践结果。
在React Native中ART是个非常重要的库，它让非常酷炫的绘图及动画变成了可能。但是可能是知道的人真的不多导致文档及少中文更少。很多都是把英文的参数列表翻译过来，也没有案例。
为什么用 ART React Native 本身自带的 &lt;Image&gt; 有很多缺陷：
首先是不支持 SVG 格式的资源，目前的解决方案有通过 ReactNative-SVG 进行实现，但是这个库需要更改客户端bundle文件，带来一定的风险。
其次是 Image decoding can take more than a frame-worth of time，图片的解码由于不在主线程中进行，所以不能确保所有图片和内容在同一帧内出现，使用 &lt;Image&gt;标签的制作的组件里的图（比如icon）可能是三三两两“闪现”出来的，让人怀疑是个webview，体验远不如原生，尤其是在开发环境下最为明显。
其次就是不能支持矢量图形，必须放置 @2x 或者 @3x 对应的图片。
ART能干什么 俗话说，库如其名，背负着如此具有“艺术感”名字的ART生来就是为了绘制矢量图的，或者说是 画UI的，ART可以解决上诉的所有缺陷。
在我看来，或者说我目前业务需求用到的功能：
 ART 可以解决上诉 &lt;Image&gt; 的缺陷：解码和矢量图形 ART 可以实现 UI 上的一些渐变，比如渐变按钮，渐变背景或者底色。以及一些交互性较强的动画——画UI ART 另外一个场景就是简单数据可视化。  使用 ART  本文使用的 RN版本为0.">




    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">


    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/ocean.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/javascript.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/python.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/css.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/swift.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/objectivec.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/rust.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/yaml.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/bash.min.js"></script>


    <link rel="stylesheet" href="/css/bundle.min.css"/>
<script src="/js/bundle.js"></script>

<style>
	a { color: #ff8181; }
	blockquote {
		background: rgba(255, 129, 129, .1);
		border-left-color: #ff8181;
		border-right-color: #ff8181; }
	.bar a:hover {
		color: #ff8181;
		text-decoration: none; }
	.sep {
		margin-top: 2rem;
		margin-bottom: 1rem;
		margin-left:0;
		width: 24rem;
		border-top: 2px solid #ff8181; }
    .bar li.active a{
        color:#ff8181;
    }
</style>

</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li>
		
		<li class="active"><a href="/blog/">Blog</a></li>
		<li class=""><a href="/gallery/">Gallery</a></li>
		<li class=""><a href="/life/">Life</a></li></ul>
</nav>

	</div>
</header>
<main class="container">

<article>
    <header><hgroup id="brand">
  <h1>React Native ART 介绍与实践</h1>
  <h5>
    
    <time datetime="2017-12-13 15:29:40 &#43;0800 CST">Dec 13, 2017</time>
    <span class="no-print">
      -
      
      <a href="/tags/react">React</a>
      
      <a href="/tags/frontend">FrontEnd</a>
      
      <a href="/tags/rn">RN</a>
      
      <a href="/tags/d3">D3</a>
      </span>
  </h5>

  <a
    style="margin-top: 1.2rem;display: inline-block;"
    href="https://github.com/V-Tom/blog/blob/hugo/content/blog/2017-12-13-React%20Native%20ART/index.md"
    >✨✨✨You can Edit this Article on Github site</a
  >

  <div id="git-update-time">
  ✏️✏️✏️ This article .MD file was last updated at:
  <b>Loading ...</b>
</div>

<script data-name="commits">
  ;(async () => {
    const b = document.querySelector('#git-update-time').querySelector('b')

    if (window.location.href.includes('localhost')) {
      b.innerHTML = 'localhost disable'
      return
    }

    const commits = await fetch(
      'https://api.github.com/repos/V-Tom/blog/commits?sha=hugo&path=content/blog\/2017-12-13-React Native ART\/index.md',
    ).then(res => res.json())
    try {
      const time = new Date(commits[0].commit.committer.date)
      b.innerHTML = `${time.getFullYear()}-${time.getMonth() +
        1}-${time.getDate()}`
    } catch (e) {
      b.innerHTML = 'unknown'
    }
  })()
</script>


  
</hgroup>
<hr class="sep" />
</header>
    <section id="markdown">
        

<h3 id="react-native-art-由来">React Native ART 由来</h3>

<p><a href="https://github.com/reactjs/react-art">React-Art </a> 是 <code>Reactjs</code> 团队基于 <a href="https://github.com/sebmarkbage/art">Art</a>（一个兼容各个浏览器SVG绘制的API封装）开发的模块，让 <code>React</code> 开发者能使用 <code>jsx</code> 语法绘制 <code>svg</code>。</p>

<p><code>React Native</code> 团队分别在0.10.0和0.18.0也添加了iOS和Android平台对 <code>react-art</code> 的支持，官网文档至今对其只字未提。本文旨在介绍安静躺在 <a href="https://github.com/facebook/react-native/blob/master/Libraries/ART/ReactNativeART.js">react-native/Libraries/</a> 里的<code>ART</code>，并展示一些实践结果。</p>

<p>在React Native中ART是个非常重要的库，它让非常酷炫的绘图及动画变成了可能。但是可能是知道的人真的不多导致文档及少中文更少。很多都是把英文的参数列表翻译过来，也没有案例。</p>

<h3 id="为什么用-art">为什么用 ART</h3>

<p><code>React Native</code> 本身自带的 <code>&lt;Image&gt;</code> 有很多缺陷：</p>

<p>首先是不支持 SVG 格式的资源，目前的解决方案有通过 <a href="https://github.com/react-native-community/react-native-svg">ReactNative-SVG</a> 进行实现，但是这个库需要更改客户端bundle文件，带来一定的风险。</p>

<p>其次是 <a href="https://facebook.github.io/react-native/docs/images.html#off-thread-decoding">Image decoding can take more than a frame-worth of time</a>，图片的解码由于不在主线程中进行，所以不能确保所有图片和内容在同一帧内出现，使用 <code>&lt;Image&gt;</code>标签的制作的组件里的图（比如icon）可能是三三两两“闪现”出来的，让人怀疑是个<code>webview</code>，体验远不如原生，尤其是在开发环境下最为明显。</p>

<p>其次就是不能支持矢量图形，必须放置 <code>@2x</code> 或者 <code>@3x</code> 对应的图片。</p>

<h3 id="art能干什么">ART能干什么</h3>

<p>俗话说，<strong>库如其名</strong>，背负着如此具有“艺术感”名字的ART生来就是为了绘制矢量图的，或者说是 <strong>画UI的</strong>，ART可以解决上诉的所有缺陷。</p>

<p>在我看来，或者说我目前业务需求用到的功能：</p>

<ul>
<li>ART 可以解决上诉 <code>&lt;Image&gt;</code> 的缺陷：解码和矢量图形</li>
<li>ART 可以实现 UI 上的一些渐变，比如渐变按钮，渐变背景或者底色。以及一些交互性较强的动画——<strong>画UI</strong></li>
<li>ART 另外一个场景就是简单数据可视化。</li>
</ul>

<h3 id="使用-art">使用 ART</h3>

<blockquote>
<p>本文使用的 RN版本为0.50.1</p>

<p>本文一些英语词汇出于编写角度进行了简写，RN是 <code>React Native</code> 的简写</p>

<p>Android默认就包含ART库，IOS需要单独添加依赖库。</p>
</blockquote>

<ul>
<li>ART在iOS上使用需要事先导入ART的链接库，找到 <code>node_modules/react-native/Libraries/ART/ART.xcdoeproj</code> 拖入Xcode对应项目的 <code>Libraries</code></li>
<li>打开 <code>General Settings</code>添加 <code>libART.a</code> 到 <code>Linked Frameworks and Libraries</code> 列表</li>
<li><code>cmd+b</code>重新构建项目</li>
</ul>

<h4 id="基本-api">基本 API</h4>

<p><a href="https://github.com/react-native-china/react-native-ART-doc/blob/master/doc.md">RN ART 文档 (非官方)</a> 在github上有这样比较全一篇文档，可以选择直接看它了解使用。</p>

<p><code>ART</code> 目前的API有：</p>

<ul>
<li><code>Surface</code> 标签对应svg中的<code>SVG</code>标签，所有ART的jsx内容需要被其包含</li>
<li><code>Group</code> 标签对应 <code>g</code> 标签</li>
<li><code>Shape</code> 标签对应 <code>path</code> 标签</li>
<li><code>Text</code> 标签对应 <code>text</code> 标签</li>
<li><code>Transform</code> 做图形变换的API</li>
<li><code>Path</code> 绘制路径API</li>
<li><code>LinearGradient</code> 创建线性渐变API</li>
<li><code>RadialGradient</code> 创建径向渐变API</li>
</ul>

<blockquote>
<p>本文不介绍 SVG ，读者可以自行线下学习。</p>
</blockquote>

<p>可以看到 ART 和 SVG 还是有不同的，有点像是阉割后的 SVG，当然已经有开发者做了实现，可以方便地使用 SVG 标签写 <a href="https://github.com/react-native-community/react-native-svg">ReactNative-SVG</a> ，这种方式的缺点上文已经说过。</p>

<p>在本文例子当中，我们使用原原本本的ART实践。</p>

<h4 id="基础例子">基础例子：</h4>

<p>下面是一个绘制线段的 ART demo：</p>

<pre><code class="language-javascript">import React, { Component } from 'react'
import {
  View,
  Dimensions,
  ART
} from 'react-native'

export default class Line extends Component {
  render() {
    return (
      &lt;View
      &gt;
        &lt;ART.Surface
          width={Dimensions.get('window').width}
          height={100}
        &gt;
          &lt;ART.Shape
            d={new ART.Path().moveTo(50, 50).lineTo(100, 100)}
            stroke=&quot;#000000&quot;
            strokeWidth={1}
          /&gt;
        &lt;/ART.Surface&gt;
      &lt;/View&gt;
    )
  }
}
</code></pre>

<p><code>Surface</code> 必须是ART内容的父层，并且其中不能包含非ART标签（否则直接闪退…），需要指定宽高，很多时候绘制无效或者缺角有可能是 <code>Path</code> 超过了 <code>Shape</code> 的绘制区域。</p>

<p><code>Group</code> 可有可无，当绘制内容较多时可以用其统一管理，可以把它当做 <code>View</code>标签使用，可制定内容在画布绘制的起点。</p>

<p><code>Shape</code> 是目前ART绘制的首要入口，<code>d</code> 属性对标svg的 <code>path</code> 标签上的 <code>d</code> 属性。</p>

<p>所有的ART标签都可以使用 <code>transform</code> 属性做变换。</p>

<p><code>Shape</code> 当中的 <code>d</code> 类似于 svg 的 path，可以通过 <code>ART.Path</code> 生成，比如下面这些是绘制的一些简单图形：</p>

<ul>
<li>圆形</li>
</ul>

<pre><code class="language-javascript">// 绘制圆形
function circlePathRender() {
  
  const path = Path()
  	.moveTo(0,50)
    .arc(0, radius * 2, radius)
    .arc(0, radius * -2, radius)
    .close(); // 闭合路径
  
  // path 可以直接作为 props 传给 shape
  return &lt;ART.Shape 
           d={path} 
           fill={'#2ba'}
          /&gt;
}
</code></pre>

<ul>
<li>绘制多边形：</li>
</ul>

<pre><code class="language-javascript">// 绘制多边形
function polygonPathRender() {
  var path = Path()
  	.moveTo(10, 10)
    .lineTo(20, 30)
    .lineTo(30, 40)
    .close(); // 闭合路径
  
  return &lt;ART.Shape 
           d={path} 
           fill={'#00a'} 
           stroke=&quot;yellow&quot; 
           strokeWidth={4}
          /&gt;
}
</code></pre>

<p><code>Path</code> 还有一些API来满足日常绘图要求：<code>arcTo</code>/<code>curve</code>/<code>line</code>/<code>Text</code></p>

<ul>
<li>文字</li>
</ul>

<pre><code class="language-javascript">// 绘制文字
function textRender() {
  return (
    &lt;ART.Text
      font={`bold 13px &quot;Helvetica Neue&quot;, &quot;Helvetica&quot;, Arial`}
      fill=&quot;#749&quot;
      x={0}
      y={0}
    &gt;
      Lorem ipsum dolor sit amet
    &lt;/ART.Text&gt;
  );
}
</code></pre>

<ul>
<li>渐变</li>
</ul>

<pre><code class="language-javascript">// linearGradient 可赋值给Path或者Text标签的fill属性

function linearGradientRender() {
  const linearGradient = new ART.LinearGradient({
    &quot;0&quot;: &quot;#2ba&quot;,
    &quot;.5&quot;: &quot;#f90&quot;,
    &quot;0.7&quot;: &quot;#aa4422&quot;,
    &quot;1&quot;: &quot;rgba(255,255,255,0.5)&quot;
  }, 0, 0, 100, 200);
  
  // 这里的 d props(Path) 简略
  return &lt;ART.Shape 
           d={...} 
           fill={linearGradient} 
          /&gt;
}

</code></pre>

<p><code>LinearGradient</code> 构造函数第一个参数是设定渐变色的对象。</p>

<p>使用诸如<code>0.3</code>/<code>.52</code>/<code>1</code>这样的属性表示<code>30%</code>/<code>52%</code>/<code>100%</code>，值为颜色值，不符合要求的键值对会被忽略。
后面四个参数分别表示：起点x，起点y，终点x，终点y.</p>

<pre><code class="language-javascript">// radialGradient 可赋值给Path或者Text标签的fill属性

function radialGradientRender() {
  const radialGradient = new ART.RadialGradient({
    &quot;0&quot;: &quot;#2ba&quot;,
    &quot;.5&quot;: &quot;#f90&quot;,
    &quot;0.7&quot;: &quot;#aa4422&quot;,
    &quot;1&quot;: &quot;rgba(255,255,255,0.5)&quot;
  }, 0, 0, 100, 200);
  
  // 这里的 d props(Path) 简略
  return &lt;ART.Shape 
           d={...} 
           fill={radialGradient} 
          /&gt;
}

</code></pre>

<p><code>RadialGradient</code>构造函数第一个参数是和线性渐变相同的，后续六个分别表示：焦点x，焦点y，x半轴长，y半轴长，原点x，原点y。</p>

<h3 id="art-动画">ART 动画</h3>

<p>大多数情况下，在 React Native 中创建动画是推荐使用 <a href="https://facebook.github.io/react-native/docs/animated.html">Animated API</a> 的，其提供了三个主要的方法用于创建动画：</p>

<h3 id="art-简单数据可视化">ART 简单数据可视化</h3>

<blockquote>
<p>本文采用 d3-shapes 生成 Path 来通过 ART.Shape 进行绘制可视化数据。</p>

<p>注意：这个 Path 和 SVG 的 Path 基本上一样，但是请注意 ART 只是 阉割版的 SVG，以下针对 D3 文档的描述和解释是个人对 D3 的理解</p>
</blockquote>

<p>通过上面对 ART 提供的一些 API 简单介绍可以发现，我们可以指定一个特殊的 <code>Path</code> 给 <code>Shape</code> 组件（d props），可以实现一些曲线线段，比如下面代码：</p>

<pre><code class="language-javascript">import React, { Component } from 'react'
import {
  ART,
  View,
} from 'react-native';

const {
  Surface,
  Group,
  Shape,
} = ART;

export default class ARTSimpleLine extends Component{
    render(){
        return (
            &lt;View&gt;
              &lt;Surface width={500} height={500}&gt;
                &lt;Group&gt;
                  &lt;Shape
                    d=&quot;M0,100L60,160L120,60L180,140L240,100L300,120&quot;
                    stroke=&quot;#000&quot;
                    strokeWidth={1}
                    // 设置 shape X 偏移值
                    x={50}
                    /&gt;
                &lt;/Group&gt;
              &lt;/Surface&gt;
            &lt;/View&gt;
          )
    }
}
</code></pre>

<p>可以得到如下的一个简单图形：</p>

<p><img src="./ARTSimpleLine.png" alt="ARTSimpleLine" /></p>

<p>实际上我们可以通过一些工具生成 Path 来做简单的数据可视化。</p>

<p>而path data由一系列的命令组成，比如上面代码当中的：</p>

<blockquote>
<p>SVG 的 path 这里不详细介绍，可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths">SVG path tutorial</a></p>
</blockquote>

<pre><code class="language-text">M0,100L60,160L120,60L180,140L240,100L300,120
</code></pre>

<p>实际上，我们可以自己通过书写代码来创建这些 path 命令集，但是你会发现，写出这些代码虽然并不难，但是一定是很繁琐的，所以我们需要一个工具来自动生成这些命令集。</p>

<p>我们这里采用 <code>D3.js</code> path generator 的路径生成器，下面列出了一些常见的路径生成器：</p>

<ul>
<li><a href="https://github.com/d3/d3-shape#arcs">Arcs</a></li>
<li><a href="https://github.com/d3/d3-shape#pies">Pies</a></li>
<li><a href="https://github.com/d3/d3-shape#lines">Lines</a></li>
<li><a href="https://github.com/d3/d3-shape#areas">Areas</a></li>
<li><a href="https://github.com/d3/d3-shape#curves">Curves</a></li>
<li><a href="https://github.com/d3/d3-shape#symbols">Symbols</a></li>
</ul>

<blockquote>
<p>这里推荐一个在线查看 <a href="https://www.pshrmn.com/tutorials/d3/shapes/">D3 shape demo</a></p>
</blockquote>

<p>我们暂时只简单的用到了 <code>Lines</code> 生成器。</p>

<p>首先生明一个 <code>line generator</code>：</p>

<pre><code class="language-javascript">const lineGenerator = d3.line();
</code></pre>

<p>我们来定义一个坐标数组：</p>

<pre><code class="language-javascript">const points = [
  [0, 100],
  [60, 160],
  [120, 60],
  [180, 140],
  [240, 100],
  [300, 120]
];
</code></pre>

<p>接着我们传入points参数来调用lineGenerator：</p>

<pre><code class="language-javascript">const pathData = lineGenerator(points);
// pathData is &quot;M0,100L60,160L120,60L180,140L240,100L300,120&quot;
</code></pre>

<p>lineGenerator完成的工作就是创建了一个M(move to)和L（line to）命令的字符串，这样我们就得到了Path Data。</p>

<p>这是我们想要的 Path Data吗？</p>

<p>显然不是，我们需要 Path Data 尽量具有以下特征：</p>

<ul>
<li>线条扁平，曲线化</li>
<li>Data Driven</li>
</ul>

<p>查阅文档，发现 <a href="https://github.com/d3/d3-shape#line_curve">line.curve</a> 方法可以实现特征一，至于 <a href="https://github.com/d3/d3-shape#curves">Curve</a> ，D3 当中有做了详细的解释：</p>

<blockquote>
<p>While <a href="https://github.com/d3/d3-shape#lines">lines</a> are defined as a sequence of two-dimensional [<em>x</em>, <em>y</em>] points, and <a href="https://github.com/d3/d3-shape#areas">areas</a> are similarly defined by a topline and a baseline, there remains the task of transforming this discrete representation into a continuous shape: <em>i.e.</em>, how to interpolate between the points. A variety of curves are provided for this purpose.</p>

<p>简单翻译一下：线被定义为二维[x,y]点序列，为了将离散转换为连续形状的任务，D3 提供了各种曲线（ps：曲线实现是一个黑盒，使用者无需关心如何实现，可以查看 <a href="https://people.cs.clemson.edu/~dhouse/courses/405/notes/splines.pdf">splines</a></p>
</blockquote>

<p>D3 提供了 <code>line.curve</code> 方法。</p>

<p>curve 通常情况下不会直接构建或者生成，只会在调用 <code>line.curve</code> 方法的时候生成，很多方法来辅助生成 Curve：</p>

<ul>
<li><strong>curveBasis</strong></li>

<li><p><strong>curveCardinal</strong></p></li>

<li><p><strong>curveBasisClosed</strong></p></li>

<li><p><strong>&hellip;</strong></p></li>
</ul>

<p>这里只简单列出一些方法，而且我们这里只用到一种方法：<strong>curveCardinal</strong></p>

<p>按照 D3 给出的例子，代码是下面这样的：</p>

<pre><code class="language-javascript">const line = d3.line()
    .curve(d3.curveCardinal);
</code></pre>

<p><strong>curveCardinal</strong> 的作用官方是这样介绍的：</p>

<blockquote>
<p>Produces a cubic <a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline">cardinal spline</a> using the specified control points, with one-sided differences used for the first and last piece. The default <a href="https://github.com/d3/d3-shape#curveCardinal_tension">tension</a> is 0.</p>
</blockquote>

<p>官方介绍太学术化，简单理解为：使用用户传入的控制点坐标来生成曲线。</p>

<p>简单和其他的方法比较一下，没有产生一个闭环，而且使用了第一个和最后一个控制点坐标，而且张力默认为0。</p>

<p>然后我们就可以生成这样一个 Path Data</p>

<pre><code class="language-text">M0,100C0,100,40,166.66666666666666,60,160C80,153.33333333333334,100,63.333333333333336,120,60C140,56.666666666666664,160,133.33333333333334,180,140C200,146.66666666666666,220,103.33333333333333,240,100C260,96.66666666666667,300,120,300,120
</code></pre>

<p>实际得到的图形如下：</p>

<p><img src="./ARTCurve.png" alt="Art Curve" /></p>

<blockquote>
<p>当然 <code>D3.curve</code> 传入不同的辅助方法会生成不同的 Path Data 以及曲线，读者可以自行线下尝试</p>
</blockquote>

<p>这样看下来似乎已经很完美了，但是注意，这个 Path Data 是根据我们自定义的数据（<strong>预先设定完毕的二维坐标数组</strong>）生成的，实际业务当中，数据只会是数据，比如：</p>

<pre><code class="language-javascript">// 一周内的降雨流量数据(伪造)
const data = [820, 932, 631, 934, 890, 1330, 1320]
</code></pre>

<p>具体图表上的二维坐标我们是无法确定或者无法及时变动的，所以，似乎我们需要一个方法来自定义二维坐标的生成？</p>

<p>当然可以，上诉代码可以修改为：</p>

<pre><code class="language-javascript">const line = d3.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.value); })
    .curve(d3.curveCardinal);
</code></pre>

<p>你可能会说这个 <code>line.x</code> 和 <code>line.y</code> 是个什么鬼？</p>

<p>关于 <code>line.x</code> 官方是这样解释：</p>

<blockquote>
<p>If <em>x</em> is specified, sets the x accessor to the specified function or number and returns this line generator. If <em>x</em> is not specified, returns the current x accessor, which defaults to:</p>

<pre><code class="language-javascript">&gt; function x(d) {
&gt;   return d[0];
&gt; }
&gt; ```

简单来说就是：如果指定 `x` ，则将 x accessor 设置为指定的函数或编号并返回此行 generator，什么意思呢？

这个可以理解为一个辅助函数，参照上面例子我们自定义的一个坐标数组，默认情况下每一个数组元素都代表了一个二维的数组，比如 `[0,100]` ，然而我们也可以告诉 `line generator ` 来如何自定义解读传入的数据，而这就要使用对应的 `accessor functions` 了。

至于 `line.y` 当然基本也是一样的概念，但是默认的 Y accessor为：

```javascript
function y(d) {
  return d[1];
}
</code></pre>
</blockquote>

<p>这也是为什么之前我们构造的坐标为什么是一个二维数组。</p>

<p>按照上面伪造的一周内降雨流量数据：（这里复制一次，便于阅读</p>

<pre><code class="language-javascript">// 一周内的降雨流量数据(伪造)
const data = [820, 932, 631, 934, 890, 1330, 1320]
</code></pre>

<p>我们来一步步解析一下 line 图表的生成方法：</p>

<ul>
<li>Y Axis 上需要设置最小值和最大值（最大值可能会动态变化），根据数据实际情况计算出来 Y 轴坐标</li>
<li>x Axis 上需要设置一周内的日期或者周一至周日，这 7 天的 x 轴坐标为了美观必须是等分的，所以计算出来对应 X 轴坐标</li>
</ul>

<p>通过简单的上诉两个步骤，我们就能得到数据实际对应的二维坐标，这样才能生成 Path Data，绘制 line chart。</p>

<pre><code class="language-javascript">import React, { Component } from 'react'
import * as d3 from 'd3-shape'
import {
  ART,
  View,
} from 'react-native';

const {
  Surface,
  Group,
  Shape,
} = ART;

const data = [
  { &quot;data&quot;: &quot;Mon&quot;, &quot;value&quot;: 820 },
  { &quot;data&quot;: &quot;Tue&quot;, &quot;value&quot;: 932 },
  { &quot;data&quot;: &quot;Wed&quot;, &quot;value&quot;: 631 },
  { &quot;data&quot;: &quot;Thu&quot;, &quot;value&quot;: 934 },
  { &quot;data&quot;: &quot;Fri&quot;, &quot;value&quot;: 890 },
  { &quot;data&quot;: &quot;Sat&quot;, &quot;value&quot;: 1330 },
  { &quot;data&quot;: &quot;Sun&quot;, &quot;value&quot;: 1320 }
]

const CHART_WIDTH = 375
const CHART_HEIGHT = 300

const X_AXIS_OFFSET = 50
const MAX_Y_AXIS = 1600
const MIN_Y_AXIS = 0

const lineGenerator = d3.line()
  .x((d, i) =&gt; i * X_AXIS_OFFSET)
  .y(d =&gt; CHART_HEIGHT - CHART_HEIGHT * Math.min(1, (d.value / MAX_Y_AXIS)))
  .curve(d3.curveCardinal);

const path = lineGenerator(data)

export default class ReactNativeART extends Component {
  render() {

    return (
      &lt;View&gt;
        &lt;Surface width={CHART_WIDTH} height={CHART_HEIGHT}&gt;
          &lt;Group&gt;
            &lt;Shape
              d={path}
              stroke=&quot;#000&quot;
              strokeWidth={1}
            /&gt;
          &lt;/Group&gt;
        &lt;/Surface&gt;
      &lt;/View&gt;
    )
  }
}
</code></pre>

<p>上述代码当中，我们定义了一些常用的常量：</p>

<ul>
<li>图表的高度：<code>CHART_HEIGHT</code></li>
<li>Y 轴最大值：<code>MAX_Y_AXIS</code></li>
<li>X 轴每一项的等分距离：<code>X_AXIS_OFFSET</code></li>
</ul>

<p>实际生产的二维坐标为：</p>

<pre><code class="language-javascript">[[0,146.25],[50,125.25],[100,131.0625],[150,124.875],[200,58.125],[250,50.625],[300,52.5]]
</code></pre>

<p>根据坐标生成 Path Data 绘制出来的图表为：</p>

<p><img src="./ARTCurve.png" alt="Art Line Chart One" /></p>

<p>一个基本的 line 图表就这样生成了，接下来我们做一些美化操作：</p>

<ul>
<li>添加 Point</li>
<li>添加 X 和 Y 轴的坐标和label</li>
</ul>

<p>我们可以通过 <code>ART.Path</code> 来绘制圆形来模拟 Point：</p>

<pre><code class="language-javascript">  renderPoints(data) {

    const pointArc = 3
    return data.map((d, i) =&gt; {

      if (i === 0) return null
      
      return (
        &lt;Shape
          key={i}
          d={new Path()
            .moveTo(X_AXIS_OFFSET * i, CHART_HEIGHT - pointArc - CHART_HEIGHT * Math.min(1, (d.value / MAX_Y_AXIS)))
            .arc(0, 2 * pointArc, pointArc)
            .arc(0, -2 * pointArc, pointArc)
            .close()
          }
          strokeWidth={0}
          stroke={'#9573D4'}
          fill={'#f00'}
        /&gt;
      )
    })
  }
</code></pre>

<p>绘制结果如下：</p>

<p><img src="./ArtCurveWithPoints.png" alt="ART curve with points" /></p>

<p>接下来实现 X 轴和 Y 轴。</p>

<blockquote>
<p>注意这个 Y 轴需要固定在左侧，所以 Y 轴 需要使用 RN 的 Text 绝对定位在 ScrollView 的左侧</p>
</blockquote>

<pre><code class="language-javascript"> renderYAxis(data) {
    const split = 6
    return new Array(split).fill(null).map((d, i) =&gt; {
      if (i === 0) return null
      return &lt;Text
        key={i}
        style={{
          position: 'absolute',
          fontSize: 12,
          color: '#000',
          left: '3%',
          backgroundColor: 'transparent',
          top: CHART_HEIGHT - (i / split) * CHART_HEIGHT
        }}
        alignment={'center'}
      &gt;
        {String((i / split) * MAX_Y_AXIS)}
      &lt;/Text&gt;
    })
  }

  renderXAxis(data) {

    return data.map((d, i) =&gt; {
      return &lt;ART.Text
        key={i}
        fill={'#000'}
        font={`normal 12px Heiti SC`}
        x={i * X_AXIS_OFFSET + 12}
        y={CHART_HEIGHT - 12}
        alignment={'center'}
      &gt;
        {d.data}
      &lt;/ART.Text&gt;
    })
  }
  render() {

    return (
      &lt;View
        style={{
          position: 'relative',
          width: Dimensions.get('window').width,
          height: CHART_HEIGHT
        }}
      &gt;
        &lt;ScrollView
          bounces={false}
          showsHorizontalScrollIndicator={false}
          horizontal
        &gt;
          &lt;Surface
            width={CHART_REAL_WIDTH}
            height={CHART_HEIGHT}
          &gt;
            &lt;Group&gt;
              {this.renderLine(data)}
              {this.renderPoints(data)}
              {this.renderXAxis(data)}
            &lt;/Group&gt;
          &lt;/Surface&gt;
        &lt;/ScrollView&gt;
        {this.renderYAxis(data)}
      &lt;/View&gt;
    )
  }
</code></pre>

<p><img src="./ArtCurveWithAxis.png" alt="Art curve with axis" /></p>

<p>这个图表看起来似乎很单调，我们添加一些 area fill 效果。</p>

<p>这里采用 D3 area 生成 area fill 图形，并且以 <code>ART.LinearGradient</code> 来 fill 渐变色。</p>

<pre><code class="language-javascript">renderPath(data) {
    const areaGenerator = d3.area()
      .x((d, i) =&gt; i * X_AXIS_OFFSET)
      .y0(CHART_HEIGHT)
      .y1(d =&gt; CHART_HEIGHT - CHART_HEIGHT * Math.min(1, (d.value / MAX_Y_AXIS)))
      .curve(d3.curveMonotoneX);

    return &lt;Shape
      d={areaGenerator(data)}
      fill={new LinearGradient({
          '0': '#875CD5',
          '.88': '#A084D4'
        }, 0, 0, 0, CHART_HEIGHT
      )}
      strokeWidth={1}
    /&gt;
  }
</code></pre>

<p>得到效果如下：</p>

<p><img src="./ArtCurveWithGradient.png" alt="Art curve chart with gradient " /></p>

<p>同样的道理，我们可以添加 背景色渐变，更改 X、Y 轴的字体颜色来进一步美化图表，最终效果如下图：</p>

<p><img src="./ArtCurveChartFinal.png" alt="Art curve chart final" /></p>

<p>完整代码可以再 <a href="https://gist.github.com/V-Tom/5e441cba9d3a8ef1366997fff6a64606">GitHub gist</a> 上找到</p>

<blockquote>
<p>似乎这个 chart 有点单调，生硬，我们需要添加一些动画、过渡效果</p>

<p>TODO</p>
</blockquote>

<h3 id="reference">Reference</h3>

<ul>
<li><a href="https://github.com/sebmarkbage/art">sebmarkbage ART</a></li>
<li><a href="https://github.com/reactjs/react-art">React-Art </a></li>
<li><a href="https://github.com/react-native-community/react-native-svg">react-native-svg</a> 让ART支持所有svg标签。</li>
<li><a href="https://github.com/matc4/react-native-svg-uri">react-native-svg-uri</a> 依赖上面的<code>react-native-svg</code>让<code>&lt;Image&gt;</code>标签的source可使用svg的uri。</li>
<li><a href="https://github.com/oblador/react-native-progress">react-native-progress</a> ART做的进度条组件。</li>
<li><a href="https://medium.com/the-react-native-log/animated-charts-in-react-native-using-d3-and-art-21cd9ccf6c58">Animated Charts in React Native using D3 and ART</a></li>
</ul>

    </section>
    <nav class="no-print post-nav">
        
        <a class="prev-post" href="https://hasaki.xyz/blog/2017-11-02-react-%E6%A8%A1%E5%BC%8F%E6%8A%80%E5%B7%A7%E6%8A%80%E5%B7%A7%E5%92%8C%E7%AA%8D%E9%97%A8/">
            <img class="icon-text" src="/img/prev.svg"/>React 模式，技巧，技巧和窍门</a>
        
        
        <a class="next-post" href="https://hasaki.xyz/blog/2018-01-02-%E4%BB%8Ejwt%E5%88%B0oauth/">从jwt到OAuth<img class="icon-text" src="/img/next.svg"/>
        </a>
        
    </nav>
</article>



<div id="disqus_thread" class="no-print"></div>
<script type="text/javascript">
    'use strict';
    (function () {
        if ('localhost' != window.location.hostname) {
            var a = document.querySelector('#disqus_thread');
            new IntersectionObserver(function (b) {
                b.forEach(function (d) {
                    if (0 < d.intersectionRatio && !a.classList.contains('active')) {
                        var e = document.createElement('script');
                        e.type = 'text/javascript', e.async = !0;
                        e.src = '//' + 'hasaki-xyz' + '.disqus.com/embed.js', (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(e), a.classList.add('active')
                    }
                })
            }, {rootMargin: '0px', threshold: 1}).observe(a)
        }
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>


<style rel="catalog">
  #catalog {
    position: fixed;
    min-width: 12vw;
    left: 3vw;
    top: 8vh;
    overflow: auto;
    height: calc(100% - 16vh);
    background:
      linear-gradient(
        white 30%,
        rgba(255, 255, 255, 0)
      ),
      linear-gradient(rgba(255, 255, 255, 0), white 70%) 0 100%,
       
        radial-gradient(
          50% 0,
          farthest-side,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        ),
      radial-gradient(
          50% 100%,
          farthest-side,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        )
        0 100%;
    background:
      linear-gradient(
        white 30%,
        rgba(255, 255, 255, 0)
      ),
      linear-gradient(rgba(255, 255, 255, 0), white 70%) 0 100%,
       
        radial-gradient(
          farthest-side at 50% 0,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        ),
      radial-gradient(
          farthest-side at 50% 100%,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        )
        0 100%;
    background-repeat: no-repeat;
    background-color: white;
    background-size: 100% 40px, 100% 40px, 100% 14px, 100% 14px;

     
    background-attachment: local, local, scroll, scroll;
  }
  @media (max-width: 1280px) {
    #catalog {
      display: none;
    }
  }

  #catalog::-webkit-scrollbar {
    display: none;
  }

  .cl-wrapper {
    position: relative;
  }

  .cl-wrapper ul,
  .cl-wrapper li {
    margin: 0;
    -moz-padding-start: 12px;
    -webkit-padding-start: 12px;
    list-style: none;
  }

  .cl-wrapper li > .cl-link.cl-link-active {
    color: #ff8181;
    transition: 0.5s;
  }

  .cl-wrapper li > .cl-transform.cl-link-active {
    transform: translate(3px);
  }

  .cl-wrapper .cl-link {
    cursor: pointer;
    color: rgba(52, 73, 94, 0.5);
    font-size: 13px;
    transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
  }

  .cl-wrapper .cl-marker {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }

  .cl-wrapper .cl-marker path {
    transition: all 0.3s ease;
  }
</style>
<main id="catalog"></main>
<script rel="catalog">
  void (function() {
    if (
      window.innerWidth < 1024 ||
      /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)
    ) {
      return
    }

    const Catalog = (function() {
      return function(opts) {
        let defaultOpts = {
          linkClass: 'cl-link', 
          linkActiveClass: 'cl-link-active', 
          datasetName: 'data-cata-target', 
          selector: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'], 
          scrollWrapper: null, 
          activeHook: null, 
          topMargin: 0,
          bottomMargin: 0,
          cool: true, 
        }

        const Opt = Object.assign({}, defaultOpts, opts)

        const $content = document.getElementById(Opt.contentEl) 
        const $scroll_wrap = window 
        const $catalog = document.getElementById(Opt.catalogEl) 

        let allCatalogs = $content.querySelectorAll(Opt.selector.join())
        let tree = getCatalogsTree(allCatalogs)

        try {
          $catalog.innerHTML = `<div class='cl-wrapper'>${generateHtmlTree(
            tree,
            { id: -1 },
          )}<svg class="cl-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
            <path stroke="#ff8181" stroke-width="3" fill="transparent" stroke-dasharray="0, 0, 0, 1000" stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)" />
            </svg></div>`
        } catch (e) {
          console.error('error in progress-catalog', e)
        }

        const tocPath = $catalog.querySelector('.cl-marker path')
        let tocItems, pathLength 

        
        window.addEventListener('resize', drawPath)
        $catalog.addEventListener('click', clickHandler)
        Opt.cool && $scroll_wrap.addEventListener('scroll', coolScrollHandler)
        Opt.cool || $scroll_wrap.addEventListener('scroll', simpleScrollHandler)

        setTimeout(drawPath) 

        

        function drawPath() {
          tocItems = [...$catalog.querySelectorAll('li')]
          tocItems = tocItems.map(function(liDom) {
            const anchor = liDom.querySelector(`.${Opt.linkClass}`)
            const target = document.getElementById(
              anchor.getAttribute('data-cata-target'),
            )

            return {
              listItem: liDom,
              anchor: anchor,
              target: target,
            }
          })
          tocItems = tocItems.filter(item => !!item.target)

          const path = []
          let pathIndent

          tocItems &&
            tocItems.forEach(function(item, idx) {
              const { offsetLeft, offsetTop, offsetHeight } = item.anchor,
                x = Opt.cool ? offsetLeft - 5 : offsetLeft,
                y = offsetTop,
                height = offsetHeight

              if (idx === 0) {
                path.push('M', x, y, 'L', x, y + height)
                item.pathStart = 0
              } else {
                if (pathIndent !== x) path.push('L', pathIndent, y) 
                path.push('L', x, y)
                tocPath.setAttribute('d', path.join(' '))
                item.pathStart = tocPath.getTotalLength() || 0
                path.push('L', x, y + height)
              }
              pathIndent = x
              tocPath.setAttribute('d', path.join(' '))
              item.pathEnd = tocPath.getTotalLength()
            })
          pathLength = tocPath.getTotalLength()
          coolScrollHandler()
        }

        

        function coolScrollHandler() {
          const wrapHeight = document.documentElement.offsetHeight
          let pathStart = pathLength,
            pathEnd = 0,
            visibleItems = 0
          tocItems.forEach(function(liItem) {
            const { bottom, top } = liItem.target.getBoundingClientRect(),
              firstChild = liItem.listItem.firstChild
            if (bottom > Opt.topMargin && top < wrapHeight - Opt.bottomMargin) {
              firstChild.classList.remove(Opt.linkActiveClass)
              Opt.cool && firstChild.classList.remove('cl-transform')
            } else {
              pathStart = Math.min(liItem.pathStart, pathStart)
              pathEnd = Math.max(liItem.pathEnd, pathEnd)
              visibleItems += 1
              firstChild.classList.add(Opt.linkActiveClass)
              Opt.cool && firstChild.classList.add('cl-transform')
            }
          })
          if (visibleItems > 0 && pathStart < pathEnd && Opt.cool) {
            tocPath.setAttribute('stroke-dashoffset', '1')
            tocPath.setAttribute(
              'stroke-dasharray',
              `1, ${pathStart}, ${pathEnd - pathStart}, ${pathLength}`,
            )
            tocPath.setAttribute('opacity', '1')
          } else {
            tocPath.setAttribute('opacity', '0')
          }
        }

        

        function simpleScrollHandler(el) {
          let scrollToEl = null
          for (let i = allCatalogs.length - 1; i >= 0; i--) {
            if (allCatalogs[i].offsetTop <= $scroll_wrap.scrollTop) {
              scrollToEl = allCatalogs[i]
              break
            }
          }
          if (scrollToEl) setActiveItem(scrollToEl.id)
          else setActiveItem(null) 
        }

        

        function clickHandler({ target }) {
          const datasetId = target.getAttribute(Opt.datasetName)
          target.classList.contains(Opt.linkClass) &&
            document
              .getElementById(datasetId)
              .scrollIntoView({ behavior: 'smooth', block: 'start' })
        }

        

        function getCatalogsTree(catalogs) {
          let title,
            tagName,
            tree = [],
            treeItem = {},
            parentItem = { id: -1 },
            lastTreeItem = null,
            id

          for (let i = 0; i < catalogs.length; i++) {
            title = catalogs[i].innerText || catalogs[i].textContent
            tagName = catalogs[i].tagName
            id = 'heading-' + i
            catalogs[i].id = id
            treeItem = {
              name: title,
              tagName: tagName,
              id: id,
              level: +getLevel(tagName),
              parent: parentItem,
            }
            if (lastTreeItem) {
              if (getLevel(treeItem.tagName) > getLevel(lastTreeItem.tagName)) {
                treeItem.parent = lastTreeItem
              } else {
                treeItem.parent = findParent(treeItem, lastTreeItem)
              }
            }
            lastTreeItem = treeItem
            tree.push(treeItem)
          }
          return tree
        }

        

        function findParent(currTreeItem, lastTreeItem) {
          let lastTreeParent = lastTreeItem.parent
          while (
            lastTreeParent &&
            getLevel(currTreeItem.tagName) <= getLevel(lastTreeParent.tagName)
          ) {
            lastTreeParent = lastTreeParent.parent
          }
          return lastTreeParent || { id: -1 }
        }

        

        function getLevel(tagName) {
          return tagName ? tagName.slice(1) : 0
        }

        

        function generateHtmlTree(tree, _parent) {
          let ul,
            hasChild = false
          if (tree) {
            ul = `<ul>`
            for (let i = 0; i < tree.length; i++) {
              if (isEqual(tree[i].parent, _parent)) {
                hasChild = true
                ul += `<li><div class='${Opt.linkClass} cl-level-${tree[i].level}' ${Opt.datasetName}='${tree[i].id}'>${tree[i].name}</div>`
                ul += generateHtmlTree(tree, tree[i])
                ul += '</li>'
              }
            }
            ul += `</ul>`
          }
          return hasChild ? ul : ''
        }

        /**
         * 判断是否是相同节点
         */
        function isEqual(node, node2) {
          return (
            node &&
            node2 &&
            typeof node === 'object' &&
            typeof node2 === 'object' &&
            node.id === node2.id
          )
        }

        /**
         *  设置选中的项
         */
        function setActiveItem(id) {
          let catas = [...$catalog.querySelectorAll(`[${Opt.datasetName}]`)]

          catas.forEach(T => {
            if (T.getAttribute(Opt.datasetName) === id) {
              typeof Opt.activeHook === 'function' &&
                !T.classList.contains(Opt.linkActiveClass) &&
                Opt.activeHook.call(this, T) // 执行active钩子
              T.classList.add(Opt.linkActiveClass)
            } else {
              T.classList.remove(Opt.linkActiveClass)
            }
          })
        }
      }
    })()
    window.addEventListener(
      'DOMContentLoaded',
      _ =>
        new Catalog({
          contentEl: 'markdown',
          catalogEl: 'catalog',
        }),
    )
  })()
</script>

			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				
<a href="mailto:iamnomand@gmail.com"><img class="icon-social" src="/img/email.svg" alt="Email Me!"/></a>


<a href="https://github.com/v-tom/"><img class="icon-social" src="/img/github.svg" alt="Github"/></a>


<a href="https://twitter.com/iamnomand"><img class="icon-social" src="/img/twitter.svg" alt="Twitter"/></a>

<a href="https://hasaki.xyz/index.xml" target="_blank"><img class="icon-social" src="/img/feed.svg" alt="Feed"></a>

				<p>
					
					
					Early 2016 ~ 2020 &copy; TOM's Zone
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
		<script>hljs.initHighlightingOnLoad();</script>
		
	</body>
</html>

