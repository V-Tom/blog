<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="Keywords" content="">
    <meta name="full-screen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#006cb4">
    <meta name="apple-mobile-web-app-title" content="TOM&#39;s zone">
    <meta name="description" content="TOM&#39;s zone">
    <link rel="dns-prefetch" href="https://hasaki.xyz">
    <link rel="preconnect" href="https://hasaki.xyz">
    <link rel="manifest" href="/sw/manifest.json"/>
<title>Serverless 入门 - TOM&#39;s zone</title>

<meta name="description" content="老规矩，列出本机器环境
 serverless -v 1.46.0 node -v v10.15.0 system_profiler SPSoftwareDataType : macOS 10.14.3 (18D42) Darwin 18.2.0 云平台 aws vsCode for editor  什么是 Serverless Serverless 是一种架构模式。
根据 CNCF 的定义，Serverless 是指构建和运行不需要服务器管理的应用程序的概念。(serverless-overview)
 Serverless computing refers to the concept of building and running applications that do not require server management. &mdash; CNCF
 简单来讲，Serverless 指的是在构建 Web 应用程序的时候，而不用担心如何配置服务器，但是这并不意味着应用程序不会在服务器上运行，而是说服务器的管理都可以尽可能地交给相应的云平台，从而最大程度地减轻开发人员的部署与配置工作。与之对应的一个名词可能就是 Function As a Service（FAAS），由 AWS Lambda 这个命名上就能想到，当我们在构建 Serverless 架构时，实际上我们是在写一个个的 Function 即函数而已
云计算发展模式 云计算有常用的三种模式，如下图：
云计算的三种模型是 PaaS，SaaS（软件即服务）和 IaaS（基础架构即服务）。">




    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">


    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/ocean.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/javascript.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/python.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/css.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/swift.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/objectivec.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/rust.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/yaml.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/bash.min.js"></script>


    <link rel="stylesheet" href="/css/bundle.min.css"/>
<script src="/js/bundle.js"></script>

<style>
	a { color: #ff8181; }
	blockquote {
		background: rgba(255, 129, 129, .1);
		border-left-color: #ff8181;
		border-right-color: #ff8181; }
	.bar a:hover {
		color: #ff8181;
		text-decoration: none; }
	.sep {
		margin-top: 2rem;
		margin-bottom: 1rem;
		margin-left:0;
		width: 24rem;
		border-top: 2px solid #ff8181; }
    .bar li.active a{
        color:#ff8181;
    }
</style>

</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li>
		
		<li class="active"><a href="/blog/">Blog</a></li>
		<li class=""><a href="/gallery/">Gallery</a></li>
		<li class=""><a href="/life/">Life</a></li></ul>
</nav>

	</div>
</header>
<main class="container">

<article>
    <header><hgroup id="brand">
  <h1>Serverless 入门</h1>
  <h5>
    
    <time datetime="2019-04-12 12:52:40 &#43;0800 CST">Apr 12, 2019</time>
    <span class="no-print">
      -
      
      <a href="/tags/backend">BackEnd</a>
      </span>
  </h5>

  <a
    style="margin-top: 1.2rem;display: inline-block;"
    href="https://github.com/V-Tom/blog/blob/hugo/content/blog/2019-04-12-Serverless%20%e5%85%a5%e9%97%a8/index.md"
    >✨✨✨You can Edit this Article on Github site</a
  >

  <div id="git-update-time">
  ✏️✏️✏️ This article .MD file was last updated at:
  <b>Loading ...</b>
</div>

<script data-name="commits">
  ;(async () => {
    const b = document.querySelector('#git-update-time').querySelector('b')

    if (window.location.href.includes('localhost')) {
      b.innerHTML = 'localhost disable'
      return
    }

    const commits = await fetch(
      'https://api.github.com/repos/V-Tom/blog/commits?sha=hugo&path=content/blog\/2019-04-12-Serverless 入门\/index.md',
    ).then(res => res.json())
    try {
      const time = new Date(commits[0].commit.committer.date)
      b.innerHTML = `${time.getFullYear()}-${time.getMonth() +
        1}-${time.getDate()}`
    } catch (e) {
      b.innerHTML = 'unknown'
    }
  })()
</script>


  
</hgroup>
<hr class="sep" />
</header>
    <section id="markdown">
        

<p>老规矩，列出本机器环境</p>

<ul>
<li><code>serverless -v</code> 1.46.0</li>
<li><code>node -v</code> v10.15.0</li>
<li><code>system_profiler SPSoftwareDataType</code> : macOS 10.14.3 (18D42) Darwin 18.2.0</li>
<li>云平台 aws</li>
<li>vsCode for editor</li>
</ul>

<h2 id="什么是-serverless">什么是 Serverless</h2>

<p>Serverless 是一种架构模式。</p>

<p>根据 CNCF 的定义，Serverless 是指构建和运行不需要服务器管理的应用程序的概念。<a href="https://github.com/cncf/wg-serverless/tree/master/whitepapers/serverless-overview">(serverless-overview)</a></p>

<blockquote>
<p>Serverless computing refers to the concept of building and running applications that do not require server management. &mdash; CNCF</p>
</blockquote>

<p>简单来讲，Serverless 指的是在构建 Web 应用程序的时候，而不用担心如何配置服务器，但是这并不意味着应用程序不会在服务器上运行，而是说服务器的管理都可以尽可能地交给相应的云平台，从而最大程度地减轻开发人员的部署与配置工作。与之对应的一个名词可能就是 <code>Function As a Service（FAAS）</code>，由 AWS Lambda 这个命名上就能想到，当我们在构建 Serverless 架构时，实际上我们是在写一个个的 Function 即函数而已</p>

<h2 id="云计算发展模式">云计算发展模式</h2>

<p>云计算有常用的三种模式，如下图：</p>

<p><img src="./saas-paas-iaas-diagram.png" alt="saas-paas-iaas-diagram" /></p>

<p>云计算的三种模型是 PaaS，SaaS（软件即服务）和 IaaS（基础架构即服务）。</p>

<ul>
<li>IaaS 是指云计算基础架构 - 服务器，存储等 - 由云供应商管理</li>
<li>SaaS 是指托管在云中并由 SaaS 供应商维护的完整应用程序。</li>
<li>如果 SaaS 客户就像租房子一样，那么 PaaS 客户就像租用快速建造房屋所需的所有重型设备和电动工具一样，如果工具和设备由其所有者不断维护和修理。</li>
</ul>

<p><img src="./cloud.png" alt="cloud.png" /></p>

<h2 id="虚拟化与隔离">虚拟化与隔离</h2>

<p>你可能要问云计算为什么有这么多模式？</p>

<p>其实从最早的物理服务器开始，我们都在不断地抽象或者虚拟化服务器，开发人员为了保证开发环境的正确，以及云计算为了进一步地自动管理这些虚拟化的资源，大致有以下发展路程：</p>

<ul>
<li>虚拟机（如 XEN、KVM）</li>
<li>应用容器（如 Java 的 Tomcat）</li>
<li>虚拟环境（如 Python 中的 virtualenv）</li>
<li>流行的 Docker</li>
</ul>

<p>这些都是为了来隔离了应用的操作系统与服务器的操作，乃至更底层的技术细节，方便开发者可以更进一步的只关心业务层面的需求。</p>

<h2 id="serverless-的前景">Serverless 的前景</h2>

<p>近几年微服务发展迅速，加上 Serverless 的概念深入人心，各大云计算厂商纷纷推出了各自的 Serverless 产品，其中比较有代表性的有 <code>AWS lambda</code> 、<code>Azure Function</code> 、<code>Google Cloud Functions</code> 、阿里云函数计算等。</p>

<p><img src="./more-micro.png" alt="more-micro.png" /></p>

<p>如果你了解了云计算模式，你会发现 Paas 和 <code>Function As a Service（FAAS）</code> 也就是 Serverless 似乎很相似，那么两者有什么区别呢？</p>

<p><img src="./paas-vs-faas.png" alt="paas-vs-faas" /></p>

<p>其实通过图简单对比可以看到，Serverless 架构的出现让开发者更进一步不用过多地考虑传统的服务器采购、硬件运维、网络拓扑、资源扩容等问题，可以将更多的精力放在业务的拓展和创新上。</p>

<p>另外，CNCF 也于 2016 年创立了 <a href="https://github.com/cncf/wg-serverless">Serverless Working Group</a>，它致力于 <a href="https://www.cncf.io/">cloud native 云原生</a> 和 Serverless 技术的结合，Google 推出了 <a href="https://cloud.google.com/knative/">knative</a> 基于 k8s 的框架，可在任何公有私有云上实现无服务器架构，这样用户使用无服务器编程可以不限于特定的云平台。</p>

<blockquote>
<p>用户对云的期望是应用的运行环境，并且最好是只让用户关心业务逻辑，而不需要关心，或者尽量少关心技术逻辑（比如监控，性能，弹性，高可用，日志追踪等）。这也是云原生应用（Cloud Native Application）这个概念提出的背景：云原生应用就是让渡一部分功能给云，以实现弹性，高可用，故障恢复，降低研发运维成本的应用</p>
</blockquote>

<p>下图是 CNCF Serverless 全景图，它将这些产品分成了工具型、安全型、框架型和平台型等类别。</p>

<p><img src="./CNCF-serverless.png" alt="CNCF-serverless" /></p>

<p>按照 Serverless 架构，Serverless 在云计算当中的位置可以大致为下图，也是上图的简化版本：</p>

<p><img src="./from-bare-metal-to-functions.jpg" alt="from-bare-metal-to-functions" /></p>

<h2 id="更深一层的-serverless">更深一层的 Serverless</h2>

<h3 id="架构原则">架构原则</h3>

<ul>
<li>编写单一用途的无状态函数</li>
<li>设计基于推送的、事件驱动的管道</li>
<li>创建更强大的前端</li>
<li>与第三方服务集成</li>
</ul>

<h3 id="触发器">触发器</h3>

<p>Serverless 的运行才计算，便意味着他是一种 “严格” 的事件驱动式计算。</p>

<blockquote>
<p>事件驱动编程（英语：Event-driven programming）是一种电脑程序设计模型。这种模型的程序运行流程是由用户的动作（如鼠标的按键，键盘的按键动作）或者是由其他程序的消息来决定的。相对于批处理程序设计（batch programming）而言，程序运行的流程是由程序员来决定。批量的程序设计在初级程序设计教学课程上是一种方式。然而，事件驱动程序设计这种设计模型是在交互程序（Interactive program）的情况下孕育而生的</p>
</blockquote>

<p>以 aws 为例，对应的触发器有：</p>

<ul>
<li>API Gateway(http request)</li>
<li>S3</li>
<li>CloudWatch Logs</li>
<li>CodeCommit</li>
</ul>

<p>等等各种各样的触发器，具体可以去 aws 上查看</p>

<h3 id="计费方式">计费方式</h3>

<p>我们知道 Serverless 其实就是我们编写函数然后平台去 run，那么问题又来了，它到底是怎么对一个函数收钱的。我在 Lambda 函数上运行一个 Hello, world 它会怎么收我的钱呢？</p>

<p>如果要对一个运行的函数收费，那么想必只有运行时间、CPU、内存占用、硬盘这几个条件。可针对于不同的需求，提供不同的 CPU 是一件很麻烦的事。对于代码来说，一个应用占用的硬盘空间几乎可以忽略不计。</p>

<p>在一个基于 AWS 的 Serverless 应用里，应用的组成是：</p>

<ul>
<li>网关 API Gateway 来接受和处理成千上万个并发 API 调用，包括流量管理、授权和访问控制、监控等</li>
<li>计算服务 Lambda 来进行代码相关的一切计算工作，诸如授权验证、请求、输出等等</li>
<li>基础设施管理 CloudFormation 来创建和配置 AWS 基础设施部署，诸如所使用的 S3 存储桶的名称等 -静态存储 S3 作为前端代码和静态资源存放的地方</li>
<li>数据库 DynamoDB 来存储应用的数据</li>
<li>等等</li>
</ul>

<p>以博客系统为例，当我们访问一篇博客的时候，只是一个 GET 请求，可以由 S3 为我们提供前端的静态资源和响应的 HTML。</p>

<p><img src="./serverless-spa.png" alt="serverless-spa.png" /></p>

<p>而当我们创建一个博客的时候：</p>

<ul>
<li>我们的请求先来到了 API Gateway，API Gateway 计费器 + 1</li>
<li>接着请求来到了 Lambda，进行数据处理，如生成 ID、创建时间等等，Lambda 计费器 + 1</li>
<li>Lambda 在计算完后，将数据存储到 DynamoDB 上，DynamoDB 计费器 + 1</li>
<li>最后，我们会生成静态的博客到 S3 上，而 S3 只在使用的时候按存储收费。</li>
<li>在这个过程中，我们使用了一系列稳定存在的云服务，并且只在使用时才计费。由于这些服务可以自然、方便地进行调用，我们实际上只需要关注在我们的 Lambda 函数上，以及如何使用这些服务完成整个开发流程。</li>
</ul>

<p>另外 AWS 的 lambda 文档页面有一个演示，非常形象的介绍了 FaaS 的工作机制。</p>

<p><img src="./lambda.gif" alt="lambda.gif" /></p>

<p>根据 <a href="https://aws.amazon.com/cn/lambda/pricing/">aws 文档</a>，Lambda 免费套餐包含每月 100 万个免费请求以及每月 400000GB-秒的计算时间。</p>

<p><img src="./aws-serverless-price.png" alt="aws-serverless-price.png" /></p>

<p>总结一下大致为：</p>

<p><img src="./serverless-cost.png" alt="serverless-cost.png" /></p>

<h3 id="性能和冷启动时间">性能和冷启动时间</h3>

<p>对于传统的应用，我们的程序启动起来之后，就常驻在内存中；而 Serverless 函数则不是这样。</p>

<p>当驱动函数执行的事件到来的时候，首先需要下载代码，然后启动一个容器，在容器里面再启动一个运行环境，最后才是执行代码。前几步统称为冷启动（Cold Start）。传统的应用没有冷启动的过程。</p>

<p>下面是函数生命周期的示意图：</p>

<p><img src="./lifecycle.png" alt="lifecycle.png" /></p>

<p>在此之前，已经有很多人测试过不同编程语言对冷启动时间的影响，比如：</p>

<ul>
<li><a href="https://theburningmonk.com/2017/06/aws-lambda-compare-coldstart-time-with-different-languages-memory-and-code-sizes/">Compare coldstart time with different languages, memory and code sizes</a></li>
<li><a href="https://blog.octo.com/en/cold-start-warm-start-with-aws-lambda/">Cold start / Warm start with AWS Lambda</a></li>
</ul>

<p><img src="./compare-performance.png" alt="compare-performance.png" /></p>

<p>从这些测试中能够得到一些统一的结论：</p>

<ul>
<li>增加函数的内存可以减少冷启动时间</li>
<li>C#、Java 等编程语言的能启动时间大约是 Node.js、Python 的 100 倍</li>
</ul>

<p>基于上述结论，如果想要 Java 的冷启动时间达到 Node.js 那么小，可以为 Java 分配更大的内存。但更大的内存意味着更多的成本。</p>

<p>刚开始接触 Serverless 的开发者可能有一个误区，就是每次函数执行，都需要冷启动。其实并不是这样。</p>

<p>当第一次请求（驱动函数执行的事件）来临，成功启动运行环境并执行函数之后，运行环境会保留一段时间，以便用于下一次函数执行。这样就能减少冷启动的次数，从而缩短函数运行时间。当请求达到一个运行环境的限制时，FaaS 平台会自动扩展下一个运行环境。</p>

<blockquote>
<p>以 AWS Lambda 为例，在执行函数之后，Lambda 会保持执行上下文一段时间，预期用于另一次 Lambda 函数调用。其效果是，服务在 Lambda 函数完成后冻结执行上下文，如果再次调用 Lambda 函数时 AWS Lambda 选择重用上下文，则解冻上下文供重用。</p>
</blockquote>

<p><img src="./auto-scale.png" alt="auto-scale" /></p>

<h2 id="不同云平台的-serverless">不同云平台的 Serverless</h2>

<p><img src="./compare-with-cloud.png" alt="compare-with-cloud.png" /></p>

<p>上图从支持语言、触发器、价格等多个方面对不同 Serverless 服务进行了对比，可以发现有差异，也有共性。</p>

<p>比如几乎所有 Serverless 服务都支持 Node.js/Python/Java 等语言。</p>

<p>当然也有很多的差异。</p>

<h3 id="serverless-的优势">Serverless 的优势</h3>

<p>其实我们不难发现 Serverless 的一些优势也是上云的优势，只是相比较之前的云计算模式，有了一些 Serverless 独特的好处。</p>

<ul>
<li>降低启动成本</li>
<li>减少运营成本</li>
</ul>

<p>首先采用函数计算的 Serverless 与云服务器最大的不同之处在于：云服务器需要一直运行，而函数计算是按需计算。</p>

<p>按需计算就意味着，在请求到来的时候，才运行函数。没有请求的时候，是不算钱的。</p>

<p>其次 Serverless 意味无维护，Serverless 不代表完全去除服务器，而是代表去除有关对服务器运行状态的关心和担心，它们是否在工作，应用是否跑起来正常运行等等。Serverless 代表的是你不要关心运营维护问题。有了 Serverless，可以几乎无需 Devops 了。</p>

<ul>
<li>系统安全性更高</li>
<li>适应微服务架构</li>
<li>自动扩展能力</li>
</ul>

<p>对于传统应用来说，要应对更多的请求的方式，就是部署更多的实例。然而，这个时候往往已经来不及了。而对于 FaaS 来说，我们并不需要这么做，Serverless 提供的 FaaS 会自动的扩展。它可以在需要时尽可能多地启动实例副本，而不会发生冗长的部署和配置延迟。</p>

<h2 id="serverless-的劣势">Serverless 的劣势</h2>

<p>开发当然没有银弹，Serverless 也有对应的硬伤。</p>

<ul>
<li>不适合长时间运行应用</li>
</ul>

<p>Serverless 在请求到来时才运行。这意味着，当应用不运行的时候就会进入 “休眠状态”，下次当请求来临时，应用将会需要一个启动时间，即冷启动。</p>

<ul>
<li>完全依赖于第三方服务</li>
</ul>

<p>当你已经有大量的基础设施的时候，Serverless 对于你来说，并不是一个好东西。当我们采用 Serverless 架构的时候，我们就和特别的服务供应商绑定了。all in cloud，我们使用了 AWS 家的服务，那么我们再将服务迁到 Google Cloud 上就没有那么容易了</p>

<ul>
<li>冷启动时间和性能</li>
<li>缺乏调试和开发工具</li>
<li>构建复杂（主要是各个云平台的差异</li>
</ul>

<h2 id="serverless-的适用场景">Serverless 的适用场景</h2>

<p>尽管 Serverless 在编写传统的 Web 应用上，有一定的缺点。然而，它的事件驱动及运行时计算，使得它在某些场景上相当的合适，比如：</p>

<ul>
<li><code>spa</code></li>
<li><code>push notification</code></li>
<li><code>web hook</code></li>
<li><code>log trace</code></li>
<li><code>iot</code></li>
<li><code>cron job</code></li>
<li><code>robot</code></li>
<li><code>stream</code></li>
<li>等等</li>
</ul>

<h2 id="基于-serverless-的前端开发模式">基于 Serverless 的前端开发模式</h2>

<p>基于 Serverless 的前端开发模式，也有一些可取之处。</p>

<h3 id="服务端渲染-ssr">服务端渲染（ssr</h3>

<p>传统的服务端渲染，每个请求的 path 都对应着服务端的每个路由，由该路由实现对应 path 的 HTML 文档渲染。用于渲染的服务端程序，就是这些集成了这些路由的应用。</p>

<p>使用 Serverless 来做服务端渲染，就是将以往的每个路由，都拆分为一个个函数，再在 FaaS 上部署对应的函数。这样用户请求的 path，对应的就是每个单独的函数。</p>

<p><img src="./serverless-ssr.png" alt="serverless-ssr.png" /></p>

<p>ZEIT 的 <a href="https://nextjs.org/docs/#serverless-deployment">Next.js</a> 就对基于 Serverless 的服务端渲染做了很好的实现。</p>

<h3 id="小程序开发">小程序开发</h3>

<p>目前国内使用 Serverless 较多的场景可能就是小程开发了，可以参照<a href="https://docs.alipay.com/mini/developer/todo-basement">支付宝云开发</a>当中的例子，函数就是定义在 FaaS 服务中的函数。</p>

<h2 id="hello-world">hello world</h2>

<p>我们采用 aws lambda 来编写第一个 Serverless 例子，我们也可以直接通过 GUI 的方式来创建，这种方式比较简单，不得不说这几年 aws 的 UI 做的非常好。</p>

<p><img src="./aws-create-function-gui-overview.png" alt="aws-create-function-gui-overview.png" /></p>

<p>这里我们选择了通过 <a href="https://github.com/serverless/serverless">Serverless</a> 框架来实现。</p>

<blockquote>
<p>你也可以选择 tj 的 <code>Apex</code></p>
</blockquote>

<h3 id="aws-user">aws user</h3>

<p>首先我们需要设置 aws 凭证，也就是设置 <code>Provider Credentials</code>。具体可以参照这篇文章 <a href="https://serverless.com/framework/docs/providers/aws/guide/credentials/">AWS - Credentials</a></p>

<p><img src="./add-aws-user.png" alt="add-aws-user.png" /></p>

<blockquote>
<p>如果你觉得参考文章过于复杂，可以在步骤二 <code>set permissions</code> 里面可以选择 <code>Attach existing policies directly</code> 然后选择 <code>Filter policies</code> 为 <code>AdministratorAccess</code>，注意这个用户是 admin ，不要泄漏你的 key 和 token，当然还是建议按照上文的步骤来。</p>
</blockquote>

<p>然后导出你的 key 和 token 并用 <code>serverless depoy</code> 保存在本地，将会自动生成配置到 <code>~/.aws/credentials</code>：</p>

<pre><code class="language-bash">export AWS_ACCESS_KEY_ID=&lt;your-key-here&gt;
export AWS_SECRET_ACCESS_KEY=&lt;your-secret-key-here&gt;

serverless deploy
</code></pre>

<h3 id="deploy-it">deploy it</h3>

<p>我们需要安装框架，然后生成对应的模板代码，创建我们的项目 hello-world：</p>

<blockquote>
<p>我们通过配置 SLS_DEBUG=* 环境变量来详细查看 log</p>
</blockquote>

<pre><code class="language-bash">npm i -g -d serverless

export SLS_DEBUG=* &amp;&amp; serverless create --template aws-nodejs --path hello-world
</code></pre>

<p>成功后 terminal 会有以下 log：</p>

<pre><code class="language-log">Serverless: Invoke create
Serverless: Generating boilerplate...
Serverless: Generating boilerplate in &quot;/Users/***YOUR CURRENT PATH ***/hello-world&quot;
 _______                             __
|   _   .-----.----.--.--.-----.----|  .-----.-----.-----.
|   |___|  -__|   _|  |  |  -__|   _|  |  -__|__ --|__ --|
|____   |_____|__|  \___/|_____|__| |__|_____|_____|_____|
|   |   |             The Serverless Application Framework
|       |                           serverless.com, v1.46.0
 -------'

Serverless: Successfully generated boilerplate for template: &quot;aws-nodejs&quot;
</code></pre>

<p>生成这两个文件，可以自行查看文件内容，其中 <code>serverless.yml</code> 是项目配置，<code>handler.js</code> 是当前主入口文件：</p>

<pre><code class="language-txt">├── handler.js
└── serverless.yml
</code></pre>

<p>然后我们直接 <code>serverless deploy -v</code> 来部署，成功的话会有以下 log :</p>

<blockquote>
<p>serverless 框架选择 aws 的时候，默认 region 为 us-east-1</p>
</blockquote>

<p><img src="./serverless-deploy.png" alt="serverless-deploy.png" /></p>

<p>触发一下这个函数 <code>serverless invoke -f hello -l</code> 来测试我们的服务是否上线成功，会有以下返回：</p>

<p><img src="./serverless-invoke.png" alt="serverless-invoke.png" /></p>

<p>这意味着，我们的第一个服务已经成功上线了。</p>

<p>请注意这个目前还不能通过 http 的形式访问，需要添加 <code>API Gateway</code> trigger 来配置，这个可以在 <code>serverless</code> 框架当中配置也可以直接去 aws console 配置。</p>

<p>当我们配置好之后，对应的 http 地址大致为：<code>https://2peo0alpzb.execute-api.us-east-1.amazonaws.com/default/hello-world-dev-hello</code></p>

<p>当然 Serverless 能做的远远不止这些，还有更多的功能等待各位去挖掘。</p>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://serverless.com/">https://serverless.com/</a></li>
<li><a href="https://www.cloudflare.com/learning/serverless/glossary/serverless-vs-paas/">How are serverless computing and Platform-as-a-Service different? | PaaS vs. Serverless</a></li>
<li><a href="https://www.nginx.com/blog/what-is-a-service-mesh/">What Is a Service Mesh?</a></li>
<li><a href="https://cloud.google.com/knative/">knative</a></li>
<li><a href="https://serverless.ink/">serverless.ink</a></li>
<li><a href="https://juejin.im/post/5cdc3dc2e51d453b6c1d9d3a">探索 Serverless 中的前端开发模式</a></li>
<li><a href="https://medium.com/@amiram_26122/the-hidden-costs-of-serverless-6ced7844780b">The hidden costs of serverless</a></li>
</ul>

    </section>
    <nav class="no-print post-nav">
        
        <a class="prev-post" href="https://hasaki.xyz/blog/2019-03-04--grpc-%E6%B5%85%E8%B0%88%E4%B8%8E%E5%AE%9E%E8%B7%B5/">
            <img class="icon-text" src="/img/prev.svg"/>gRPC 浅谈与实践</a>
        
        
        <a class="next-post" href="https://hasaki.xyz/blog/2019-06-17-%E8%BD%AC%E8%BD%BD%E4%B8%83%E7%89%9B%E4%BA%91%E8%AE%B8%E5%BC%8F%E4%BC%9F%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88/">转载：七牛云许式伟：我所理解的架构是什么<img class="icon-text" src="/img/next.svg"/>
        </a>
        
    </nav>
</article>



<div id="disqus_thread" class="no-print"></div>
<script type="text/javascript">
  'use strict'
  ;(function() {
    if ('localhost' != window.location.hostname) {
      var a = document.querySelector('#disqus_thread')
      new IntersectionObserver(
        function(b) {
          b.forEach(function(d) {
            if (0 < d.intersectionRatio && !a.classList.contains('active')) {
              var e = document.createElement('script')
              ;(e.type = 'text/javascript'), (e.async = !0)
              ;(e.src =
                '//' + 'hasaki-xyz' + '.disqus.com/embed.js'),
                (
                  document.getElementsByTagName('head')[0] ||
                  document.getElementsByTagName('body')[0]
                ).appendChild(e),
                a.classList.add('active')
            }
          })
        },
        { rootMargin: '0px', threshold: 1 },
      ).observe(a)
    }
  })()
</script>

<script type="text/javascript">
  window.customElements.define(
    'back-to-top',
    class BackToTop extends HTMLElement {
      constructor() {
        super()
      }

      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: 'open' })

        shadowRoot.innerHTML = `
          <style>
            :host {
              box-sizing: border-box;
              position: fixed;
              width: 55px;
              height: 55px;
              bottom: 8%;
              right: 3%;
              border-radius: 5px;
              display: flex;
              justify-content: center;
              align-items: center;
              flex-direction: column;
              cursor: pointer;
              will-change: transform;
              transform: translate3d(0, 500px, 0);
              transition: transform 1s ease;
              background: #ff8181;
              border: 1px solid #ff8181;
              color: #fff;
            }
            :host(.show) {
              transform: translate3d(0, 0, 0);
            }
            :host::after,
            :host::before {
              content: '';
              display: block;
              box-sizing: border-box;
              position: relative;
            }
            :host::before {
              width: 8px;
              height: 8px;
              border-top: 2px solid;
              border-left: 2px solid;
              transform: rotate(45deg);
              top: 4px;
            }
            :host::after {
              width: 2px;
              height: 16px;
              top: -4px;
              background: currentColor;
            }
        `

        shadowRoot.host.addEventListener('click', e => {
          window.scrollTo({
            top: 0,
            left: 0,
            behavior: 'smooth',
          })
        })

        const scrollHeight = document.documentElement.scrollHeight

        window.addEventListener('scroll', e => {
          if (document.documentElement.scrollTop > scrollHeight / 4) {
            shadowRoot.host.classList.add('show')
          } else {
            shadowRoot.host.classList.remove('show')
          }
        })
      }
    },
  )
</script>
<back-to-top></back-to-top>


<style rel="catalog">
  #catalog {
    position: fixed;
    min-width: 12vw;
    left: 3vw;
    top: 8vh;
    overflow: auto;
    height: calc(100% - 16vh);
    background:
      linear-gradient(
        white 30%,
        rgba(255, 255, 255, 0)
      ),
      linear-gradient(rgba(255, 255, 255, 0), white 70%) 0 100%,
       
        radial-gradient(
          50% 0,
          farthest-side,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        ),
      radial-gradient(
          50% 100%,
          farthest-side,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        )
        0 100%;
    background:
      linear-gradient(
        white 30%,
        rgba(255, 255, 255, 0)
      ),
      linear-gradient(rgba(255, 255, 255, 0), white 70%) 0 100%,
       
        radial-gradient(
          farthest-side at 50% 0,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        ),
      radial-gradient(
          farthest-side at 50% 100%,
          rgba(0, 0, 0, 0.2),
          rgba(0, 0, 0, 0)
        )
        0 100%;
    background-repeat: no-repeat;
    background-color: white;
    background-size: 100% 40px, 100% 40px, 100% 14px, 100% 14px;

     
    background-attachment: local, local, scroll, scroll;
  }
  @media (max-width: 1280px) {
    #catalog {
      display: none;
    }
  }

  #catalog::-webkit-scrollbar {
    display: none;
  }

  .cl-wrapper {
    position: relative;
  }

  .cl-wrapper ul,
  .cl-wrapper li {
    margin: 0;
    -moz-padding-start: 12px;
    -webkit-padding-start: 12px;
    list-style: none;
  }

  .cl-wrapper li > .cl-link.cl-link-active {
    color: #ff8181;
    transition: 0.5s;
  }

  .cl-wrapper li > .cl-transform.cl-link-active {
    transform: translate(3px);
  }

  .cl-wrapper .cl-link {
    cursor: pointer;
    color: rgba(52, 73, 94, 0.5);
    font-size: 13px;
    transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
  }

  .cl-wrapper .cl-marker {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }

  .cl-wrapper .cl-marker path {
    transition: all 0.3s ease;
  }
</style>
<main id="catalog"></main>
<script rel="catalog">
  void (function() {
    if (
      window.innerWidth < 1024 ||
      /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)
    ) {
      return
    }

    const Catalog = (function() {
      return function(opts) {
        let defaultOpts = {
          linkClass: 'cl-link', 
          linkActiveClass: 'cl-link-active', 
          datasetName: 'data-cata-target', 
          selector: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'], 
          scrollWrapper: null, 
          activeHook: null, 
          topMargin: 0,
          bottomMargin: 0,
          cool: true, 
        }

        const Opt = Object.assign({}, defaultOpts, opts)

        const $content = document.getElementById(Opt.contentEl) 
        const $scroll_wrap = window 
        const $catalog = document.getElementById(Opt.catalogEl) 

        let allCatalogs = $content.querySelectorAll(Opt.selector.join())
        let tree = getCatalogsTree(allCatalogs)

        try {
          $catalog.innerHTML = `<div class='cl-wrapper'>${generateHtmlTree(
            tree,
            { id: -1 },
          )}<svg class="cl-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
            <path stroke="#ff8181" stroke-width="3" fill="transparent" stroke-dasharray="0, 0, 0, 1000" stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)" />
            </svg></div>`
        } catch (e) {
          console.error('error in progress-catalog', e)
        }

        const tocPath = $catalog.querySelector('.cl-marker path')
        let tocItems, pathLength 

        
        window.addEventListener('resize', drawPath)
        $catalog.addEventListener('click', clickHandler)
        Opt.cool && $scroll_wrap.addEventListener('scroll', coolScrollHandler)
        Opt.cool || $scroll_wrap.addEventListener('scroll', simpleScrollHandler)

        setTimeout(drawPath) 

        

        function drawPath() {
          tocItems = [...$catalog.querySelectorAll('li')]
          tocItems = tocItems.map(function(liDom) {
            const anchor = liDom.querySelector(`.${Opt.linkClass}`)
            const target = document.getElementById(
              anchor.getAttribute('data-cata-target'),
            )

            return {
              listItem: liDom,
              anchor: anchor,
              target: target,
            }
          })
          tocItems = tocItems.filter(item => !!item.target)

          const path = []
          let pathIndent

          tocItems &&
            tocItems.forEach(function(item, idx) {
              const { offsetLeft, offsetTop, offsetHeight } = item.anchor,
                x = Opt.cool ? offsetLeft - 5 : offsetLeft,
                y = offsetTop,
                height = offsetHeight

              if (idx === 0) {
                path.push('M', x, y, 'L', x, y + height)
                item.pathStart = 0
              } else {
                if (pathIndent !== x) path.push('L', pathIndent, y) 
                path.push('L', x, y)
                tocPath.setAttribute('d', path.join(' '))
                item.pathStart = tocPath.getTotalLength() || 0
                path.push('L', x, y + height)
              }
              pathIndent = x
              tocPath.setAttribute('d', path.join(' '))
              item.pathEnd = tocPath.getTotalLength()
            })
          pathLength = tocPath.getTotalLength()
          coolScrollHandler()
        }

        

        function coolScrollHandler() {
          const wrapHeight = document.documentElement.offsetHeight
          let pathStart = pathLength,
            pathEnd = 0,
            visibleItems = 0
          tocItems.forEach(function(liItem) {
            const { bottom, top } = liItem.target.getBoundingClientRect(),
              firstChild = liItem.listItem.firstChild
            if (bottom > Opt.topMargin && top < wrapHeight - Opt.bottomMargin) {
              firstChild.classList.remove(Opt.linkActiveClass)
              Opt.cool && firstChild.classList.remove('cl-transform')
            } else {
              pathStart = Math.min(liItem.pathStart, pathStart)
              pathEnd = Math.max(liItem.pathEnd, pathEnd)
              visibleItems += 1
              firstChild.classList.add(Opt.linkActiveClass)
              Opt.cool && firstChild.classList.add('cl-transform')
            }
          })
          if (visibleItems > 0 && pathStart < pathEnd && Opt.cool) {
            tocPath.setAttribute('stroke-dashoffset', '1')
            tocPath.setAttribute(
              'stroke-dasharray',
              `1, ${pathStart}, ${pathEnd - pathStart}, ${pathLength}`,
            )
            tocPath.setAttribute('opacity', '1')
          } else {
            tocPath.setAttribute('opacity', '0')
          }
        }

        

        function simpleScrollHandler(el) {
          let scrollToEl = null
          for (let i = allCatalogs.length - 1; i >= 0; i--) {
            if (allCatalogs[i].offsetTop <= $scroll_wrap.scrollTop) {
              scrollToEl = allCatalogs[i]
              break
            }
          }
          if (scrollToEl) setActiveItem(scrollToEl.id)
          else setActiveItem(null) 
        }

        

        function clickHandler({ target }) {
          const datasetId = target.getAttribute(Opt.datasetName)
          target.classList.contains(Opt.linkClass) &&
            document
              .getElementById(datasetId)
              .scrollIntoView({ behavior: 'smooth', block: 'start' })
        }

        

        function getCatalogsTree(catalogs) {
          let title,
            tagName,
            tree = [],
            treeItem = {},
            parentItem = { id: -1 },
            lastTreeItem = null,
            id

          for (let i = 0; i < catalogs.length; i++) {
            title = catalogs[i].innerText || catalogs[i].textContent
            tagName = catalogs[i].tagName
            id = 'heading-' + i
            catalogs[i].id = id
            treeItem = {
              name: title,
              tagName: tagName,
              id: id,
              level: +getLevel(tagName),
              parent: parentItem,
            }
            if (lastTreeItem) {
              if (getLevel(treeItem.tagName) > getLevel(lastTreeItem.tagName)) {
                treeItem.parent = lastTreeItem
              } else {
                treeItem.parent = findParent(treeItem, lastTreeItem)
              }
            }
            lastTreeItem = treeItem
            tree.push(treeItem)
          }
          return tree
        }

        

        function findParent(currTreeItem, lastTreeItem) {
          let lastTreeParent = lastTreeItem.parent
          while (
            lastTreeParent &&
            getLevel(currTreeItem.tagName) <= getLevel(lastTreeParent.tagName)
          ) {
            lastTreeParent = lastTreeParent.parent
          }
          return lastTreeParent || { id: -1 }
        }

        

        function getLevel(tagName) {
          return tagName ? tagName.slice(1) : 0
        }

        

        function generateHtmlTree(tree, _parent) {
          let ul,
            hasChild = false
          if (tree) {
            ul = `<ul>`
            for (let i = 0; i < tree.length; i++) {
              if (isEqual(tree[i].parent, _parent)) {
                hasChild = true
                ul += `<li><div class='${Opt.linkClass} cl-level-${tree[i].level}' ${Opt.datasetName}='${tree[i].id}'>${tree[i].name}</div>`
                ul += generateHtmlTree(tree, tree[i])
                ul += '</li>'
              }
            }
            ul += `</ul>`
          }
          return hasChild ? ul : ''
        }

        /**
         * 判断是否是相同节点
         */
        function isEqual(node, node2) {
          return (
            node &&
            node2 &&
            typeof node === 'object' &&
            typeof node2 === 'object' &&
            node.id === node2.id
          )
        }

        /**
         *  设置选中的项
         */
        function setActiveItem(id) {
          let catas = [...$catalog.querySelectorAll(`[${Opt.datasetName}]`)]

          catas.forEach(T => {
            if (T.getAttribute(Opt.datasetName) === id) {
              typeof Opt.activeHook === 'function' &&
                !T.classList.contains(Opt.linkActiveClass) &&
                Opt.activeHook.call(this, T) // 执行active钩子
              T.classList.add(Opt.linkActiveClass)
            } else {
              T.classList.remove(Opt.linkActiveClass)
            }
          })
        }
      }
    })()
    window.addEventListener('DOMContentLoaded', function() {
      new Catalog({
        contentEl: 'markdown',
        catalogEl: 'catalog',
      })
    })
  })()
</script>

			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				
<a href="mailto:iamnomand@gmail.com"><img class="icon-social" src="/img/email.svg" alt="Email Me!"/></a>


<a href="https://github.com/v-tom/"><img class="icon-social" src="/img/github.svg" alt="Github"/></a>


<a href="https://twitter.com/iamnomand"><img class="icon-social" src="/img/twitter.svg" alt="Twitter"/></a>

<a href="https://hasaki.xyz/index.xml" target="_blank"><img class="icon-social" src="/img/feed.svg" alt="Feed"></a>

				<p>
					
					
					Early 2016 ~ 2020 &copy; TOM's Zone
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
		<script>hljs.initHighlightingOnLoad();</script>
		
	</body>
</html>


<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-108259988-2"
></script>
<script>
  window.dataLayer = window.dataLayer || []
  function gtag() {
    dataLayer.push(arguments)
  }
  gtag('js', new Date())

  gtag('config', 'UA-108259988-2')
</script>

