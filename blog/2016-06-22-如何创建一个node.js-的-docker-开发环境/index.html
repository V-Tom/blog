<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="Keywords" content="">
    <meta name="full-screen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#006cb4">
    <meta name="apple-mobile-web-app-title" content="TOM&#39;s zone">
    <meta name="description" content="TOM&#39;s zone">
    <link rel="dns-prefetch" href="https://hasaki.xyz">
    <link rel="preconnect" href="https://hasaki.xyz">
    <link rel="manifest" href="/sw/manifest.json"/>
<title>如何创建一个Node.js 的 Docker 开发环境 - TOM&#39;s zone</title>

<meta name="description" content="本文以构建一个 Node.js Docker应用 为目标写的一个教程。当前操作系统环境 Mac OSX Sierra 10.12.4
 Docker介绍  Docker 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的运行效率，降低了云计算资源供应的成本！ 使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！
 Docker引擎的基础是Linuxring器(Linux Containers，LXC)技术。这个并不是一个新生的概念，很早前已经出现，比如操作系统上的chroot工具、以及Solaris Containers和FreeBSD jail等等，虽然这个技术非常成熟，然而这些工具使用起来非常不方便。Docker的出现解决了这些问题。
Docker容器虚拟化有很多好处：
 更高效的利用系统资源：由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。 更快速的启动时间，Docker容器应用启动时间很快 一致的运行环境和环境隔离 持续交付和部署 更轻松的迁移服务  既然Docker这么好，我们来试试如何跑一个Node.js Docker应用。
安装Docker 使用Docker之前，我们需要安装。Docker支持在主流操作平台上使用：包括Ubuntu、CenterOS、Windows已经MacOS系统。
Ubuntu 在Ubuntu上安装Docker可以直接使用以下shell script
// 最新的Docker安装需要先移除老的Docker sudo apt-get remove docker docker-engine sudo apt-get update sudo curl -sSL https://get.docker.com/ | sh  Windows Windows 上我们可以直接下载 Docker GUI
Mac OSX Mac OSX 上我们也可以直接下载 Docker GUI。
Docker的主要目标是Build ship and run any app,any where.">




    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">


    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/ocean.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/javascript.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/python.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/css.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/swift.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/objectivec.min.js"></script>


    <link rel="stylesheet" href="/css/bundle.min.css"/>
<script src="/js/bundle.min.js"></script>
<style>
	a { color: #ff8181; }
	blockquote {
		border-left-color: #ff8181;
		border-right-color: #ff8181; }
	.bar a:hover {
		color: #ff8181;
		text-decoration: none; }
	.sep {
		margin-top: 2rem;
		margin-bottom: 1rem;
		margin-left:0;
		width: 24rem;
		border-top: 2px solid #ff8181; }
    .bar li.active a{
        color:#ff8181;
    }
</style>

</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li>
		
		<li class="active"><a href="/blog/">Blog</a></li></ul>
</nav>

	</div>
</header>
<main class="container">

<article>
    <header><hgroup id="brand">
	<h1>如何创建一个Node.js 的 Docker 开发环境</h1>
	<h5>
		
		<time datetime="2016-06-22 15:29:40 &#43;0800 CST">Jun 22, 2016</time>
		<span class="no-print">
			-
			
			<a href="/tags/node.js">Node.js</a>
			
			<a href="/tags/docker">Docker</a>
			
			<a href="/tags/cluster">Cluster</a>
			</span>
	</h5>

	
	<a style="margin-top: 1.2rem;display: inline-block;" href="https://github.com/V-Tom/blog/blob/hugo/content/blog/2016-06-22-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AANode.js%20%E7%9A%84%20Docker%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/index.md">✨✨✨You can Edit this Article on Github</a>
	
	
	
</hgroup>
<hr class="sep" /></header>
    <section id="markdown">
        

<blockquote>
<p>本文以构建一个 Node.js Docker应用 为目标写的一个教程。当前操作系统环境 Mac OSX Sierra 10.12.4</p>
</blockquote>

<h3 id="docker介绍">Docker介绍</h3>

<blockquote>
<p>Docker 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的运行效率，降低了云计算资源供应的成本！ 使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！</p>
</blockquote>

<p>Docker引擎的基础是Linuxring器(Linux Containers，LXC)技术。这个并不是一个新生的概念，很早前已经出现，比如操作系统上的<code>chroot</code>工具、以及<code>Solaris Containers</code>和<code>FreeBSD jail</code>等等，虽然这个技术非常成熟，然而这些工具使用起来非常不方便。Docker的出现解决了这些问题。</p>

<p>Docker容器虚拟化有很多好处：</p>

<ul>
<li>更高效的利用系统资源：由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。</li>
<li>更快速的启动时间，Docker容器应用启动时间很快</li>
<li>一致的运行环境和环境隔离</li>
<li>持续交付和部署</li>
<li>更轻松的迁移服务</li>
</ul>

<p>既然Docker这么好，我们来试试如何跑一个Node.js Docker应用。</p>

<h3 id="安装docker">安装Docker</h3>

<p>使用Docker之前，我们需要安装。Docker支持在主流操作平台上使用：包括Ubuntu、CenterOS、Windows已经MacOS系统。</p>

<h4 id="ubuntu">Ubuntu</h4>

<p>在Ubuntu上安装Docker可以直接使用以下shell script</p>

<pre><code class="language-shell"> // 最新的Docker安装需要先移除老的Docker
 sudo apt-get remove docker docker-engine
 sudo apt-get update
 sudo curl -sSL https://get.docker.com/ | sh
</code></pre>

<h4 id="windows">Windows</h4>

<p>Windows 上我们可以直接下载 <a href="https://store.docker.com/editions/community/docker-ce-desktop-windows">Docker GUI</a></p>

<h4 id="mac-osx">Mac OSX</h4>

<p>Mac OSX 上我们也可以直接下载 <a href="https://store.docker.com/editions/community/docker-ce-desktop-mac">Docker GUI</a>。</p>

<p>Docker的主要目标是<code>Build ship and run any app,any where</code>.主要生命周期有：封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等。</p>

<p>Docker具有三大核心概念：</p>

<ul>
<li><p>仓库（Repository）</p></li>

<li><p>镜像（Image）</p></li>

<li><p>容器 （Container）</p></li>
</ul>

<blockquote>
<p>本篇教程会按照这三大核心概念来展开，中间当然会穿插一些其他Docker方面的内容：Dockerfile、docker-compose</p>
</blockquote>

<h3 id="仓库">仓库</h3>

<p>Docker仓库类似于代码库，是存放Docker镜像文件的统一地方。分为公开仓库和私人仓库。目前最大的国内仓库是 Docker hub。但是这个仓库由于国内墙的原因pull一个镜像的时候会很慢，所以可以把Docker的仓库地址设置为国内，我们可以打开 <code>Docker preferences</code> 来设置 <code>registry mirrors</code>，我们这里可以设置为国内的 <a href="https://daocloud.io">daocloud</a>提供的仓库地址。设置完之后记得重启Docker，然后我们就可以安装我们需要的镜像了。</p>

<p><img src="./QQ20170422-235751@2x.png" alt="设置Docker registry mirrors" /></p>

<h3 id="镜像">镜像</h3>

<p>Docker镜像类似于虚拟机镜像，一个镜像可以只包含一个完整的Ubuntu操作系统环境。Docker提供了一套十分简单的机制来进行创建和更新现有镜像，甚至可以从网上下载第三方已经做好的镜像，当然也可以自己build一个自定义的镜像发布到仓库当中。</p>

<blockquote>
<p>再次提醒：我们当前教程最终的目的是创建一个 Node.js环境的Docker容器，当前操作系统环境 Mac OSX Sierra 10.12.4</p>
</blockquote>

<h4 id="docker-pull-name-tag">docker pull NAME[:TAG]</h4>

<p>Docker下载镜像的命令格式为：</p>

<pre><code class="language-shell">docker pull NAME[:TAG]
</code></pre>

<p>对于Docker来说，如果不显式的指定TAG（也可以理解为镜像版本），则默认会选择<code>latest</code>来作为标签：即下载仓库最新版本的镜像。</p>

<p>我们需要先安装一个稳定的<code>Ubuntu</code>镜像，在这里我选择了<code>16.04</code>版本的镜像：</p>

<pre><code class="language-shell">docker pull ubuntu:16.04
</code></pre>

<p>执行结果如下图：</p>

<p><img src="./QQ20170422-235751@2x.png" alt="docker pull ubuntu:16.04" /></p>

<h4 id="docker-iamges">docker iamges</h4>

<p>接下来我们可以列出本地主机上已经存在的镜像，通过以下命令可以看到我们刚才已经安装过的Ubuntu系统：</p>

<pre><code class="language-shell">docker iamges
</code></pre>

<p>执行结果如下图：</p>

<p><img src="./QQ20170423-000256@2x.png" alt="docker iamges" /></p>

<p>从列出信息中，我们可以看到很多有用的内容，依次为：</p>

<ul>
<li>来自于哪个仓库（REPOSITORY）</li>
<li>镜像的标签信息（TAG）</li>
<li>镜像的唯一id号（IMAGE ID）</li>
<li>创建时间（REACTED）</li>
<li>镜像大小（SIZE）</li>
</ul>

<blockquote>
<p>其中镜像的唯一id号（IMAGE ID）十分重要，它唯一标识了该镜像。</p>
</blockquote>

<h4 id="docker-inspect-image-id">docker inspect IMAGE_ID</h4>

<p>我们可以通过以下命令来查看指定 IMAGE_ID 镜像的详细信息，这里不再列出执行结果。</p>

<pre><code class="language-shell">docker inspect IMAGE_ID
</code></pre>

<h4 id="docker-search-name">docker search NAME</h4>

<p>如果我们准备获取镜像的时候并不知道这个镜像是否在远程仓库当中是否存在，我们可以通过下面命令来搜索，该条支持很多参数，这里不再列出，请自行<a href="https://docs.docker.com/engine/reference/commandline/search/">查看文档</a>，默认输出结果安装星级评价排序。</p>

<pre><code class="language-shell">docker search NAME
</code></pre>

<h4 id="docker-rmi-image-image">docker rmi IMAGE[IMAGE&hellip;]</h4>

<p>我们可以使用镜像的唯一标签来删除镜像，常用的参数是<code>--force, -f</code>来指定是否强制删除镜像。其他参数这里不再列出，请自行<a href="https://docs.docker.com/engine/reference/commandline/rmi/">查看文档</a>：</p>

<pre><code class="language-shell">docker rmi IMAGE[IMAGE...]
</code></pre>

<h4 id="创建镜像">创建镜像</h4>

<p>至此，Docker Image 常用的命令已经罗列完毕，其他更多命令请自行<a href="https://docs.docker.com/edge/engine/reference/commandline/docker/">参阅文档</a>。</p>

<p>接下来我们需要来创建我们需要的Node.js镜像。常用创建镜像的方式有三种：</p>

<ul>
<li>基于已有镜像创建</li>
</ul>

<p>该方法使用下面命令创建，由于这个方法是在已有镜像的基础上创建的镜像，但是我们这里需要<strong>自定义创建镜像</strong>，所以不采用该方式创建，请自行<a href="https://docs.docker.com/engine/reference/commandline/commit/">查看文档</a>：</p>

<pre><code class="language-shell">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]
</code></pre>

<ul>
<li>基于本地模板导入</li>
</ul>

<p>可以直接通过一个操作系统模板来创建镜像。我们依旧不采用，请自行<a href="https://docs.docker.com/engine/reference/commandline/import/">查看文档</a></p>

<ul>
<li>基于Dockerfile创建</li>
</ul>

<p>Dockerfile 是一个文本格式的配置文件，用户可以使用它来快速创建自定义的镜像，刚好符合我们的要求。在下面有详细介绍和使用教程。</p>

<h3 id="容器">容器</h3>

<h3 id="dockerfile">Dockerfile</h3>

<blockquote>
<p>Dockerfile 是一个文本格式的配置文件，用户可以使用它来快速创建自定义的镜像。</p>
</blockquote>

<p>Dockerfile 由一条条命令语句组成，并且支持以<strong>#</strong>开头的注释行。</p>

<p>一般来说，Dockerfile分为四个部分：</p>

<ul>
<li>基础镜像信息</li>
<li>维护者信息</li>
<li>镜像操作指令</li>
<li>容器启动时的执行命令</li>
</ul>

<p>接下来介绍一下Dockerfile的执行指令，一般格式为 INSTRUCTION arguments。</p>

<p>这些指令在我们来完成我们的目标：Node.js Docker应用 都会用到，更多的请自行<a href="https://docs.docker.com/engine/reference/builder/">查看文档</a>。我们需要用到的执行指令包括以下内容:</p>

<h4 id="from">FROM</h4>

<p>格式为：FROM <image> 或者FROM <image>:<tag>。</p>

<p>第一条指令必须为FROM指令，如果在一个Dockerfile当中创建多个镜像，可以使用多个FROM。ßß</p>

<h4 id="maintainer">MAINTAINER</h4>

<p>格式为：MAINTAINER <name>，指定维护者信息。</p>

<h4 id="run">RUN</h4>

<p>格式为：RUN <command> 或者 Run [&ldquo;executable&rdquo;,&ldquo;param1&rdquo;,&ldquo;param2&rdquo;]</p>

<p>区别是：前者将在shell终端中执行，也就是<code>/bin/sh -c</code>；后者则使用<code>exec</code>执行。</p>

<p>当命令过长的时候可以使用<code>\</code>来换行。</p>

<h4 id="cmd">CMD</h4>

<p>格式为：CMD command param1 param2 或者 CMD [&ldquo;executable&rdquo;,&ldquo;param1&rdquo;,&ldquo;param2&rdquo;]</p>

<p>区别是：前者将在shell终端中执行，也就是<code>/bin/sh -c</code>；后者则使用<code>exec</code>执行。</p>

<p>每个Dockerfile只能有一条CMD命令，如果指定多个，只有最后一个执行。</p>

<h4 id="expose">EXPOSE</h4>

<p>格式为：EXPOSE <port> [<port>…]。</p>

<p>告诉Docker服务器容器暴露的端口号来进行容器和本地主机端口映射。启动容器的时候通过<code>-p</code>可以具体指定端口</p>

<h4 id="env">ENV</h4>

<p>格式为：ENV <key> <value> 指定一个环境变量，并且在容器当中保持</p>

<h4 id="add">ADD</h4>

<p>格式为：ADD <src> <dest></p>

<p>该命令指定复制本地主机当中的<strong>src</strong>到容器当中的<strong>dest</strong>。其中src可以是相对路径、url、tar。</p>

<h4 id="copy">COPY</h4>

<p>格式为：COPY <src> <dest></p>

<p>该命令指定复制本地主机当中的<strong>src</strong>到容器当中的<strong>dest</strong>。目标路径不存在的时候自动创建</p>

<h4 id="volume">VOLUME</h4>

<p>格式为：VOLUME [&ldquo;/data&rdquo;]</p>

<p>创建一个可以从本地主机或者其他容器挂载的挂载点，一般来存储数据库或者需要保持链接的数据等。</p>

<h4 id="workdir">WORKDIR</h4>

<p>格式为：WORKDIR <path></p>

<p>定义当前容器的工作目录。</p>

<p>使用多次WORKDIR命令，如果参数是相对路径，则会何必每次的相对路径。</p>

<blockquote>
<p>接下来我们正式创建Node.js container</p>
</blockquote>

<h3 id="node-js-dockerfile">Node.js Dockerfile</h3>

<p>终于到了我们来编写Dockerfile来创建 Node.js container 的时候了！</p>

<p>在正式开始之前，我们先梳理一下任务要点：</p>

<ul>
<li>安装最新版本的Node.js（这里不选择stable版本）</li>
<li>从GitHub上下载我们的服务器代码（这里的例子采用本地服务器server.js，当然也会有GitHub的例子）</li>
<li>启动服务器并抛出端口</li>
</ul>

<p>下面正式开始，开始之前需要自行创建一个Dockerfile文件并且在相同文件目录下写入一个<code>server.js</code>来作为我们的本地例子，<code>server.js</code>可以参考：</p>

<pre><code class="language-javascript">'use strict'
const http = require('http')
const port = 3000
const server = http.createServer((req, res) =&gt; {
  res.end('hello world')
})
server.listen(3000, () =&gt; {
  process.stdout.write(`server start success on port ${port}`)
})
</code></pre>

<blockquote>
<p>上面server只是做一个简单的hello world例子 :smile:</p>
</blockquote>

<p>首先指定我们的基础镜像信息，这里我们选择<code>ubuntu:16.04</code>来作为基础镜像，并写好维护者信息。</p>

<pre><code class="language-dockerfile"># Docker file 文件头
FROM ubuntu:16.04
MAINTAINER Nomand &lt;iamnomand@gmail.com&gt;
</code></pre>

<p>然后设置本地语言，这个不是必要操作：</p>

<pre><code class="language-dockerfile"># 非必须操作
RUN locale-gen en_US.UTF-8
ENV LANG       en_US.UTF-8
ENV LC_ALL     en_US.UTF-8
</code></pre>

<p>由于国内的原因，我们需要设定阿里云的镜像来作为Ubuntu的更新镜像：</p>

<pre><code class="language-dockerfile"># 设置 Ubuntu 镜像源地址
RUN sed -i 's/http:\/\/archive\.ubuntu\.com\/ubuntu\//http:\/\/mirrors\.aliyun\.com\/ubuntu\//g' /etc/apt/sources.list
</code></pre>

<p>而且你也有可能需要设置一下代理：</p>

<pre><code class="language-dockerfile"># RUN export http_proxy=xxxxx
# RUN export https_proxy=$http_proxy
</code></pre>

<p>接下来更新系统内核：</p>

<pre><code class="language-dockerfile">RUN apt-get update
</code></pre>

<p>上面一些步骤都是为了接下来安装<code>Node.js</code>做的必要操作，做完这些之后方可继续下一步。</p>

<p>接下来继续安装一些需要用到的包：</p>

<pre><code class="language-dockerfile"># 更新系统并且安装需要的包
RUN apt-get install -y -q --no-install-recommends \
    apt-transport-https \
    build-essential \
    ca-certificates \
    curl \
    g++ \
    gcc \
    git \
    make \
    sudo \
    wget \
    vim \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; apt-get -y autoclean
</code></pre>

<p>正式开始安装<code>Node.js</code>，我们选择安装<code>7.X</code>版本。</p>

<p>我们选择官方的<a href="https://github.com/nodesource/distributions">Binary Distributions</a>提供的bash文件来进行安装，这样可以省下来很多不必要的操作：</p>

<pre><code class="language-dockerfile"># 可以通过 echo 来输出当前信息
RUN echo '正在安装 nodejs'

ENV NODE_VERSION=7

RUN curl -o- https://deb.nodesource.com/setup_$NODE_VERSION.x | bash -       

RUN sudo apt-get install -y nodejs
</code></pre>

<p>安装好了依赖和主程序，我们接下来需要配置我们的容器工作目录了，也就是<code>WORKDIR</code></p>

<pre><code class="language-dockerfile"># 这里我们先简单指定 /home/hello 为我们的工作目录
ENV WORK_DIR=/home/hello
RUN mkdir -p $WORK_DIR
WORKDIR $WORK_DIR
</code></pre>

<p>然后接下来我们需要把<code>server.js</code>拷贝到容器当中，如果是从GitHub上的例子，直接可以<code>git clone xxx</code>:</p>

<pre><code class="language-dockerfile"># 复制 server.js
COPY ./server.js $WORK_DIR/server.js
</code></pre>

<p>在启动服务器之前， 我们可以选择安装<code>pm2</code>来管理我们的node程序：</p>

<pre><code class="language-dockerfile"># 国内环境可以带上 registry
RUN sudo npm install pm2 -g -d --registry https://registry.npm.taobao.org
</code></pre>

<p>最后直接启动我们的服务，这里请注意，Docker不支持以<code>daemon</code>方式启动的任何服务:</p>

<pre><code class="language-dockerfile"># 启动服务
# RUN unset http_proxy
# RUN unset https_proxy
CMD [&quot;pm2&quot;,&quot;start&quot;,&quot;server.js&quot;]
EXPOSE 3000
</code></pre>

<p>然后执行shell script：</p>

<pre><code class="language-shell">docker build - &lt; Dockerfile
</code></pre>

<p>下面附上完整的Dockerfile:</p>

<pre><code class="language-dockerfile"># Docker file 文件头
FROM ubuntu:16.04
MAINTAINER Nomand &lt;iamnomand@gmail.com&gt;
# 非必须操作
RUN locale-gen en_US.UTF-8
ENV LANG       en_US.UTF-8
ENV LC_ALL     en_US.UTF-8
# 设置 Ubuntu 镜像源地址
RUN sed -i 's/http:\/\/archive\.ubuntu\.com\/ubuntu\//http:\/\/mirrors\.aliyun\.com\/ubuntu\//g' /etc/apt/sources.list

# RUN export http_proxy=xxxxx
# RUN export https_proxy=$http_proxy

# 更新系统并且安装需要的包
RUN apt-get install -y -q --no-install-recommends \
    apt-transport-https \
    build-essential \
    ca-certificates \
    curl \
    g++ \
    gcc \
    git \
    make \
    sudo \
    wget \
    vim \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; apt-get -y autoclean
# 可以通过 echo 来输出当前信息
RUN echo '正在安装 nodejs'
ENV NODE_VERSION=7
RUN curl -o- https://deb.nodesource.com/setup_$NODE_VERSION.x | bash -       
RUN sudo apt-get install -y nodejs
# 这里我们先简单指定 /home/hello 为我们的工作目录
ENV WORK_DIR=/home/hello
RUN mkdir -p $WORK_DIR
WORKDIR $WORK_DIR
# 复制 server.js
COPY ./server.js $WORK_DIR/server.js
# 国内环境可以带上 registry
RUN sudo npm install pm2 -g -d --registry https://registry.npm.taobao.org
# 启动服务
# RUN unset http_proxy
# RUN unset https_proxy
CMD [&quot;pm2&quot;,&quot;start&quot;,&quot;server.js&quot;]
EXPOSE 3000
</code></pre>

<h3 id="docker-compose">Docker-compose</h3>

<p><code>Docker-compose</code>是一个非常有用的官方项目，它的作用是：<strong>负责快速在集群中部署分布式应用</strong></p>

<p>我们知道使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>

<p>它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>

<p>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理</p>

<h4 id="安装-docker-compose">安装 Docker-compose</h4>

<p>在Mac OSX 系统上安装完Docker以后默认自带了Compose，在Linux系统上需要手动安装：</p>

<pre><code class="language-shell">sudo curl -o /usr/local/bin/docker-compose -L &quot;https://github.com/docker/compose/releases/download/1.11.2/docker-compose-$(uname -s)-$(uname -m)&quot;
sudo chmod +x /usr/local/bin/docker-compose
</code></pre>

<blockquote>
<p>安装的过程当中有可能会安装所需的其他依赖，比如Python</p>
</blockquote>

<h4 id="编写yml">编写yml</h4>

<p>安装完后，我们就可以来以上面的简单的Node.js应用为例，去编写<code>docker-compose.yml</code>，更方面的编排我们的Docker应用了。</p>

<p>首先在原来的目录下面新建一个命名为<code>docker-compose.yml</code>的文件。</p>

<p>开始编写之前，有两个关于<code>docker-compose</code>的术语需要了解：</p>

<ul>
<li>service：一个应用容器，实际上可以运行多个相同镜像的实例。</li>
<li>project：由一组关联的应用容器组成的一个完整业务单元。</li>
</ul>

<p>刚开始的<code>docker-compose</code>像下面这样：</p>

<pre><code class="language-yaml">version: '2'
</code></pre>

<p>我们在这里指定compose file 的版本为2，来告诉解析器如何解析。</p>

<blockquote>
<p>版本这里不深入，对应的版本信息可以在这里找到：<a href="https://docs.docker.com/compose/compose-file/compose-versioning/">版本信息</a></p>
</blockquote>

<p>接下来就要开始配置我们的<code>services</code>：</p>

<pre><code class="language-yaml">services:
  workspace:
    build:
      context: .
    container_name: docker_work_space
    ports:
         - &quot;3000:3000&quot;
    tty: true
</code></pre>

<p>然后执行下面命令就可以跑起我们第一个 docker 集群了。</p>

<pre><code class="language-shell">docker-compose up --build
</code></pre>

    </section>
    <nav class="no-print post-nav">
        
        <a class="prev-post" href="https://hasaki.xyz/blog/2016-04-03-%E5%88%A9%E7%94%A8-shadowsocksr-%E5%92%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E7%BF%BB%E5%A2%99/">
            <img class="icon-text" src="/img/prev.svg"/>利用 Shadowsocksr 和云主机翻墙</a>
        
        
        <a class="next-post" href="https://hasaki.xyz/blog/2016-09-03-koa%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%A7%A3%E8%AF%BB/">koa 源码简单解读<img class="icon-text" src="/img/next.svg"/>
        </a>
        
    </nav>
</article>



<div id="disqus_thread" class="no-print"></div>
<script type="text/javascript">
    'use strict';
    (function () {
        if ('localhost' != window.location.hostname) {
            var a = document.querySelector('#disqus_thread');
            new IntersectionObserver(function (b) {
                b.forEach(function (d) {
                    if (0 < d.intersectionRatio && !a.classList.contains('active')) {
                        var e = document.createElement('script');
                        e.type = 'text/javascript', e.async = !0;
                        e.src = '//' + 'toms-blog-1' + '.disqus.com/embed.js', (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(e), a.classList.add('active')
                    }
                })
            }, {rootMargin: '0px', threshold: 1}).observe(a)
        }
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>


<style rel="catalog">
    #catalog {
        position: fixed;
        left: 3vw;
        top: 8vh;
    }

    .cl-wrapper {
        position: relative;
    }

    .cl-wrapper ul, .cl-wrapper li {
        margin: 0;
        -moz-padding-start: 12px;
        -webkit-padding-start: 12px;
        list-style: none;
    }

    .cl-wrapper li > .cl-link.cl-link-active {
        color: #ff8181;
        transition: .5s;
    }

    .cl-wrapper li > .cl-transform.cl-link-active {
        transform: translate(3px);
    }

    .cl-wrapper .cl-link {
        cursor: pointer;
        color: rgba(52, 73, 94, 0.5);
        font-size: 13px;
        transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
    }

    .cl-wrapper .cl-marker {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
    }

    .cl-wrapper .cl-marker path {
        transition: all 0.3s ease;
    }
</style>
<main id="catalog"></main>
<script rel="catalog">
    void function () {
        
        if (window.innerWidth < 1024 || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
            return
        }

        const Catalog = (function () {
            return function (opts) {
                let defaultOpts = {
                    linkClass: 'cl-link',                             
                    linkActiveClass: 'cl-link-active',                
                    datasetName: 'data-cata-target',                  
                    selector: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],   
                    scrollWrapper: null,                              
                    activeHook: null,                                 
                    topMargin: 0,
                    bottomMargin: 0,
                    cool: true                                        
                }

                const Opt = Object.assign({}, defaultOpts, opts)

                const $content = document.getElementById(Opt.contentEl)                          
                const $scroll_wrap = window   
                const $catalog = document.getElementById(Opt.catalogEl)                          

                let allCatalogs = $content.querySelectorAll(Opt.selector.join())
                let tree = getCatalogsTree(allCatalogs)

                try {
                    $catalog.innerHTML = `<div class='cl-wrapper'>${generateHtmlTree(tree, {id: -1})}<svg class="cl-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
            <path stroke="#ff8181" stroke-width="3" fill="transparent" stroke-dasharray="0, 0, 0, 1000" stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)" />
            </svg></div>`
                } catch (e) {
                    console.error('error in progress-catalog', e)
                }


                const tocPath = $catalog.querySelector('.cl-marker path')
                let tocItems, pathLength    

                
                window.addEventListener('resize', drawPath)
                $catalog.addEventListener('click', clickHandler)
                Opt.cool && $scroll_wrap.addEventListener('scroll', coolScrollHandler)
                Opt.cool || $scroll_wrap.addEventListener('scroll', simpleScrollHandler)

                setTimeout(drawPath)          

                

                function drawPath() {
                    tocItems = [...$catalog.querySelectorAll('li')]
                    tocItems = tocItems.map(function (liDom) {
                        const anchor = liDom.querySelector(`.${Opt.linkClass}`)
                        const target = document.getElementById(anchor.getAttribute('data-cata-target'))

                        return {
                            listItem: liDom,
                            anchor: anchor,
                            target: target
                        }
                    })
                    tocItems = tocItems.filter(item => !!item.target)

                    const path = []
                    let pathIndent

                    tocItems && tocItems.forEach(function (item, idx) {
                        const {offsetLeft, offsetTop, offsetHeight} = item.anchor,
                            x = Opt.cool ? offsetLeft - 5 : offsetLeft,
                            y = offsetTop,
                            height = offsetHeight

                        if (idx === 0) {
                            path.push('M', x, y, 'L', x, y + height)
                            item.pathStart = 0
                        }
                        else {
                            if (pathIndent !== x) path.push('L', pathIndent, y)     
                            path.push('L', x, y)
                            tocPath.setAttribute('d', path.join(' '))
                            item.pathStart = tocPath.getTotalLength() || 0
                            path.push('L', x, y + height)
                        }
                        pathIndent = x
                        tocPath.setAttribute('d', path.join(' '))
                        item.pathEnd = tocPath.getTotalLength()
                    })
                    pathLength = tocPath.getTotalLength()
                    coolScrollHandler()
                }

                

                function coolScrollHandler() {
                    const wrapHeight = document.documentElement.offsetHeight
                    let pathStart = pathLength,
                        pathEnd = 0,
                        visibleItems = 0
                    tocItems.forEach(function (liItem) {
                        const {bottom, top} = liItem.target.getBoundingClientRect(),
                            firstChild = liItem.listItem.firstChild
                        if (bottom > Opt.topMargin && top < wrapHeight - Opt.bottomMargin) {
                            firstChild.classList.remove(Opt.linkActiveClass)
                            Opt.cool && firstChild.classList.remove('cl-transform')
                        } else {
                            pathStart = Math.min(liItem.pathStart, pathStart)
                            pathEnd = Math.max(liItem.pathEnd, pathEnd)
                            visibleItems += 1
                            firstChild.classList.add(Opt.linkActiveClass)
                            Opt.cool && firstChild.classList.add('cl-transform')
                        }
                    })
                    if (visibleItems > 0 && pathStart < pathEnd && Opt.cool) {
                        tocPath.setAttribute('stroke-dashoffset', '1')
                        tocPath.setAttribute('stroke-dasharray', `1, ${pathStart}, ${pathEnd - pathStart}, ${pathLength}`)
                        tocPath.setAttribute('opacity', '1')
                    }
                    else {
                        tocPath.setAttribute('opacity', '0')
                    }
                }

                

                function simpleScrollHandler(el) {
                    let scrollToEl = null
                    for (let i = allCatalogs.length - 1; i >= 0; i--) {
                        if (allCatalogs[i].offsetTop <= $scroll_wrap.scrollTop) {
                            scrollToEl = allCatalogs[i]
                            break
                        }
                    }
                    if (scrollToEl) setActiveItem(scrollToEl.id)
                    else setActiveItem(null)            
                }

                

                function clickHandler({target}) {
                    const datasetId = target.getAttribute(Opt.datasetName)
                    target.classList.contains(Opt.linkClass) &&
                    document.getElementById(datasetId)
                        .scrollIntoView({behavior: "smooth", block: "start"})
                }

                

                function getCatalogsTree(catalogs) {
                    let title, tagName, tree = [], treeItem = {}, parentItem = {id: -1}, lastTreeItem = null, id

                    for (let i = 0; i < catalogs.length; i++) {
                        title = catalogs[i].innerText || catalogs[i].textContent
                        tagName = catalogs[i].tagName
                        id = 'heading-' + i
                        catalogs[i].id = id
                        treeItem = {
                            name: title,
                            tagName: tagName,
                            id: id,
                            level: +getLevel(tagName),
                            parent: parentItem
                        }
                        if (lastTreeItem) {
                            if (getLevel(treeItem.tagName) > getLevel(lastTreeItem.tagName)) {
                                treeItem.parent = lastTreeItem
                            } else {
                                treeItem.parent = findParent(treeItem, lastTreeItem)
                            }
                        }
                        lastTreeItem = treeItem
                        tree.push(treeItem)
                    }
                    return tree
                }

                

                function findParent(currTreeItem, lastTreeItem) {
                    let lastTreeParent = lastTreeItem.parent
                    while (lastTreeParent && (getLevel(currTreeItem.tagName) <= getLevel(lastTreeParent.tagName))) {
                        lastTreeParent = lastTreeParent.parent
                    }
                    return lastTreeParent || {id: -1}
                }

                

                function getLevel(tagName) {
                    return tagName ? tagName.slice(1) : 0
                }

                

                function generateHtmlTree(tree, _parent) {
                    let ul, hasChild = false
                    if (tree) {
                        ul = `<ul>`
                        for (let i = 0; i < tree.length; i++) {
                            if (isEqual(tree[i].parent, _parent)) {
                                hasChild = true
                                ul += `<li><div class='${ Opt.linkClass } cl-level-${ tree[i].level }' ${Opt.datasetName}='${ tree[i].id }'>${tree[i].name}</div>`
                                ul += generateHtmlTree(tree, tree[i])
                                ul += '</li>'
                            }
                        }
                        ul += `</ul>`
                    }
                    return hasChild ? ul : ''
                }

                /**
                 * 判断是否是相同节点
                 */
                function isEqual(node, node2) {
                    return node && node2 && typeof node === 'object' && typeof node2 === 'object' && node.id === node2.id
                }

                /**
                 *  设置选中的项
                 */
                function setActiveItem(id) {
                    let catas = [...$catalog.querySelectorAll(`[${Opt.datasetName}]`)]

                    catas.forEach(T => {
                        if (T.getAttribute(Opt.datasetName) === id) {
                            typeof Opt.activeHook === 'function' &&
                            !T.classList.contains(Opt.linkActiveClass) &&
                            Opt.activeHook.call(this, T)                    // 执行active钩子
                            T.classList.add(Opt.linkActiveClass)
                        } else {
                            T.classList.remove(Opt.linkActiveClass)
                        }
                    })
                }
            }
        })();
        window.addEventListener('DOMContentLoaded', _ => new Catalog({
            contentEl: 'markdown',
            catalogEl: 'catalog'
        }))
    }();
</script>
			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				
<a href="mailto:iamnomand@gmail.com"><img class="icon-social" src="/img/email.svg" alt="Email Me!"/></a>


<a href="https://github.com/v-tom/"><img class="icon-social" src="/img/github.svg" alt="Github"/></a>


<a href="https://twitter.com/iamnomand"><img class="icon-social" src="/img/twitter.svg" alt="Twitter"/></a>

<a href="https://hasaki.xyz/index.xml" target="_blank"><img class="icon-social" src="/img/feed.svg" alt="Feed"></a>

				<p>
					
					
					Early 2016 ~ 2019 &copy; TOM's Zone
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
		<script>hljs.initHighlightingOnLoad();</script>
		
	</body>
</html>

