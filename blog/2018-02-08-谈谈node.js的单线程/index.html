<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="Keywords" content="">
    <meta name="full-screen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#006cb4">
    <meta name="apple-mobile-web-app-title" content="TOM&#39;s zone">
    <meta name="description" content="TOM&#39;s zone">
    <link rel="dns-prefetch" href="https://t-tom.me">
    <link rel="preconnect" href="https://t-tom.me">
    <link rel="manifest" href="/sw/manifest.json"/>
    <meta name="generator" content="Hugo 0.37" />
    <title>谈谈 Node.js 的单线程 - TOM&#39;s zone</title>

    <meta name="description" content="前言 从Node.js进入人们的视野时，我们所知道的它就由这些关键字组成 事件驱动、非阻塞I/O、高效、轻量，它在官网中也是这么描述自己的。
 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.
 Node.js 结构 我们可以看到，Node.js 的结构大致分为三个层次：
 Node.js 标准库，这部分是由 Javascript 编写的，即我们使用过程中直接能调用的 API。在源码中的 lib 目录下可以看到。 Node bindings，这一层是 Javascript 与底层 C/C&#43;&#43; 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。实现在 node.cc 这一层是支撑 Node.js 运行的关键，由 C/C&#43;&#43; 实现。  V8：Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript 的关键，它为 Javascript 提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。 Libuv：它为 Node.">


    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">

    
    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/ocean.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/javascript.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/python.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/css.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/swift.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/objectivec.min.js"></script>
    
    
    <link rel="stylesheet" href="/css/bundle.min.css"/>
    <style>
	a { color: #ff8181; }
	blockquote {
		border-left-color: #ff8181;
		border-right-color: #ff8181; }
	.bar a:hover {
		color: #ff8181;
		text-decoration: none; }
	.sep {
		margin-top: 2rem;
		margin-bottom: 1rem;
		margin-left:0;
		width: 24rem;
		border-top: 2px solid #ff8181; }
    .bar li.active a{
        color:#ff8181;
    }
</style>

</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li>
		
		<li class="active"><a href="/blog/">Blog</a></li>
		<li class=""><a href="/life/">Life</a></li></ul>
</nav>

	</div>
</header>
<main class="container">

<article>
    <header><hgroup id="brand">
	<h1>谈谈 Node.js 的单线程</h1>
	<h5>
		
		<time datetime="2018-02-08 14:22:25 &#43;0800 CST">Feb 08, 2018</time>
		<span class="no-print">
			-
				
				<a href="/tags/node.js">Node.js</a>
				
				<a href="/tags/backend">BackEnd</a>
				
				<a href="/tags/cluster">Cluster</a>
				<span>
	</h5>
	
</hgroup>
<hr class="sep" />
</header>
    <section id="markdown">
        

<h3 id="前言">前言</h3>

<p>从Node.js进入人们的视野时，我们所知道的它就由这些关键字组成 <strong>事件驱动、非阻塞I/O、高效、轻量</strong>，它在官网中也是这么描述自己的。</p>

<blockquote>
<p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an <strong>event-driven</strong>, <strong>non-blocking I/O model</strong> that makes it <strong>lightweight</strong> and <strong>efficient</strong>.</p>
</blockquote>

<h3 id="node-js-结构">Node.js 结构</h3>

<p><img src="./Node-struct.jpeg" alt="Node-struct" /></p>

<p>我们可以看到，Node.js 的结构大致分为三个层次：</p>

<ul>
<li>Node.js 标准库，这部分是由 Javascript 编写的，即我们使用过程中直接能调用的 API。在源码中的 <a href="https://github.com/nodejs/node/tree/master/lib">lib</a> 目录下可以看到。</li>
<li>Node bindings，这一层是 Javascript 与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。实现在 <a href="https://github.com/nodejs/node/blob/master/src/node.cc">node.cc</a></li>
<li>这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。

<ul>
<li>V8：Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript 的关键，它为 Javascript 提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。</li>
<li>Libuv：它为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力，是 Node.js 如此强大的关键。</li>
<li>C-ares：提供了异步处理 DNS 相关的能力。</li>
<li>http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。</li>
</ul></li>
</ul>

<p>所以，由此可以看出 <code>Node.js</code> 并不是一门语言，只是一个平台。</p>

<h3 id="什么是线程">什么是线程</h3>

<p>我们来先说说什么是进程、线程。</p>

<h4 id="上下文切换技术">上下文切换技术</h4>

<p>当我们说“上下文”的时候，指的是程序在执行中的一个状态。通常我们会用调用栈来表示这个状态——栈记载了每个调用层级执行到哪里，还有执行时的环境情况等所有有关的信息。</p>

<blockquote>
<p>由于单核 CPU 无法被平行使用(多个程序同时运行在一个CPU上)。为了创造*共享CPU*的假象，设计人员就搞出了一个叫做时间片的概念，将时间分割成为连续的时间片段，让多个程序在这些连续的时间片中交叉获得CPU使用权限，这样看起来就好像多个程序在同时运行一样。后来，给任务分配时间片并进行调度的调度器成为了操作系统的核心组件;</p>

<p><strong>摘自《深入理解计算机操作系统》</strong></p>
</blockquote>

<p>当我们说“上下文切换”的时候，表达的是一种从一个上下文切换到另一个上下文执行的技术。</p>

<h4 id="进程">进程</h4>

<p>进程是一种古老而典型的上下文系统，每个进程有独立的地址空间，资源句柄，他们互相之间不发生干扰。</p>

<p>每个进程在内核中会有一个数据结构进行描述，我们称其为进程描述符。这些描述符包含了系统管理进程所需的信息，并且放在一个叫做任务队列的队列里面。</p>

<p>很显然，当新建进程时，我们需要分配新的进程描述符，并且分配新的地址空间(和父地址空间的映射保持一致，但是两者同时进入COW状态)。这些过程需要一定的开销。</p>

<p>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>

<p><strong>进程的出现是为了更好的利用CPU资源使到并发成为可能</strong></p>

<h4 id="线程">线程</h4>

<blockquote>
<p>线程是一种轻量进程，实际上在linux内核中，两者几乎没有差别，除了一点——线程并不产生新的地址空间和资源描述符表，而是复用父进程的。</p>
</blockquote>

<p><strong>线程的出现是为了降低上下文切换的消耗，提高系统的并发性，并突破一个进程只能干一样事的缺陷，使到进程内并发成为可能</strong></p>

<p>进程和线程的关系：</p>

<ul>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</li>
<li>线程在进程内部，处理并发的逻辑，拥有独立的栈，却共享线程的资源</li>
<li>处理机分给线程，即真正在处理机上运行的是线程</li>
<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步</li>
</ul>

<p>由于线程是操作系统直接支持的执行单元，很多高级语言都基本上内置了对 <code>thread</code> 的操作。</p>

<h3 id="服务端历史">服务端历史</h3>

<p>传统网络服务模型总体来说分为：（没有先后顺序之分</p>

<ul>
<li>同步模型（单线程</li>
<li>进程模型（多进程</li>
<li>线程模型（多线程</li>
<li>协程模型（超线程</li>
<li>CPS模型（个人能力有限，针对该模型没有找到具体的描述和内容，所以就不详细介绍</li>
<li>非阻塞式I/O</li>
</ul>

<h4 id="同步模型">同步模型</h4>

<p>这类服务器是最早出现的，其执行模型是同步的（<code>基于read或select I/O模型</code>），编写自然，每个上下文可以当作其他上下文不存在一样的操作，每次读取数据可以当作必然能读取到。</p>

<p>它的服务模式是一次只能处理一个请求，其他的请求都需要按照顺序依次等待接受处理。</p>

<p>任何一个略慢的任务都会导致后续代码被阻塞，所以，它的处理能力特别的低下。</p>

<h4 id="进程模型">进程模型</h4>

<p>进程模型自然的隔离了连接。即使程序复杂且易崩溃，也只影响一个连接而不是在整个系统，当然服务器的进程数量是有上限的。</p>

<pre><code>cat /proc/sys/kernel/pid_max
// Ubuntu 16.04 上结果为 32768
</code></pre>

<p>进程是一个比较重的概念，拥有自己的堆和栈，占用内存较多，一台服务器能运行的进程数量有上限，大约也就在几千或者几万左右，频繁的生成和释放开销很大，需要考虑复用，相同的状态会在内存中存在很多份，造成浪费，数据共享也是一个问题。</p>

<pre><code class="language-python">from multiprocessing import Pool


def fib(n):
    if n &lt;= 2:
        return 1
    return fib(n - 1) + fib(n - 2)


if __name__ == &quot;__main__&quot;:
    p = Pool(processes=5)
    data = p.map(fib, [35] * 2)
    p.close()
    print(data)

</code></pre>

<blockquote>
<p>早期的 <code>Apache</code> 服务器就是进程模型，以及后面提出的优化 <code>fastCGI</code> 属于进程池。</p>
</blockquote>

<p>在前端 browser 当中可以通过创建 <code>webworkers</code> 来创建额外的进程。</p>

<h4 id="线程模型">线程模型</h4>

<p><strong>线程，是cpu调度的基本单位，是最小的执行单元</strong></p>

<p>线程模型的优点是更轻量，建立和释放速度更快，而且多个上下文间的通讯速度非常快，当然服务器的线程数量也是有上限的。</p>

<p>线程上下文由系统来切换控制，调度是由操作系统负责，线程的睡眠、等待、唤醒的时机是由操作系统控制，开发者无法精确的控制它们。</p>

<p>线程虽然比进程轻量，但也是相对的。<a href="http://www.cnblogs.com/PurpleTide/archive/2010/11/12/1875763.html">有人测试过</a>，每个线程独享的栈的大小是 1M，依然不够高效。除此以外，多线程编程会带来各种麻烦，一个线程出现问题容易将整个系统搞崩溃，也面临锁的问题。</p>

<pre><code class="language-python">import threading
import time

globals_num = 0

lock = threading.RLock()


def Func():
    lock.acquire()  # 获得锁
    global globals_num
    globals_num += 1
    time.sleep(1)
    print(globals_num)
    lock.release()  # 释放锁


for i in range(10):
    t = threading.Thread(target=Func)
    t.start()
</code></pre>

<blockquote>
<p>现在的 <code>java</code> 我理解的就是线程模型，而且是深入内核态的线程。</p>
</blockquote>

<p>早期的 C10K 问题就是讨论如何利用单台服务器支持 10K 并发数。当然随着软硬件性能的提高，目前 C10K 已经不再是问题，我们开始尝试解决 C10M 问题，即单台服务器如何处理百万级的并发。如果不使用进程或者线程，还有两种解决方案，分别是使用协程(coroutine)和非阻塞 I/O。</p>

<p>为了在寄存器当中快速的上下文切换，不牵扯到内核，其实还有一个叫做 <code>协程</code> 的解决方案。</p>

<h4 id="协程模型">协程模型</h4>

<p>历史上先有协程再有的线程。</p>

<blockquote>
<p>实际上线程确实比协程性能更好，协程比较适合 I/O密集型任务。</p>
</blockquote>

<p>协程属于非抢占式任务，也可以叫做<strong>用户态线程</strong></p>

<blockquote>
<p>用户态线程就是程序自己控制状态切换，进程不用陷入内核态，开发者可以按照程序的特性来选择更适合的调度算法，</p>
</blockquote>

<p>协程属于语言级别的调度算法实现，通过在线程中实现调度，避免了陷入内核级别的上下文切换造成的性能损失，协程所能调度的，只有在同一进程中的不同上下文而已。可以看做用户控件下的进程，进而突破了线程在IO上的性能瓶颈。</p>

<p>协程也可以说是一种编程组件，减少 callback 的使用，以看是同步的方式来编程，把这些异步伪装成同步，让写代码的人爽一些。</p>

<blockquote>
<p>在事件驱动的编程里面 callback 可能更加合适。</p>
</blockquote>

<pre><code class="language-python">import asyncio


async def cor1():
    print(&quot;COR1 start&quot;)
    await cor2()
    print(&quot;COR1 end&quot;)


async def cor2():
    print(&quot;COR2&quot;)


loop = asyncio.get_event_loop()
loop.run_until_complete(cor1())
loop.close()

</code></pre>

<blockquote>
<p>协程模型这种技术在 <code>Go</code> 语言中被广泛使用。</p>
</blockquote>

<p>Node 作者视乎 <a href="https://news.ycombinator.com/item?id=1549168">不愿加入 coroutine，</a>理由是一种哲学、信仰的问题。对协程感兴趣可以看一下 <a href="http://fibjs.org/">fib.js</a>，以及 TJ 的 <a href="https://github.com/tj/co">co</a> 语法糖。</p>

<p>ES6 当中已经加入 <code>yield/Generator/GeneratorFunction</code> 来支持协程，不过是半协程（semi-coroutine），而且我觉得 async 应该不单单只是 <code>generator</code> 的升级语法糖。</p>

<h4 id="非阻塞式i-o">非阻塞式I/O</h4>

<p>I/O 的处理方式分为：</p>

<ul>
<li>阻塞式</li>
<li>非阻塞式。</li>
</ul>

<p>对于阻塞 I/O 来说，从发起读请求，到缓冲区就绪，再到用户进程获取数据，这两个步骤都是阻塞的。</p>

<p>非阻塞 I/O 实际上是向内核轮询，缓冲区是否就绪，如果没有则继续执行其他操作。当缓冲区就绪时，讲缓冲区内容拷贝到用户进程，这一步实际上还是阻塞的。</p>

<blockquote>
<p>什么是 I/O ?</p>
</blockquote>

<p>这里所说的 I/O 可以分为:</p>

<ul>
<li>网络 I/O</li>
<li>文件 I/O</li>
<li>磁盘 I/O</li>
<li>&hellip;</li>
</ul>

<p>实际上两者高度类似。 I/O 可以分为两个步骤，首先把文件(网络)中的内容拷贝到缓冲区，这个缓冲区位于操作系统独占的内存区域中。随后再把缓冲区中的内容拷贝到用户程序的内存区域中。</p>

<p>为了让 CPU 的处理能力得到充分利用，减少 I/O 浪费时间，避免陷入内核态，提高性能，内核提供了非阻塞式 I/O，后来演变成异步编程。</p>

<p>Linux 提出了<a href="http://www.cnblogs.com/lizheng19822003/p/5337792.html">3种解决方案</a> 来实现非阻塞式 IO ：</p>

<ul>
<li><code>select</code></li>
<li><code>poll</code></li>
<li><code>epoll</code></li>
</ul>

<p>除此之外其他平台也有对应的实现：</p>

<ul>
<li><code>kqueue</code> FreeBSD</li>
<li><code>Event ports</code> Solaris</li>
</ul>

<p>这些方案有好有坏，其实这些从根本上讲还是算是一种同步，应用程序仍然需要等待 I/O 完全返回。比如 <code>Apache</code> 采用了前者，而 <code>Nginx</code> 和 <code>Node.js</code> 使用了后者，区别在于后者<a href="http://stackoverflow.com/questions/17355593/why-is-epoll-faster-than-select">效率更高</a></p>

<p>当然异步 I/O 是最理想的 I/O 模型，然而可惜的是真正的异步 I/O 并不存在。 Linux 上的 AIO 通过信号和回调来传递数据，但是存在缺陷。现有的 libeio 以及 Windows 上的 IOCP，本质上都是利用线程池与阻塞 I/O 来模拟异步 I/O。</p>

<p>Node 本身有自己的事件模型—— <code>event loop</code>：</p>

<pre><code>   ┌───────────────────────┐
┌─&gt;│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │&lt;─────┤  connections, │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘

</code></pre>

<p>这里不仔细介绍，读者可以线下自行学习。</p>

<h3 id="单线程的-node">单线程的 Node</h3>

<p>从严格意义上来讲， <code>Node.js</code> 本身并不是单线程的。</p>

<p>因为Node自身还有I/O线程存在（网络I/O、磁盘I/O），这些I/O线程是由更底层的 <code>libuv</code> 处理，这些实际上还是多线程，当然这些对于 <code>JavaScript</code> 开发者来说是透明的。</p>

<p>Node 的异步 I/O 并非首创，但是是第一个成功的平台。</p>

<h4 id="libuv">libuv</h4>

<p>Node 的底层关键结构有一个<a href="https://github.com/libuv/libuv">libuv</a> ，在它的介绍当中提到：</p>

<ul>
<li>Full-featured event loop backed by epoll, kqueue, IOCP, event ports.</li>
<li>….</li>
</ul>

<p>一张图来提现它大概的所有功能：</p>

<p><img src="./libuv.png" alt="libuv" /></p>

<p>Node 正是通过它来和<strong>底层操作系统打交道</strong>，来实现：事件驱动、非阻塞I/O、高效。</p>

<p>下面是一张简化的调用流程图(以fs为例)：</p>

<p><img src="./libuv-fs.jpg" alt="libuv fs" /></p>

<blockquote>
<p>在 Linux 当中是通过 AIO(epoll) 实现异步io，Windows 当中则是 IOCP，libuv 作为抽象封装层，使得所有平台差异有这一层完成，并且在 Node 编译期间会判断平台条件选择性编译。</p>
</blockquote>

<p>Node 当中 javascript 的执行线程是单线程，把需要做的 <code>I/O</code> 交给 <code>libuv</code>，并设定好回调。</p>

<p>自己马上返回做别的事情，然后 <code>libuv</code> 有一个事件循环(<code>event loop</code>)的机制。</p>

<p>大致会执行一个相当于 <code>while true</code> 的无限循环，不断的检查各个 <code>watcher</code> 上面是否有需要处理的 <code>pending</code> 状态事件，然后来指定执行事件回调。</p>

<h4 id="存在的优势">存在的优势</h4>

<p>Node.js的单线程具有它的优势：</p>

<ul>
<li>状态单一</li>
<li>不存在竞态，没有锁</li>
<li>不需要线程间同步</li>
<li>减少系统上下文的切换</li>
<li>有效提高单核CPU的使用率</li>
</ul>

<p>但也并非十全十美：</p>

<ul>
<li>单线程是可以被阻塞的</li>
<li>无法充分调用 CPU 的资源</li>
<li>CPU 密集型任务显得无力，需要多进程或者拓展模块来优化</li>
<li>单线程的脆弱性，如果单线程出现未捕获的异常，就会造成这个进程 crash</li>
</ul>

<h4 id="非i-o的异步api">非I/O的异步API</h4>

<p>介绍 Node 的时候，多数情况下都会提到异步 I/O，Node 当中也存在一些与 I/O 无关的异步API：</p>

<ul>
<li><code>setTimeout</code></li>
<li><code>setInterval</code></li>
<li><code>setImmediate</code></li>
<li><code>process.nextTick</code></li>
</ul>

<blockquote>
<p>从上面这些 API 当中也引发出一个常见的问题 macrotask 和 microtask 的区别，其实还是 event loop</p>
</blockquote>

<h4 id="settimeout和setinterval">setTimeout和setInterval</h4>

<p>这两个API和浏览器当中的行为是一致的。它们的实现原理和异步 I/O 比较相似，只是不需要进程池的参与。</p>

<p>调用的时候创建的定时器会被插入到观察者内部的一个红黑树当中。每次一个 Tick 执行的时候，会从红黑树当中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，立即执行回调函数。</p>

<p>问题在于：定时器并非是精准的。尽管 event loop 循环的很快，如果某一次循环占用时间过多，下次循环的时候，或许已经超时很久了。比如一些 CPU 任务占用时间过长。</p>

<h4 id="process-nexttick">process.nextTick</h4>

<p>由于事件循环自身的特点，定时器的精确度不够，好多人采用过这样的方法来实现异步执行一个任务（延迟执行：</p>

<pre><code class="language-javascript">setTimeout(()=&gt;{
    // do something
},0)
</code></pre>

<p>实际上这样写不但浪费性能，而且根据 event loop 顺序，setTimeout 的优先级也不高。实际上 <code>process.nextTick</code> 方法操作较为轻量、高效，功能实现上也较为符合需求。</p>

<p>根据 event loop，<strong>process.nextTick()不在event loop的任何阶段执行，而是在各个阶段切换的中间执行</strong>,即从一个阶段切换到下个阶段前执行。</p>

<h4 id="setimmediate">setImmediate</h4>

<p>这个 <code>setImmediate</code> 方法和 <code>process.nextTick</code> 十分相似，都是回调函数延迟执行，两者的差别是：</p>

<pre><code class="language-javascript">process.nextTick(function () {
  console.log('nextTick')
})

setImmediate(function () {
  console.log('setImmediate')
})

console.log('runtime')
</code></pre>

<p>执行结果是：</p>

<pre><code>runtime
nextTick
setImmediate
</code></pre>

<p>从这里可以看出，<code>process.nextTick</code>中的回调函数优先级高级 <code>setImmediate</code>，这是因为前者属于 <code>idle</code> 阶段，后者属于 <code>check</code> 阶段，每一次事件循环当中，<code>idle</code> 优先级大于 <code>check</code> 阶段。</p>

<h3 id="多进程的-node">多进程的 Node</h3>

<p>如果你运行 Node.js 的机器是像i5，i7这样多核cpu，那么将无法充分利用多核cpu的性能来为Node.js服务。</p>

<p>在C++、C#、python等其他语言都有与之对应的多线程编程，能够充分的利用多核 CPU。</p>

<p>我们可以通过以下方式实现多进程：</p>

<ul>
<li>fork</li>
<li>cluster</li>
<li>第三方库 <code>tagg</code>、<code>tagg2</code>（对v8，libuv进行拓展</li>
</ul>

<h4 id="fork">fork</h4>

<p>说到多进程当然少不了 <a href="http://man7.org/linux/man-pages/man2/fork.2.html">fork</a> ,在 un*x 系统中，fork 函数为用户提供最底层的多进程实现。</p>

<p>多个子进程便是通过在master进程中不断的调用 cluster.fork 方法构造出来:</p>

<p><img src="./fork.png" alt="fork" /></p>

<p>Node 有以下几种创建进程的方式：</p>

<ul>
<li><code>spawn</code> 创建一个子进程来执行命令，结果以 stream 的形式返回</li>
<li><code>exec</code> 创建一个子进程来执行命令，和spawn()不同的是方法参数不同，它可以传入回调函数来获取子进程的状态，结果立即返回</li>
<li><code>execFile</code> 启动一个子进程来执行指定文件。注意，该文件的顶部必须声明 <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">SHEBANG</a>符号(#!)用来指定进程类型。</li>
<li><code>fork</code> 这个和 <code>spawn</code> 类似，不同点在于它创建 Node 的子进程只需要执定要执行的 JavaScript 文件模块即可。</li>
</ul>

<p>对于这些创建进程的方式一般有以下问题：</p>

<blockquote>
<p>1、child_process.fork 与 POSIX 的 fork 有什么区别?</p>
</blockquote>

<p>Node 的 <code>child_process.fork()</code> 在 Unix 上的实现最终调用了 POSIX <a href="http://man7.org/linux/man-pages/man2/fork.2.html">fork(2)</a></p>

<p>而 POSIX 的 fork 需要手动管理子进程的资源释放 (waitpid)</p>

<p><code>child_process.fork</code> 则不用关心这个问题, Node.js 会自动释放, 并且可以在 option 中选择父进程死后是否允许子进程存活.</p>

<blockquote>
<p>2、父进程或子进程的死亡是否会影响对方? 什么是孤儿进程?</p>
</blockquote>

<p>子进程死亡不会影响父进程, 不过子进程死亡时（线程组的最后一个线程，通常是“领头”线程死亡时），会向它的父进程发送死亡信号。</p>

<p>父进程死亡, 一般情况下子进程也会随之死亡, 但如果此时子进程处于可运行态、僵死状态等等的话, 子进程将被 [init 进程](<a href="https://zh.wikipedia.org/wiki/Init收养，从而成为孤儿进程。">https://zh.wikipedia.org/wiki/Init收养，从而成为孤儿进程。</a></p>

<p>另外, 子进程死亡的时候（处于“终止状态”），父进程没有及时调用 <code>wait()</code> 或 <code>waitpid()</code> 来返回死亡进程的相关信息，此时子进程还有一个 <code>PCB</code> 残留在进程表中，被称作僵尸进程。</p>

<blockquote>
<p>3、有兴趣的话可以看一下守护进程（daemon）以及实现。</p>
</blockquote>

<p>在这里值得一提的是：<code>fork</code> 出来的应用程序如果都监听相同的端口会出现常见的 <code>EADDRINNUSE</code> 错误，早期的解决办法是 <code>进程间发送句柄，共享 fd</code> 。</p>

<h4 id="cluster">Cluster</h4>

<p>官方的介绍的作用是，通过 cluster 模块可以帮助应用程序在多核的系统上轻松创建共享服务器端口的子进程。</p>

<blockquote>
<p>A single instance of Node.js runs in a single thread. To take advantage of multi-core systems, the user will sometimes want to launch a cluster of Node.js processes to handle the load.</p>

<p>The cluster module allows easy creation of child processes that all share server ports.</p>
</blockquote>

<p>cluster 模块对 child_process 模块提供了一层封装，简单的一个 fork，不需要开发者修改任何的应用代码便能够实现多进程部署。</p>

<p>cluster 通过加入 <code>cluster.isMaster</code> 这个标识, 来区分父进程以及子进程，父进程起到了协调,调度的作用,他把客户端过来的请求分发给子进程.</p>

<p>下面是采用 <code>cluster</code> 来创建一个简单的集群：</p>

<pre><code class="language-javascript">const cluster = require('cluster');            // | | 
const http = require('http');                  // | | 
const numCPUs = require('os').cpus().length;   // | |    都执行了
                                               // | | 
if (cluster.isMaster) {                        // |-|-----------------
  // Fork workers.                             //   | 
  for (var i = 0; i &lt; numCPUs; i++) {          //   | 
    cluster.fork();                            //   | 
  }                                            //   | 仅父进程执行 (a.js)
  cluster.on('exit', (worker) =&gt; {             //   | 
    console.log(`${worker.process.pid} died`); //   | 
  });                                          //   |
} else {                                       // |-------------------
  // Workers can share any TCP connection      // | 
  // In this case it is an HTTP server         // | 
  http.createServer((req, res) =&gt; {            // | 
    res.writeHead(200);                        // |   仅子进程执行 (b.js)
    res.end('hello world\n');                  // | 
  }).listen(8000);                             // | 
}                                              // |-------------------
                                               // | |
console.log('hello');                          // | |    都执行了
</code></pre>

<p>真实的工作进程是通过使用 <code>child_process.fork</code> 方法实现并派送的,他们可以通过 IPC （Inter-Process Communication）进行进程间的通信。</p>

<blockquote>
<p>Node.js 中的 IPC 通信是由 <code>libuv</code> 通过管道技术实现的, 在 windows 下由命名管道（named pipe）实现也就是上表中的最后第二个, *nix 系统则采用 UDS (Unix Domain Socket) 实现。</p>
</blockquote>

<p>IPC的创建和实现示意图：</p>

<p><img src="./ipc.jpeg" alt="ipc" /></p>

<p>父进程在实际创建子进程之前，会先创建IPC通道并监听它，然后才真正创建出子进程。子进程在启动的过程中会去链接这个已存在的IPC通道，从而完成了父子进程之间的连接。</p>

<p><img src="./ipc-parent-to-child.jpeg" alt="ipc-parent-to-child" /></p>

<p>通过 <code>fork()</code> 复制的进程都是一个<code>独立</code>的进程，这个进程中有着独立而全新的V8实例。</p>

<h3 id="负载均衡">负载均衡</h3>

<p>为了保证多个进程工作量公平，Node 必然会遇到负载均衡的问题。</p>

<p>首先，Node 默认提供的机制采用操作系统的抢占式策略：一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务，一般而言这个对大家都是公平的。但是这在高并发、大客户端链接的时候会产生<a href="https://en.wikipedia.org/wiki/Thundering_herd_problem">惊群问题</a>：</p>

<p><img src="./thundering-herd.png" alt="Thundering herd problem" /></p>

<blockquote>
<p>多线程/多进程等待同一个 socket 事件，当这个事件发生时，这些线程/进程被同时唤醒，就是惊群现象。</p>
</blockquote>

<p>感兴趣的话可以看一下 <code>C10K problem</code> 以及 <code>c10M problem</code></p>

<p>这种模式有着明显的问题：</p>

<ul>
<li>多个进程之间会竞争，产生惊群现象，效率比较低，许多进程被内核重新调度唤醒，同时去响应这一个事件，只有一个进程能处理事件成功，其他的进程在处理该事件失败后重新休眠。</li>
<li>由于无法控制一个新的连接由哪个进程来处理，Node 的繁忙分为 CPU 和 I/O 繁忙，影响抢占的是 CPU 的繁忙度，必然导致各 worker 进程之间的负载非常不均衡。</li>
</ul>

<p>其次，后来 Node 提供了新的策略使得负载均衡更合理，这种策略叫做 <code>Round-Robin</code> ，又叫轮叫调度。</p>

<blockquote>
<p>Windows 上是采用 句柄共享 ，*nix 是 Round-Robin</p>
</blockquote>

<p>如何传递以及传递给哪个 worker 完全是可控的，参照下图的 <code>dispatch</code></p>

<p><img src="./Round-Robin.png" alt="Round-Robin" /></p>

<p>在 Cluster 模块当中启用的方式如下：</p>

<pre><code class="language-bash">// 启用 Round-Robin
cluster.schedulingPolicy = cluster.SCHED_RR

// 不启用 Round-Robin
cluster.schedulingPolicy = cluster.SCHED_NONE
</code></pre>

<p>或者在环境变量当中这种 <code>NODE_CLUSTER_SCHED_POLICY</code>：</p>

<pre><code class="language-bash"># 启用 Round-Robin
export NODE_CLUSTER_SCHED_POLICY=rr

# 不启用 Round-Robin
export NODE_CLUSTER_SCHED_POLICY=none
</code></pre>

<p>当然负载均衡策略也可以通过代理服务器 nginx 配置 <code>upstream</code> 实现：</p>

<pre><code class="language-nginx">http { 
  upstream cluster { 
      server 127.0.0.1:3000; 
      server 127.0.0.1:3001; 
      server 127.0.0.1:3002; 
      server 127.0.0.1:3003; 
  } 
  server { 
       listen 80; 
       server_name www.domain.com; 
       location / { 
            proxy_pass http://cluster;
       } 
  }
}
</code></pre>

<p>可以简单理解为：</p>

<p><img src="./nginx-upstream.jpg" alt="nginx-upstream.jpg" /></p>

<h3 id="进程守护">进程守护</h3>

<p>master 进程除了负责接收新的连接，分发给各 <code>worker</code> 进程处理之外，还得守护每一个 worker 进程，保证整个应用的稳定性，一旦某个 <code>worker</code> 异常退出就需要 <code>fork</code> 一个新的进程上去。</p>

<p>我们可以给 <code>process</code> 对象 添加 <code>uncaughtException</code> 事件绑定来避免异常发生时直接退出，可以在回调当中停止任务，告诉 <code>master</code> 进程该进程已经 <code>died</code>：</p>

<pre><code class="language-javascript">process.on('uncaughtException', err =&gt; {

  // 记录日志
  logger.error(err)

  // 发送自杀信号
  process.send({ act: 'suicide' })

  // 停止接收新的连接
  worker.close(function () {
    process.exit(1)
  })

  // 5秒后自动退出
  setTimeout(function () {
    process.exit(1)
  }, 5e3)

})
</code></pre>

<p>在 <code>cluster</code> 模块当中我们可以这样进行处理：</p>

<pre><code class="language-javascript">cluster.on('exit', function(){
    clsuter.fork();
});

cluster.on('disconnect', function(){
    clsuter.fork();
});
</code></pre>

<p>整个应用的稳定性就落在了 master 身上，要百分百保证它的健壮性。</p>

<h3 id="个人看法">个人看法</h3>

<p>Node.js 非常适合为 I/O 密集型应用提供服务。但这种方式的缺陷就是不擅长处理 CPU 密集型任务。</p>

<p>对于高并发的长连接，事件驱动模型比线程轻量得多，Node 虽然隐藏了 <code>event loop</code> 和 <code>async io</code> 的细节，但是它的特点是易于上手，非常容易编写，开发效率高，同时写出来性能还不差。</p>

<p>问题在于，到了一定的复杂程度之后，代码维护、提高性能瓶颈就比较困难了，开发者需要深入了解它大部分甚至所有隐藏的细节才有保障构建复杂、大型的应用。</p>

<h3 id="reference">Reference</h3>

<ul>
<li><a href="https://segmentfault.com/a/1190000001813992">Python 中的进程、线程、协程、同步、异步、回调</a></li>
<li><a href="http://blog.shell909090.org/blog/archives/2703/">上下文切换技术</a></li>
<li><a href="https://en.wikipedia.org/wiki/C10k_problem">c10k</a></li>
<li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/"><code>event loop</code> 官方解释</a></li>
<li><a href="http://www.cnblogs.com/aylin/p/5601969.html">Python 当中的多线程，多进程，协程</a></li>
<li><a href="https://blog.csdn.net/shenlei19911210/article/details/61194617">协程(Coroutine)-ES中关于Generator/async/await的学习思考</a></li>
<li><a href="https://www.zhihu.com/question/32218874/answer/56255707">为什么协程是趋势</a></li>
<li><a href="http://shiningray.cn/node-js-coroutine.html">Node 的协程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27069865">Node.js cluster 踩坑小结</a></li>
<li><a href="http://www.cnblogs.com/lizheng19822003/p/5337792.html">理解事件驱动select,poll,epoll三种模型</a></li>
<li><a href="http://jolestar.com/parallel-programming-model-thread-goroutine-actor/">并发之痛 Thread，Goroutine，Actor</a></li>
<li><a href="https://github.com/DavidCai1993/my-blog/issues/31">通过源码解析 Node.js 中进程间通信中的 socket 句柄传递</a></li>
<li><a href="https://blog.csdn.net/gatieme/article/details/51058797">linux下进程的进程最大数、最大线程数、进程打开的文件数和ulimit命令修改硬件资源限制</a></li>
<li><a href="https://blog.csdn.net/great3779/article/details/5930190">一个进程(Process)最多可以生成多少个线程(Thread)</a></li>
<li><a href="https://segmentfault.com/q/1010000000190024">既然nodejs是单线程的，那么它怎么处理并发，难道要排队么</a></li>
<li><a href="https://github.com/hustxiaoc/node.js/issues/11">当我们谈论 cluster 时我们在谈论什么</a></li>
</ul>

    </section>
    <nav class="no-print post-nav">
        
        <a class="prev-post" href="https://t-tom.me/blog/2018-01-02-%E4%BB%8Ejwt%E5%88%B0oauth/">
            <img class="icon-text" src="/img/prev.svg"/>从jwt到OAuth</a>
        
        
        <a class="next-post" href="https://t-tom.me/blog/2018-03-23-%E4%BD%BF%E7%94%A8swift%E5%BC%80%E5%8F%91react-native%E7%BB%84%E4%BB%B6/">使用Swift开发React Native组件<img class="icon-text" src="/img/next.svg"/>
        </a>
        
    </nav>
</article>
<script src="/js/bundle.min.js"></script>



<div id="disqus_thread" class="no-print"></div>
<script type="text/javascript">

  (function () {
    
    if (window.location.hostname == "localhost")
      return;

    const disqus_thread = document.querySelector('#disqus_thread')
    new IntersectionObserver(function (entries, observer) {
        entries.forEach(entry => {
          if (entry.intersectionRatio > 0 && !disqus_thread.classList.contains('active')) {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            var disqus_shortname = 'toms-blog-1';
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            disqus_thread.classList.add('active')
          }
        })
      }, {
        rootMargin: '0px',
        threshold: 1.0
      }
    ).observe(disqus_thread)

  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>

			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				
<a href="mailto:iamnomand@gmail.com"><img class="icon-social" src="/img/email.svg" alt="Email Me!"/></a>


<a href="https://github.com/v-tom/"><img class="icon-social" src="/img/github.svg" alt="Github"/></a>


<a href="https://twitter.com/iamnomand"><img class="icon-social" src="/img/twitter.svg" alt="Twitter"/></a>

<a href="https://t-tom.me/index.xml" target="_blank"><img class="icon-social" src="/img/feed.svg" alt="Feed"></a>

				<p>
					
					
					Early 2016 ~ 2018 &copy; TOM's Zone
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
		<script>hljs.initHighlightingOnLoad();</script>
		
	</body>
</html>

