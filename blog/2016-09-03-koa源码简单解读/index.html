<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="Keywords" content="">
    <meta name="full-screen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#006cb4">
    <meta name="apple-mobile-web-app-title" content="TOM&#39;s zone">
    <meta name="description" content="TOM&#39;s zone">
    <link rel="dns-prefetch" href="https://hasaki.xyz">
    <link rel="preconnect" href="https://hasaki.xyz">
    <link rel="manifest" href="/sw/manifest.json"/>
<title>koa 源码简单解读 - TOM&#39;s zone</title>

<meta name="description" content="Koa 是一个类似于 Express 的 Web开发框架，创始人也都是 TJ
Koa 的主要特点是，使用了ES6 的 Generator 函数，进行了架构的重新设计。Koa 的原理和内部结构很像Express，但是语法和内部结构进行了升级，最近已经发布了2.x版本，我们来直接看一下2.x版本的koa
创建 Koa 应用 我们可以按照官方的说明很简单的创建一个koa应用
const koa = require(&#39;koa&#39;) const app = new koa() app.listen(3000)  或者可以这样：
var koa = require(&#39;koa&#39;); var http = require(&#39;http&#39;); var app = new koa(); http.createServer(app.callback()).listen(4000);  这两种方式是等价的：
第一种方式:listen在内部主动创建一个一个http server并调用实例内部的 callback方法，把返回的handleRequest函数作为创建http server服务的回调函数，然后内部主动去listen。
参考源码 listen方法：
listen() { debug(&#39;listen&#39;); const server = http.createServer(this.callback()); return server.listen.apply(server, arguments); }  第二种方式:主动创建一个http server并主动调用实例的callback方法来生成一个handleRequest函数，最后listen端口号。
我们先以第一种写法作为入口，切入进去来分析源码。
首先实例化了一个koa实例，然后调用了listen方法:
简单解读: koa 本身是没有定义事件处理机制的，其事件处理机制继承自Node 的events模块，本身就是在events模块上继承的一个实例">




    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">


    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/ocean.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/javascript.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/python.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/css.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/swift.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/objectivec.min.js"></script>


    <link rel="stylesheet" href="/css/bundle.min.css"/>
<script src="/js/bundle.min.js"></script>
<style>
	a { color: #ff8181; }
	blockquote {
		border-left-color: #ff8181;
		border-right-color: #ff8181; }
	.bar a:hover {
		color: #ff8181;
		text-decoration: none; }
	.sep {
		margin-top: 2rem;
		margin-bottom: 1rem;
		margin-left:0;
		width: 24rem;
		border-top: 2px solid #ff8181; }
    .bar li.active a{
        color:#ff8181;
    }
</style>

</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li>
		
		<li class="active"><a href="/blog/">Blog</a></li></ul>
</nav>

	</div>
</header>
<main class="container">

<article>
    <header><hgroup id="brand">
	<h1>koa 源码简单解读</h1>
	<h5>
		
		<time datetime="2016-09-03 15:29:40 &#43;0800 CST">Sep 03, 2016</time>
		<span class="no-print">
			-
				
				<a href="/tags/node.js">Node.js</a>
				
				<a href="/tags/backend">BackEnd</a>
				<span>
	</h5>
	
</hgroup>
<hr class="sep" />
</header>
    <section id="markdown">
        

<p><a href="https://github.com/koajs/koa">Koa</a> 是一个类似于 <a href="https://expressjs.com/">Express</a> 的 <code>Web</code>开发框架，创始人也都是 TJ</p>

<p>Koa 的主要特点是，使用了<code>ES6</code> 的 <code>Generator</code> 函数，进行了架构的重新设计。Koa 的原理和内部结构很像Express，但是语法和内部结构进行了升级，最近已经发布了<code>2.x</code>版本，我们来直接看一下<code>2.x</code>版本的<code>koa</code></p>

<h3 id="创建-koa-应用">创建 <code>Koa</code> 应用</h3>

<p>我们可以按照官方的说明很简单的创建一个<code>koa</code>应用</p>

<pre><code class="language-javascript">const koa = require('koa')

const app = new koa()

app.listen(3000)
</code></pre>

<p>或者可以这样：</p>

<pre><code class="language-javascript">var koa = require('koa');
var http = require('http');

var app = new koa();

http.createServer(app.callback()).listen(4000);
</code></pre>

<p>这两种方式是等价的：</p>

<p>第一种方式:<code>listen</code>在内部主动创建一个一个<code>http server</code>并调用实例内部的 <code>callback</code>方法，把返回的<code>handleRequest</code>函数作为创建<code>http server</code>服务的回调函数，然后内部主动去<code>listen</code>。</p>

<p>参考源码 <code>listen</code>方法：</p>

<pre><code class="language-javascript">  listen() {
    debug('listen');
    const server = http.createServer(this.callback());
    return server.listen.apply(server, arguments);
  }
</code></pre>

<p>第二种方式:主动创建一个<code>http server</code>并主动调用实例的<code>callback</code>方法来生成一个<code>handleRequest</code>函数，最后<code>listen</code>端口号。</p>

<p>我们先以第一种写法作为入口，切入进去来分析源码。</p>

<p>首先实例化了一个<code>koa</code>实例，然后调用了<code>listen</code>方法:</p>

<h3 id="简单解读">简单解读:</h3>

<p><code>koa</code> 本身是没有定义事件处理机制的，其事件处理机制继承自<code>Node</code> 的<code>events</code>模块，本身就是在<code>events</code>模块上继承的一个实例</p>

<pre><code class="language-javascript">// koa 源码解读
const Emitter = require('events');
module.exports = class Application extends Emitter {}
</code></pre>

<h3 id="constructor">constructor</h3>

<p>我们来看一下 <code>constructor</code></p>

<pre><code class="language-javascript">// koa 源码解读
 constructor() {
    super();

    this.proxy = false;
    this.middleware = [];
    this.subdomainOffset = 2;
    this.env = process.env.NODE_ENV || 'development';
    this.context = Object.create(context);
    this.request = Object.create(request);
    this.response = Object.create(response);
  }
</code></pre>

<blockquote>
<p>我们要看的关键方法在于 <code>use</code>、<code>listen</code>、<code>compose</code>、<code>callback</code>，本篇文章（扯淡）会详细的说明，也算是自己的理解</p>
</blockquote>

<h3 id="use方法">use方法</h3>

<p>在<code>koa2</code>中，我们在使用中间件的方法很简单，只需要按照下面的方式就可以添加一层中间件：</p>

<pre><code class="language-javascript">App.use( async ()=&gt;{
  // 中间件
})
</code></pre>

<p><code>koa</code>的一个很重要的概念就是中间件，这个官方讲的很详细，国内翻译的也通俗易懂，<a href="https://github.com/guo-yu/koa-guide">地址</a>,我这里就简单贴个图就好：</p>

<p><img src="https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67" alt="koa middleware" /></p>

<p>参考<code>use</code>方法：</p>

<pre><code class="language-javascript">  // koa 源码加理解
  use(fn) {
    if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');
    // *** 省略代码
    this.middleware.push(fn);
    return this;
  }
</code></pre>

<p><code>koa</code>对中间件的数量并没有限制，可以随意注册多个中间件。但如果有多个中间件，只要有一个中间件缺少 <code>yield next</code> 语句，后面的中间件都不会执行。</p>

<p>所以根据源码可以看到，<code>use</code>方法参数必须是个函数，也可以是个<code>GeneratorFunction</code>（deprecate），而且调用这个<code>use</code>方法后，<code>koa</code>实例内部会自动在<code>middleware</code>数组上<code>push</code>一个中间件。</p>

<h3 id="listen方法">listen方法</h3>

<pre><code class="language-javascript">  // koa 源码加理解
  
  // 创建一个 http server
  const server = http.createServer(this.callback());
  
  // 显式返回 server
  return server.listen.apply(server, arguments);
</code></pre>

<p>在<code>listen</code>方法当中通过[http lib]()模块创建一个<code>http server</code>，然后调用了<code>this.callback()</code>作为这个新创建服务的回调函数，最后通过<code>apply</code>来调用<code>server.listen</code>方法，并把<code>this</code>指向新创建出来的<code>server</code>，并把<code>listen</code>方法的函数实参传入并返回。</p>

<h3 id="callback-方法">callback 方法</h3>

<p>我们来看这个<code>this.callback</code>方法</p>

<pre><code class="language-javascript">  // koa 源码加理解
  callback(){
     // compose
	  const fn = compose(this.middleware);
	  // *** 先省略下面代码
	}
</code></pre>

<p>这个<code>callback</code>方法当中有一个很重要的函数<code>compose</code>。</p>

<h4 id="callback-compose">callback.compose</h4>

<p>这个方法来自<a href="https://github.com/koajs/compose">koa-compose</a>，按照官方的说法作用是:</p>

<blockquote>
<p>Compose the given middleware and return middleware.</p>
</blockquote>

<p>我的理解就是：它的作用是把一个个不相干的中间件串联在一起。我们来看看这个<code>compose</code>方法：</p>

<pre><code class="language-javascript">function compose (middleware) {
  
  // *** 省略代码
  
  // 创建一个闭包便于访问 middleware
  // 根据上面 callback 可以看出，每次 http 请求，都会调用这个闭包函数，然后对整个 middleware 走一次遍历。
  return function (context, next) {
    
    // last called middleware #
    let index = -1
    
    // 第一次调用这个闭包，默认从第一个中间件开始
    return dispatch(0)
    function dispatch (i) {
    
      // 进行条件判断
      if (i &lt;= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      
      // 在这里尝试执行中间件并进行错误捕捉
      // 然后把进入下一个中间件的方法作为参数传入当前中间件，也就是 next 函数，内部进行递归，注意这个递归是按顺序的。
      try {
        return Promise.resolve(fn(context, function next () {
        	// next 函数作为实参进行递归
          return dispatch(i + 1)
        }))
      } catch (err) {
      		// 错误捕捉
        return Promise.reject(err)
      }
    }
  }
}
</code></pre>

<p><code>compose</code>被调用后返回一个闭包函数，在内部可以访问到 <code>middleware</code> 实参，也就是我们跟 <code>koa</code> 进行 <code>use</code> 的中间件。</p>

<p>返回函数<code>dispatch</code>方法内部返回一个递归，第一次调用的时候尝试执行第一个中间件，在内部进行错误捕捉。并且把递归下一个中间件的方法： <code>Function next</code>作为实参传给当前调用的中间件。</p>

<p>所以这也说明了为什么我们使用中间件的时候，<code>use</code>内部要显式的调用<code>yield next</code>，不然下面的中间件不会执行。</p>

<h4 id="callback-handlerequest">callback.handleRequest</h4>

<p>跳过<code>compose</code>让我们继续看下面的代码：</p>

<pre><code class="language-javascript">  // Koa 源码理解
  callback(){
    
    // *** 上面代码在上面，参照 compose 
   
	const handleRequest = (req, res) =&gt; {
	    
	  // 默认http状态码为404，即没有任何中间件修改过就是 404 。
	  res.statusCode = 404;
	    
	  // 创建上下文
	  const ctx = this.createContext(req, res);
	    
	  // 设置 error 分发
	  const onerror = err =&gt; ctx.onerror(err);
	    
	  // 设置 response 分发
	  const handleResponse = () =&gt; respond(ctx);
	    
	  // 统一设置 finished 分发，用于监听 http response 的结束事件，执行回调
	  onFinished(res, onerror);
	    
	  // 添加一个中间件的方法：app.use(middleware)
	  // 调用 compose 返回的闭包来按顺序处理所有的 middleware，并把 context 传入，所以每个中间件内部可以访问到 context
	    
	  fn(ctx).then(handleResponse).catch(onerror);
	    
	};
	
	  // 显式返回 handleRequest
	  return handleRequest;    
  }
</code></pre>

<p>上面调用<code>compose</code>后，显式返回了一个<code>handleRequest</code>函数来作为返回值来处理<code>http</code>请求</p>

<p>每次<code>http</code>请求，都会有以下流程：</p>

<ul>
<li>状态码默认是<code>404</code>，当然在下面的中间件当中可以进行处理，这也方便了[koa-router]()进行匹配。</li>
<li>创建一个新的上下文：<code>createContext</code>,也就是<code>context</code>或者<code>ctx</code></li>
<li>设置<code>error：onerror</code>，<code>response：respond</code>等分发</li>
<li>递归中间件并捕捉错误</li>
</ul>

<blockquote>
<p>根据上面的<code>listen</code>方法内部<code>http.createServer(this.callback())</code>可以看出，每次<code>http</code>请求都会走一次这个<code>callback</code>，返回一个函数：在函数内部创建全新的上下文，设置<code>error</code>，<code>response</code>，<code>finished</code>，最后调用<code>compose</code>来按照顺序走一次我们配置的所有的中间件。</p>
</blockquote>

<p>我们接下来来看看 <code>createContext</code>和 <code>respond</code>以及<code>onFinished</code></p>

<h4 id="callback-createcontext">callback.createContext</h4>

<pre><code class="language-javascript">  // koa 源码理解
  createContext(req, res) {
  
    // 通过Object.create 来创建 上下文 request response
    const context = Object.create(this.context);
    const request = context.request = Object.create(this.request);
    const response = context.response = Object.create(this.response);
    
    // 在 上下文 request response 上挂载 app 和 req 和 res 便于访问
    // app === this
    // req === httpServer.request
    // res === httpServer.response
    context.app = request.app = response.app = this;
    context.req = request.req = response.req = req;
    context.res = request.res = response.res = res;
    
    // 在 request 上 挂载 上下文
    request.ctx = response.ctx = context;
    
    // 互相挂载
    request.response = response;
    response.request = request;
    
    // 挂载 原始请求地址
    context.originalUrl = request.originalUrl = req.url;
    
    // 挂载 cookies ，这里暂不深入
    context.cookies = new Cookies(req, res, {
      keys: this.keys,
      secure: request.secure
    });
    
    // 挂载原始ip
    request.ip = request.ips[0] || req.socket.remoteAddress || '';
    
    // 挂载 request accept
    context.accept = request.accept = accepts(req);
    
    // 当前上下文的state，官方推荐设置state最好的方式
    context.state = {};
    
    // 显式返回 上下文
    return context;
  }
</code></pre>

<h4 id="callback-respond">callback.respond</h4>

<pre><code class="language-javascript">function respond(ctx) {
  // allow bypassing koa
  if (false === ctx.respond) return;

  const res = ctx.res;
  if (!ctx.writable) return;

  let body = ctx.body;
  const code = ctx.status;

  // ignore body
  if (statuses.empty[code]) {
    // strip headers
    ctx.body = null;
    return res.end();
  }

  if ('HEAD' == ctx.method) {
    if (!res.headersSent &amp;&amp; isJSON(body)) {
      ctx.length = Buffer.byteLength(JSON.stringify(body));
    }
    return res.end();
  }

  // status body
  if (null == body) {
    body = ctx.message || String(code);
    if (!res.headersSent) {
      ctx.type = 'text';
      ctx.length = Buffer.byteLength(body);
    }
    return res.end(body);
  }

  // responses
  if (Buffer.isBuffer(body)) return res.end(body);
  if ('string' == typeof body) return res.end(body);
  if (body instanceof Stream) return body.pipe(res);

  // body: json
  body = JSON.stringify(body);
  if (!res.headersSent) {
    ctx.length = Buffer.byteLength(body);
  }
  res.end(body);
}

</code></pre>

<p>至此基本上源码也就解读完了，也许会有人会问：koa 和 express 中间件的主要区别是什么？</p>

<blockquote>
<p>可以参考这篇文章来详细介绍 <a href="http://perkinzone.cn/2017/08/15/Redux,Koa,Express%E4%B9%8Bmiddleware%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94/">koa、express等中间件的区别</a></p>
</blockquote>

<p>其实两者的中间件都是以一系列数组的模式，只是对于中间件的处理方式不同</p>

<p>koa 是洋葱型，内部实现中间件是以 Promise 的形式通过 <code>Promise based then</code> 来实现洋葱模型</p>

<p>虽然都说 express 则是直线型，实际运行起来 express 也可以说是洋葱型，只是内部实现中间件是以 stack 的形式，通过 <code>callback</code> 的形式实现。</p>

    </section>
    <nav class="no-print post-nav">
        
        <a class="prev-post" href="https://hasaki.xyz/blog/2016-06-22-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAnode.js-%E7%9A%84-docker-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">
            <img class="icon-text" src="/img/prev.svg"/>如何创建一个Node.js 的 Docker 开发环境</a>
        
        
        <a class="next-post" href="https://hasaki.xyz/blog/2017-03-24-%E5%89%8D%E7%AB%AF%E7%9A%8410000%E4%B8%AA%E5%B0%8F%E6%97%B6/">前端的10000个小时<img class="icon-text" src="/img/next.svg"/>
        </a>
        
    </nav>
</article>



<div id="disqus_thread" class="no-print"></div>
<script type="text/javascript">
    'use strict';
    (function () {
        if ('localhost' != window.location.hostname) {
            var a = document.querySelector('#disqus_thread');
            new IntersectionObserver(function (b) {
                b.forEach(function (d) {
                    if (0 < d.intersectionRatio && !a.classList.contains('active')) {
                        var e = document.createElement('script');
                        e.type = 'text/javascript', e.async = !0;
                        e.src = '//' + 'toms-blog-1' + '.disqus.com/embed.js', (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(e), a.classList.add('active')
                    }
                })
            }, {rootMargin: '0px', threshold: 1}).observe(a)
        }
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>


<style rel="catalog">
    #catalog {
        position: fixed;
        left: 3vw;
        top: 8vh;
    }

    .cl-wrapper {
        position: relative;
    }

    .cl-wrapper ul, .cl-wrapper li {
        margin: 0;
        -moz-padding-start: 12px;
        -webkit-padding-start: 12px;
        list-style: none;
    }

    .cl-wrapper li > .cl-link.cl-link-active {
        color: #ff8181;
        transition: .5s;
    }

    .cl-wrapper li > .cl-transform.cl-link-active {
        transform: translate(3px);
    }

    .cl-wrapper .cl-link {
        cursor: pointer;
        color: rgba(52, 73, 94, 0.5);
        font-size: 13px;
        transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
    }

    .cl-wrapper .cl-marker {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
    }

    .cl-wrapper .cl-marker path {
        transition: all 0.3s ease;
    }
</style>
<main id="catalog"></main>
<script rel="catalog">
    void function () {
        
        
        
        const Catalog = (function () {
            return function (opts) {
                let defaultOpts = {
                    linkClass: 'cl-link',                             
                    linkActiveClass: 'cl-link-active',                
                    datasetName: 'data-cata-target',                  
                    selector: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],   
                    scrollWrapper: null,                              
                    activeHook: null,                                 
                    topMargin: 0,
                    bottomMargin: 0,
                    cool: true                                        
                }

                const Opt = Object.assign({}, defaultOpts, opts)

                const $content = document.getElementById(Opt.contentEl)                          
                const $scroll_wrap = window   
                const $catalog = document.getElementById(Opt.catalogEl)                          

                let allCatalogs = $content.querySelectorAll(Opt.selector.join())
                let tree = getCatalogsTree(allCatalogs)

                try {
                    $catalog.innerHTML = `<div class='cl-wrapper'>${generateHtmlTree(tree, {id: -1})}<svg class="cl-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
            <path stroke="#ff8181" stroke-width="3" fill="transparent" stroke-dasharray="0, 0, 0, 1000" stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)" />
            </svg></div>`
                } catch (e) {
                    console.error('error in progress-catalog', e)
                }


                const tocPath = $catalog.querySelector('.cl-marker path')
                let tocItems, pathLength    

                
                window.addEventListener('resize', drawPath)
                $catalog.addEventListener('click', clickHandler)
                Opt.cool && $scroll_wrap.addEventListener('scroll', coolScrollHandler)
                Opt.cool || $scroll_wrap.addEventListener('scroll', simpleScrollHandler)

                setTimeout(drawPath)          

                

                function drawPath() {
                    tocItems = [...$catalog.querySelectorAll('li')]
                    tocItems = tocItems.map(function (liDom) {
                        const anchor = liDom.querySelector(`.${Opt.linkClass}`)
                        const target = document.getElementById(anchor.getAttribute('data-cata-target'))

                        return {
                            listItem: liDom,
                            anchor: anchor,
                            target: target
                        }
                    })
                    tocItems = tocItems.filter(item => !!item.target)

                    const path = []
                    let pathIndent

                    tocItems && tocItems.forEach(function (item, idx) {
                        const {offsetLeft, offsetTop, offsetHeight} = item.anchor,
                            x = Opt.cool ? offsetLeft - 5 : offsetLeft,
                            y = offsetTop,
                            height = offsetHeight

                        if (idx === 0) {
                            path.push('M', x, y, 'L', x, y + height)
                            item.pathStart = 0
                        }
                        else {
                            if (pathIndent !== x) path.push('L', pathIndent, y)     
                            path.push('L', x, y)
                            tocPath.setAttribute('d', path.join(' '))
                            item.pathStart = tocPath.getTotalLength() || 0
                            path.push('L', x, y + height)
                        }
                        pathIndent = x
                        tocPath.setAttribute('d', path.join(' '))
                        item.pathEnd = tocPath.getTotalLength()
                    })
                    pathLength = tocPath.getTotalLength()
                    coolScrollHandler()
                }

                

                function coolScrollHandler() {
                    const wrapHeight = document.documentElement.offsetHeight
                    let pathStart = pathLength,
                        pathEnd = 0,
                        visibleItems = 0
                    tocItems.forEach(function (liItem) {
                        const {bottom, top} = liItem.target.getBoundingClientRect(),
                            firstChild = liItem.listItem.firstChild
                        if (bottom > Opt.topMargin && top < wrapHeight - Opt.bottomMargin) {
                            firstChild.classList.remove(Opt.linkActiveClass)
                            Opt.cool && firstChild.classList.remove('cl-transform')
                        } else {
                            pathStart = Math.min(liItem.pathStart, pathStart)
                            pathEnd = Math.max(liItem.pathEnd, pathEnd)
                            visibleItems += 1
                            firstChild.classList.add(Opt.linkActiveClass)
                            Opt.cool && firstChild.classList.add('cl-transform')
                        }
                    })
                    if (visibleItems > 0 && pathStart < pathEnd && Opt.cool) {
                        tocPath.setAttribute('stroke-dashoffset', '1')
                        tocPath.setAttribute('stroke-dasharray', `1, ${pathStart}, ${pathEnd - pathStart}, ${pathLength}`)
                        tocPath.setAttribute('opacity', '1')
                    }
                    else {
                        tocPath.setAttribute('opacity', '0')
                    }
                }

                

                function simpleScrollHandler(el) {
                    let scrollToEl = null
                    for (let i = allCatalogs.length - 1; i >= 0; i--) {
                        if (allCatalogs[i].offsetTop <= $scroll_wrap.scrollTop) {
                            scrollToEl = allCatalogs[i]
                            break
                        }
                    }
                    if (scrollToEl) setActiveItem(scrollToEl.id)
                    else setActiveItem(null)            
                }

                

                function clickHandler({target}) {
                    const datasetId = target.getAttribute(Opt.datasetName)
                    target.classList.contains(Opt.linkClass) &&
                    document.getElementById(datasetId)
                        .scrollIntoView({behavior: "smooth", block: "start"})
                }

                

                function getCatalogsTree(catalogs) {
                    let title, tagName, tree = [], treeItem = {}, parentItem = {id: -1}, lastTreeItem = null, id

                    for (let i = 0; i < catalogs.length; i++) {
                        title = catalogs[i].innerText || catalogs[i].textContent
                        tagName = catalogs[i].tagName
                        id = 'heading-' + i
                        catalogs[i].id = id
                        treeItem = {
                            name: title,
                            tagName: tagName,
                            id: id,
                            level: +getLevel(tagName),
                            parent: parentItem
                        }
                        if (lastTreeItem) {
                            if (getLevel(treeItem.tagName) > getLevel(lastTreeItem.tagName)) {
                                treeItem.parent = lastTreeItem
                            } else {
                                treeItem.parent = findParent(treeItem, lastTreeItem)
                            }
                        }
                        lastTreeItem = treeItem
                        tree.push(treeItem)
                    }
                    return tree
                }

                

                function findParent(currTreeItem, lastTreeItem) {
                    let lastTreeParent = lastTreeItem.parent
                    while (lastTreeParent && (getLevel(currTreeItem.tagName) <= getLevel(lastTreeParent.tagName))) {
                        lastTreeParent = lastTreeParent.parent
                    }
                    return lastTreeParent || {id: -1}
                }

                

                function getLevel(tagName) {
                    return tagName ? tagName.slice(1) : 0
                }

                

                function generateHtmlTree(tree, _parent) {
                    let ul, hasChild = false
                    if (tree) {
                        ul = `<ul>`
                        for (let i = 0; i < tree.length; i++) {
                            if (isEqual(tree[i].parent, _parent)) {
                                hasChild = true
                                ul += `<li><div class='${ Opt.linkClass } cl-level-${ tree[i].level }' ${Opt.datasetName}='${ tree[i].id }'>${tree[i].name}</div>`
                                ul += generateHtmlTree(tree, tree[i])
                                ul += '</li>'
                            }
                        }
                        ul += `</ul>`
                    }
                    return hasChild ? ul : ''
                }

                /**
                 * 判断是否是相同节点
                 */
                function isEqual(node, node2) {
                    return node && node2 && typeof node === 'object' && typeof node2 === 'object' && node.id === node2.id
                }

                /**
                 *  设置选中的项
                 */
                function setActiveItem(id) {
                    let catas = [...$catalog.querySelectorAll(`[${Opt.datasetName}]`)]

                    catas.forEach(T => {
                        if (T.getAttribute(Opt.datasetName) === id) {
                            typeof Opt.activeHook === 'function' &&
                            !T.classList.contains(Opt.linkActiveClass) &&
                            Opt.activeHook.call(this, T)                    // 执行active钩子
                            T.classList.add(Opt.linkActiveClass)
                        } else {
                            T.classList.remove(Opt.linkActiveClass)
                        }
                    })
                }
            }
        })();
        window.addEventListener('DOMContentLoaded', _ => new Catalog({
            contentEl: 'markdown',
            catalogEl: 'catalog'
        }))
    }();
</script>
			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				
<a href="mailto:iamnomand@gmail.com"><img class="icon-social" src="/img/email.svg" alt="Email Me!"/></a>


<a href="https://github.com/v-tom/"><img class="icon-social" src="/img/github.svg" alt="Github"/></a>


<a href="https://twitter.com/iamnomand"><img class="icon-social" src="/img/twitter.svg" alt="Twitter"/></a>

<a href="https://hasaki.xyz/index.xml" target="_blank"><img class="icon-social" src="/img/feed.svg" alt="Feed"></a>

				<p>
					
					
					Early 2016 ~ 2019 &copy; TOM's Zone
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
		<script>hljs.initHighlightingOnLoad();</script>
		
	</body>
</html>

