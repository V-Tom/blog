<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Hugo 0.38.2" />
    <title>React Native ART 介绍与实践 - TOM&#39;s zone</title>

    <meta name="description" content="TBD
 React Native ART 由来 React-Art  是 Reactjs 团队基于 Art（一个兼容各个浏览器SVG绘制的API封装）开发的模块，让 React 开发者能使用 jsx 语法绘制 svg。
React Native 团队分别在0.10.0和0.18.0也添加了iOS和Android平台对 react-art 的支持，官网文档至今对其只字未提。本文旨在介绍安静躺在 react-native/Libraries/ 里的ART，并展示一些实践结果。
在React Native中ART是个非常重要的库，它让非常酷炫的绘图及动画变成了可能。但是可能是知道的人真的不多导致文档及少中文更少。很多都是把英文的参数列表翻译过来，也没有案例。
为什么用 ART React Native 本身自带的 &lt;Image&gt; 有很多缺陷：
首先是不支持 SVG 格式的资源，目前的解决方案有通过 ReactNative-SVG 进行实现，但是这个库需要更改客户端bundle文件，带来一定的风险。
其次是 Image decoding can take more than a frame-worth of time，图片的解码由于不在主线程中进行，所以不能确保所有图片和内容在同一帧内出现，使用 &lt;Image&gt;标签的制作的组件里的图（比如icon）可能是三三两两“闪现”出来的，让人怀疑是个webview，体验远不如原生，尤其是在开发环境下最为明显。
其次就是不能支持矢量图形，必须放置 @2x 或者 @3x 对应的图片。
ART能干什么 俗话说，库如其名，背负着如此具有“艺术感”名字的ART生来就是为了绘制矢量图的，或者说是 画UI的，ART可以解决上诉的所有缺陷。
在我看来，或者说我目前业务需求用到的功能：
 ART 可以解决上诉 &lt;Image&gt; 的缺陷：解码和矢量图形 ART 可以实现 UI 上的一些渐变，比如渐变按钮，渐变背景或者底色。以及一些交互性较强的动画——画UI ART 另外一个场景就是简单数据可视化。  使用 ART  本文使用的 RN版本为0.">


    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">

    
    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/ocean.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/javascript.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/python.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/css.min.js"></script>
    
    
    <link rel="stylesheet" href="/css/bundle.css"/>
    <style>
	a { color: #ff8181; }
	blockquote {
		border-left-color: #ff8181;
		border-right-color: #ff8181; }
	.bar a:hover {
		color: #ff8181;
		text-decoration: none; }
	.sep {
		margin-top: 2rem;
		margin-bottom: 1rem;
		margin-left:0;
		width: 24rem;
		border-top: 2px solid #ff8181; }
</style>

</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li><li><a href="/blog/">Blog</a></li></ul>
</nav>

	</div>
</header>
<main class="container">

<article>
    <header><hgroup id="brand">
	<h1>React Native ART 介绍与实践</h1>
	<h5>
		
		<time datetime="2018-01-13 15:29:40 &#43;0800 CST">Jan 13, 2018</time>
		<span class="no-print">
			-
				
				<a href="/tags/React">React</a>
				
				<a href="/tags/FrontEnd">FrontEnd</a>
				
				<a href="/tags/RN">RN</a>
				
				<a href="/tags/D3">D3</a>
				<span>
	</h5>
	
</hgroup>
<hr class="sep" />
</header>
    <section id="markdown">
        

<blockquote>
<p>TBD</p>
</blockquote>

<h3 id="react-native-art-由来">React Native ART 由来</h3>

<p><a href="https://github.com/reactjs/react-art">React-Art </a> 是 <code>Reactjs</code> 团队基于 <a href="https://github.com/sebmarkbage/art">Art</a>（一个兼容各个浏览器SVG绘制的API封装）开发的模块，让 <code>React</code> 开发者能使用 <code>jsx</code> 语法绘制 <code>svg</code>。</p>

<p><code>React Native</code> 团队分别在0.10.0和0.18.0也添加了iOS和Android平台对 <code>react-art</code> 的支持，官网文档至今对其只字未提。本文旨在介绍安静躺在 <a href="https://github.com/facebook/react-native/blob/master/Libraries/ART/ReactNativeART.js">react-native/Libraries/</a> 里的<code>ART</code>，并展示一些实践结果。</p>

<p>在React Native中ART是个非常重要的库，它让非常酷炫的绘图及动画变成了可能。但是可能是知道的人真的不多导致文档及少中文更少。很多都是把英文的参数列表翻译过来，也没有案例。</p>

<h3 id="为什么用-art">为什么用 ART</h3>

<p><code>React Native</code> 本身自带的 <code>&lt;Image&gt;</code> 有很多缺陷：</p>

<p>首先是不支持 SVG 格式的资源，目前的解决方案有通过 <a href="https://github.com/react-native-community/react-native-svg">ReactNative-SVG</a> 进行实现，但是这个库需要更改客户端bundle文件，带来一定的风险。</p>

<p>其次是 <a href="https://facebook.github.io/react-native/docs/images.html#off-thread-decoding">Image decoding can take more than a frame-worth of time</a>，图片的解码由于不在主线程中进行，所以不能确保所有图片和内容在同一帧内出现，使用 <code>&lt;Image&gt;</code>标签的制作的组件里的图（比如icon）可能是三三两两“闪现”出来的，让人怀疑是个<code>webview</code>，体验远不如原生，尤其是在开发环境下最为明显。</p>

<p>其次就是不能支持矢量图形，必须放置 <code>@2x</code> 或者 <code>@3x</code> 对应的图片。</p>

<h3 id="art能干什么">ART能干什么</h3>

<p>俗话说，<strong>库如其名</strong>，背负着如此具有“艺术感”名字的ART生来就是为了绘制矢量图的，或者说是 <strong>画UI的</strong>，ART可以解决上诉的所有缺陷。</p>

<p>在我看来，或者说我目前业务需求用到的功能：</p>

<ul>
<li>ART 可以解决上诉 <code>&lt;Image&gt;</code> 的缺陷：解码和矢量图形</li>
<li>ART 可以实现 UI 上的一些渐变，比如渐变按钮，渐变背景或者底色。以及一些交互性较强的动画——<strong>画UI</strong></li>
<li>ART 另外一个场景就是简单数据可视化。</li>
</ul>

<h3 id="使用-art">使用 ART</h3>

<blockquote>
<p>本文使用的 RN版本为0.50.1</p>

<p>本文一些英语词汇出于编写角度进行了简写，RN是 <code>React Native</code> 的简写</p>

<p>Android默认就包含ART库，IOS需要单独添加依赖库。</p>
</blockquote>

<ul>
<li>ART在iOS上使用需要事先导入ART的链接库，找到 <code>node_modules/react-native/Libraries/ART/ART.xcdoeproj</code> 拖入Xcode对应项目的 <code>Libraries</code></li>
<li>打开 <code>General Settings</code>添加 <code>libART.a</code> 到 <code>Linked Frameworks and Libraries</code> 列表</li>
<li><code>cmd+b</code>重新构建项目</li>
</ul>

<h4 id="基本-api">基本 API</h4>

<p><a href="https://github.com/react-native-china/react-native-ART-doc/blob/master/doc.md">RN ART 文档 (非官方)</a> 在github上有这样比较全一篇文档，可以选择直接看它了解使用。</p>

<p><code>ART</code> 目前的API有：</p>

<ul>
<li><code>Surface</code> 标签对应svg中的<code>SVG</code>标签，所有ART的jsx内容需要被其包含</li>
<li><code>Group</code> 标签对应 <code>g</code> 标签</li>
<li><code>Shape</code> 标签对应 <code>path</code> 标签</li>
<li><code>Text</code> 标签对应 <code>text</code> 标签</li>
<li><code>Transform</code> 做图形变换的API</li>
<li><code>Path</code> 绘制路径API</li>
<li><code>LinearGradient</code> 创建线性渐变API</li>
<li><code>RadialGradient</code> 创建径向渐变API</li>
</ul>

<blockquote>
<p>本文不介绍 SVG ，读者可以自行线下学习。</p>
</blockquote>

<p>可以看到 ART 和 SVG 还是有不同的，有点像是阉割后的 SVG，当然已经有开发者做了实现，可以方便地使用 SVG 标签写 <a href="https://github.com/react-native-community/react-native-svg">ReactNative-SVG</a> ，这种方式的缺点上文已经说过。</p>

<p>在本文例子当中，我们使用原原本本的ART实践。</p>

<h4 id="基础例子">基础例子：</h4>

<p>下面是一个绘制线段的 ART demo：</p>

<pre><code class="language-javascript">import React, { Component } from 'react'
import {
  View,
  Dimensions,
  ART
} from 'react-native'

export default class Line extends Component {
  render() {
    return (
      &lt;View
      &gt;
        &lt;ART.Surface
          width={Dimensions.get('window').width}
          height={100}
        &gt;
          &lt;ART.Shape
            d={new ART.Path().moveTo(50, 50).lineTo(100, 100)}
            stroke=&quot;#000000&quot;
            strokeWidth={1}
          /&gt;
        &lt;/ART.Surface&gt;
      &lt;/View&gt;
    )
  }
}
</code></pre>

<p><code>Surface</code> 必须是ART内容的父层，并且其中不能包含非ART标签（否则直接闪退…），需要指定宽高，很多时候绘制无效或者缺角有可能是 <code>Path</code> 超过了 <code>Shape</code> 的绘制区域。</p>

<p><code>Group</code> 可有可无，当绘制内容较多时可以用其统一管理，可以把它当做 <code>View</code>标签使用，可制定内容在画布绘制的起点。</p>

<p><code>Shape</code> 是目前ART绘制的首要入口，<code>d</code> 属性对标svg的 <code>path</code> 标签上的 <code>d</code> 属性。</p>

<p>所有的ART标签都可以使用 <code>transform</code> 属性做变换。</p>

<p><code>Shape</code> 当中的 <code>d</code> 类似于 svg 的 path，可以通过 <code>ART.Path</code> 生成，比如下面这些是绘制的一些简单图形：</p>

<ul>
<li>圆形</li>
</ul>

<pre><code class="language-javascript">// 绘制圆形
function circlePathRender() {
  
  const path = Path()
  	.moveTo(0,50)
    .arc(0, radius * 2, radius)
    .arc(0, radius * -2, radius)
    .close(); // 闭合路径
  
  // path 可以直接作为 props 传给 shape
  return &lt;ART.Shape 
           d={path} 
           fill={'#2ba'}
          /&gt;
}
</code></pre>

<ul>
<li>绘制多边形：</li>
</ul>

<pre><code class="language-javascript">// 绘制多边形
function polygonPathRender() {
  var path = Path()
  	.moveTo(10, 10)
    .lineTo(20, 30)
    .lineTo(30, 40)
    .close(); // 闭合路径
  
  return &lt;ART.Shape 
           d={path} 
           fill={'#00a'} 
           stroke=&quot;yellow&quot; 
           strokeWidth={4}
          /&gt;
}
</code></pre>

<p><code>Path</code> 还有一些API来满足日常绘图要求：<code>arcTo</code>/<code>curve</code>/<code>line</code>/<code>Text</code></p>

<ul>
<li>文字</li>
</ul>

<pre><code class="language-javascript">// 绘制文字
function textRender() {
  return (
    &lt;ART.Text
      font={`bold 13px &quot;Helvetica Neue&quot;, &quot;Helvetica&quot;, Arial`}
      fill=&quot;#749&quot;
      x={0}
      y={0}
    &gt;
      Lorem ipsum dolor sit amet
    &lt;/ART.Text&gt;
  );
}
</code></pre>

<ul>
<li>渐变</li>
</ul>

<pre><code class="language-javascript">// linearGradient 可赋值给Path或者Text标签的fill属性

function linearGradientRender() {
  const linearGradient = new ART.LinearGradient({
    &quot;0&quot;: &quot;#2ba&quot;,
    &quot;.5&quot;: &quot;#f90&quot;,
    &quot;0.7&quot;: &quot;#aa4422&quot;,
    &quot;1&quot;: &quot;rgba(255,255,255,0.5)&quot;
  }, 0, 0, 100, 200);
  
  // 这里的 d props(Path) 简略
  return &lt;ART.Shape 
           d={...} 
           fill={linearGradient} 
          /&gt;
}

</code></pre>

<p><code>LinearGradient</code> 构造函数第一个参数是设定渐变色的对象。</p>

<p>使用诸如<code>0.3</code>/<code>.52</code>/<code>1</code>这样的属性表示<code>30%</code>/<code>52%</code>/<code>100%</code>，值为颜色值，不符合要求的键值对会被忽略。
后面四个参数分别表示：起点x，起点y，终点x，终点y.</p>

<pre><code class="language-javascript">// radialGradient 可赋值给Path或者Text标签的fill属性

function radialGradientRender() {
  const radialGradient = new ART.RadialGradient({
    &quot;0&quot;: &quot;#2ba&quot;,
    &quot;.5&quot;: &quot;#f90&quot;,
    &quot;0.7&quot;: &quot;#aa4422&quot;,
    &quot;1&quot;: &quot;rgba(255,255,255,0.5)&quot;
  }, 0, 0, 100, 200);
  
  // 这里的 d props(Path) 简略
  return &lt;ART.Shape 
           d={...} 
           fill={radialGradient} 
          /&gt;
}

</code></pre>

<p><code>RadialGradient</code>构造函数第一个参数是和线性渐变相同的，后续六个分别表示：焦点x，焦点y，x半轴长，y半轴长，原点x，原点y。</p>

<h3 id="art-动画">ART 动画</h3>

<p>大多数情况下，在 React Native 中创建动画是推荐使用 <a href="https://facebook.github.io/react-native/docs/animated.html">Animated API</a> 的，其提供了三个主要的方法用于创建动画：</p>

<h3 id="art-简单数据可视化">ART 简单数据可视化</h3>

<blockquote>
<p>本文采用 d3-shapes 生成 Path 来通过 ART.Shape 进行绘制可视化数据。</p>

<p>注意：这个 Path 和 SVG 的 Path 基本上一样，但是请注意 ART 只是 阉割版的 SVG，以下针对 D3 文档的描述和解释是个人对 D3 的理解</p>
</blockquote>

<p>通过上面对 ART 提供的一些 API 简单介绍可以发现，我们可以指定一个特殊的 <code>Path</code> 给 <code>Shape</code> 组件（d props），可以实现一些曲线线段，比如下面代码：</p>

<pre><code class="language-javascript">import React, { Component } from 'react'
import {
  ART,
  View,
} from 'react-native';

const {
  Surface,
  Group,
  Shape,
} = ART;

export default class ARTSimpleLine extends Component{
    render(){
        return (
            &lt;View&gt;
              &lt;Surface width={500} height={500}&gt;
                &lt;Group&gt;
                  &lt;Shape
                    d=&quot;M0,100L60,160L120,60L180,140L240,100L300,120&quot;
                    stroke=&quot;#000&quot;
                    strokeWidth={1}
                    // 设置 shape X 偏移值
                    x={50}
                    /&gt;
                &lt;/Group&gt;
              &lt;/Surface&gt;
            &lt;/View&gt;
          )
    }
}
</code></pre>

<p>可以得到如下的一个简单图形：</p>

<p><img src="./ARTSimpleLine.png" alt="ARTSimpleLine" /></p>

<p>实际上我们可以通过一些工具生成 Path 来做简单的数据可视化。</p>

<p>而path data由一系列的命令组成，比如上面代码当中的：</p>

<blockquote>
<p>SVG 的 path 这里不详细介绍，可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths">SVG path tutorial</a></p>
</blockquote>

<pre><code class="language-text">M0,100L60,160L120,60L180,140L240,100L300,120
</code></pre>

<p>实际上，我们可以自己通过书写代码来创建这些 path 命令集，但是你会发现，写出这些代码虽然并不难，但是一定是很繁琐的，所以我们需要一个工具来自动生成这些命令集。</p>

<p>我们这里采用 <code>D3.js</code> path generator 的路径生成器，下面列出了一些常见的路径生成器：</p>

<ul>
<li><a href="https://github.com/d3/d3-shape#arcs">Arcs</a></li>
<li><a href="https://github.com/d3/d3-shape#pies">Pies</a></li>
<li><a href="https://github.com/d3/d3-shape#lines">Lines</a></li>
<li><a href="https://github.com/d3/d3-shape#areas">Areas</a></li>
<li><a href="https://github.com/d3/d3-shape#curves">Curves</a></li>
<li><a href="https://github.com/d3/d3-shape#symbols">Symbols</a></li>
</ul>

<p>我们暂时只简单的用到了 <code>Lines</code> 生成器。</p>

<p>首先生明一个 <code>line generator</code>：</p>

<pre><code class="language-javascript">const lineGenerator = d3.line();
</code></pre>

<p>我们来定义一个坐标数组：</p>

<pre><code class="language-javascript">const points = [
  [0, 100],
  [60, 160],
  [120, 60],
  [180, 140],
  [240, 100],
  [300, 120]
];
</code></pre>

<p>接着我们传入points参数来调用lineGenerator：</p>

<pre><code class="language-javascript">const pathData = lineGenerator(points);
// pathData is &quot;M0,100L60,160L120,60L180,140L240,100L300,120&quot;
</code></pre>

<p>lineGenerator完成的工作就是创建了一个M(move to)和L（line to）命令的字符串，这样我们就得到了Path Data。</p>

<p>这是我们想要的 Path Data吗？</p>

<p>显然不是，我们需要 Path Data 尽量具有以下特征：</p>

<ul>
<li>线条扁平，曲线化</li>
<li>Data Driven</li>
</ul>

<p>查阅文档，发现 <a href="https://github.com/d3/d3-shape#line_curve">line.curve</a> 方法可以实现特征一，至于 <a href="https://github.com/d3/d3-shape#curves">Curve</a> ，D3 当中有做了详细的解释：</p>

<blockquote>
<p>While <a href="https://github.com/d3/d3-shape#lines">lines</a> are defined as a sequence of two-dimensional [<em>x</em>, <em>y</em>] points, and <a href="https://github.com/d3/d3-shape#areas">areas</a> are similarly defined by a topline and a baseline, there remains the task of transforming this discrete representation into a continuous shape: <em>i.e.</em>, how to interpolate between the points. A variety of curves are provided for this purpose.</p>

<p>简单翻译一下：线被定义为二维[x,y]点序列，为了将离散转换为连续形状的任务，D3 提供了各种曲线（ps：曲线实现是一个黑盒，使用者无需关心如何实现，可以查看 <a href="https://people.cs.clemson.edu/~dhouse/courses/405/notes/splines.pdf">splines</a></p>
</blockquote>

<p>D3 提供了 <code>line.curve</code> 方法。</p>

<p>curve 通常情况下不会直接构建或者生成，只会在调用 <code>line.curve</code> 方法的时候生成，很多方法来辅助生成 Curve：</p>

<ul>
<li><strong>curveBasis</strong></li>

<li><p><strong>curveCardinal</strong></p></li>

<li><p><strong>curveBasisClosed</strong></p></li>

<li><p><strong>&hellip;</strong></p></li>
</ul>

<p>这里只简单列出一些方法，而且我们这里只用到一种方法：<strong>curveCardinal</strong></p>

<p>按照 D3 给出的例子，代码是下面这样的：</p>

<pre><code class="language-javascript">const line = d3.line()
    .curve(d3.curveCardinal);
</code></pre>

<p><strong>curveCardinal</strong> 的作用官方是这样介绍的：</p>

<blockquote>
<p>Produces a cubic <a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline">cardinal spline</a> using the specified control points, with one-sided differences used for the first and last piece. The default <a href="https://github.com/d3/d3-shape#curveCardinal_tension">tension</a> is 0.</p>
</blockquote>

<p>官方介绍太学术化，简单理解为：使用用户传入的控制点坐标来生成曲线。</p>

<p>简单和其他的方法比较一下，没有产生一个闭环，而且使用了第一个和最后一个控制点坐标，而且张力默认为0。</p>

<p>然后我们就可以生成这样一个 Path Data</p>

<pre><code class="language-text">M0,100C0,100,40,166.66666666666666,60,160C80,153.33333333333334,100,63.333333333333336,120,60C140,56.666666666666664,160,133.33333333333334,180,140C200,146.66666666666666,220,103.33333333333333,240,100C260,96.66666666666667,300,120,300,120
</code></pre>

<p>实际得到的图形如下：</p>

<p><img src="./ARTCurve.png" alt="Art Curve" /></p>

<blockquote>
<p>当然 <code>D3.curve</code> 传入不同的辅助方法会生成不同的 Path Data 以及曲线，读者可以自行线下尝试</p>
</blockquote>

<p>这样看下来似乎已经很完美了，但是注意，这个 Path Data 是根据我们自定义的数据（<strong>预先设定完毕的二维坐标数组</strong>）生成的，实际业务当中，数据只会是数据，比如：</p>

<pre><code class="language-javascript">// 一周内的降雨流量数据(伪造)
const data = [820, 932, 631, 934, 890, 1330, 1320]
</code></pre>

<p>具体图表上的二维坐标我们是无法确定或者无法及时变动的，所以，似乎我们需要一个方法来自定义二维坐标的生成？</p>

<p>当然可以，上诉代码可以修改为：</p>

<pre><code class="language-javascript">const line = d3.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.value); })
    .curve(d3.curveCardinal);
</code></pre>

<p>你可能会说这个 <code>line.x</code> 和 <code>line.y</code> 是个什么鬼？</p>

<p>关于 <code>line.x</code> 官方是这样解释：</p>

<blockquote>
<p>If <em>x</em> is specified, sets the x accessor to the specified function or number and returns this line generator. If <em>x</em> is not specified, returns the current x accessor, which defaults to:</p>

<pre><code class="language-javascript">&gt; function x(d) {
&gt;   return d[0];
&gt; }
&gt; ```

简单来说就是：如果指定 `x` ，则将 x accessor 设置为指定的函数或编号并返回此行 generator，什么意思呢？

这个可以理解为一个辅助函数，参照上面例子我们自定义的一个坐标数组，默认情况下每一个数组元素都代表了一个二维的数组，比如 `[0,100]` ，然而我们也可以告诉 `line generator ` 来如何自定义解读传入的数据，而这就要使用对应的 `accessor functions` 了。

至于 `line.y` 当然基本也是一样的概念，但是默认的 Y accessor为：

```javascript
function y(d) {
  return d[1];
}
</code></pre>
</blockquote>

<p>这也是为什么之前我们构造的坐标为什么是一个二维数组。</p>

<p>按照上面伪造的一周内降雨流量数据：（这里复制一次，便于阅读</p>

<pre><code class="language-javascript">// 一周内的降雨流量数据(伪造)
const data = [820, 932, 631, 934, 890, 1330, 1320]
</code></pre>

<p>我们来一步步解析一下 line 图表的生成方法：</p>

<ul>
<li>Y Axis 上需要设置最小值和最大值（最大值可能会动态变化），根据数据实际情况计算出来 Y 轴坐标</li>
<li>x Axis 上需要设置一周内的日期或者周一至周日，这 7 天的 x 轴坐标为了美观必须是等分的，所以计算出来对应 X 轴坐标</li>
</ul>

<p>通过简单的上诉两个步骤，我们就能得到数据实际对应的二维坐标，这样才能生成 Path Data，绘制 line chart。</p>

<pre><code class="language-javascript">import React, { Component } from 'react'
import * as d3 from 'd3-shape'
import {
  ART,
  View,
} from 'react-native';

const {
  Surface,
  Group,
  Shape,
} = ART;

const data = [
  { &quot;data&quot;: &quot;Mon&quot;, &quot;value&quot;: 820 },
  { &quot;data&quot;: &quot;Tue&quot;, &quot;value&quot;: 932 },
  { &quot;data&quot;: &quot;Wed&quot;, &quot;value&quot;: 631 },
  { &quot;data&quot;: &quot;Thu&quot;, &quot;value&quot;: 934 },
  { &quot;data&quot;: &quot;Fri&quot;, &quot;value&quot;: 890 },
  { &quot;data&quot;: &quot;Sat&quot;, &quot;value&quot;: 1330 },
  { &quot;data&quot;: &quot;Sun&quot;, &quot;value&quot;: 1320 }
]

const CHART_WIDTH = 375
const CHART_HEIGHT = 300

const X_AXIS_OFFSET = 50
const MAX_Y_AXIS = 1600
const MIN_Y_AXIS = 0

const lineGenerator = d3.line()
  .x((d, i) =&gt; i * X_AXIS_OFFSET)
  .y(d =&gt; CHART_HEIGHT - CHART_HEIGHT * Math.min(1, (d.value / MAX_Y_AXIS)))
  .curve(d3.curveCardinal);

const path = lineGenerator(data)

export default class ReactNativeART extends Component {
  render() {

    return (
      &lt;View&gt;
        &lt;Surface width={CHART_WIDTH} height={CHART_HEIGHT}&gt;
          &lt;Group&gt;
            &lt;Shape
              d={path}
              stroke=&quot;#000&quot;
              strokeWidth={1}
            /&gt;
          &lt;/Group&gt;
        &lt;/Surface&gt;
      &lt;/View&gt;
    )
  }
}
</code></pre>

<p>上述代码当中，我们定义了一些常用的常量：</p>

<ul>
<li>图表的高度：<code>CHART_HEIGHT</code></li>
<li>Y 轴最大值：<code>MAX_Y_AXIS</code></li>
<li>X 轴每一项的等分距离：<code>X_AXIS_OFFSET</code></li>
</ul>

<p>实际生产的二维坐标为：</p>

<pre><code class="language-javascript">[[0,146.25],[50,125.25],[100,131.0625],[150,124.875],[200,58.125],[250,50.625],[300,52.5]]
</code></pre>

<p>根据坐标生成 Path Data 绘制出来的图表为：</p>

<p><img src="./ARTCurve.png" alt="Art Line Chart One" /></p>

<p>一个基本的 line 图表就这样生成了，接下来我们做一些美化操作：</p>

<ul>
<li>添加 Point</li>
<li>添加 X 和 Y 轴的坐标和label</li>
</ul>

<p>我们可以通过 <code>ART.Path</code> 来绘制圆形来模拟 Point：</p>

<pre><code class="language-javascript">  renderPoints(data) {

    const pointArc = 3
    return data.map((d, i) =&gt; {

      if (i === 0) return null
      
      return (
        &lt;Shape
          key={i}
          d={new Path()
            .moveTo(X_AXIS_OFFSET * i, CHART_HEIGHT - pointArc - CHART_HEIGHT * Math.min(1, (d.value / MAX_Y_AXIS)))
            .arc(0, 2 * pointArc, pointArc)
            .arc(0, -2 * pointArc, pointArc)
            .close()
          }
          strokeWidth={0}
          stroke={'#9573D4'}
          fill={'#f00'}
        /&gt;
      )
    })
  }
</code></pre>

<p>绘制结果如下：</p>

<p><img src="./ArtCurveWithPoints.png" alt="ART curve with points" /></p>

<p>接下来实现 X 轴和 Y 轴。</p>

<blockquote>
<p>注意这个 Y 轴需要固定在左侧，所以 Y 轴 需要使用 RN 的 Text 绝对定位在 ScrollView 的左侧</p>
</blockquote>

<pre><code class="language-javascript"> renderYAxis(data) {
    const split = 6
    return new Array(split).fill(null).map((d, i) =&gt; {
      if (i === 0) return null
      return &lt;Text
        key={i}
        style={{
          position: 'absolute',
          fontSize: 12,
          color: '#000',
          left: '3%',
          backgroundColor: 'transparent',
          top: CHART_HEIGHT - (i / split) * CHART_HEIGHT
        }}
        alignment={'center'}
      &gt;
        {String((i / split) * MAX_Y_AXIS)}
      &lt;/Text&gt;
    })
  }

  renderXAxis(data) {

    return data.map((d, i) =&gt; {
      return &lt;ART.Text
        key={i}
        fill={'#000'}
        font={`normal 12px Heiti SC`}
        x={i * X_AXIS_OFFSET + 12}
        y={CHART_HEIGHT - 12}
        alignment={'center'}
      &gt;
        {d.data}
      &lt;/ART.Text&gt;
    })
  }
  render() {

    return (
      &lt;View
        style={{
          position: 'relative',
          width: Dimensions.get('window').width,
          height: CHART_HEIGHT
        }}
      &gt;
        &lt;ScrollView
          bounces={false}
          showsHorizontalScrollIndicator={false}
          horizontal
        &gt;
          &lt;Surface
            width={CHART_REAL_WIDTH}
            height={CHART_HEIGHT}
          &gt;
            &lt;Group&gt;
              {this.renderLine(data)}
              {this.renderPoints(data)}
              {this.renderXAxis(data)}
            &lt;/Group&gt;
          &lt;/Surface&gt;
        &lt;/ScrollView&gt;
        {this.renderYAxis(data)}
      &lt;/View&gt;
    )
  }
</code></pre>

<p><img src="./ArtCurveWithAxis.png" alt="Art curve with axis" /></p>

<p>这个图表看起来似乎很单调，我们添加一些 area fill 效果。</p>

<p>这里采用 D3 area 生成 area fill 图形，并且以 <code>ART.LinearGradient</code> 来 fill 渐变色。</p>

<pre><code class="language-javascript">renderPath(data) {
    const areaGenerator = d3.area()
      .x((d, i) =&gt; i * X_AXIS_OFFSET)
      .y0(CHART_HEIGHT)
      .y1(d =&gt; CHART_HEIGHT - CHART_HEIGHT * Math.min(1, (d.value / MAX_Y_AXIS)))
      .curve(d3.curveMonotoneX);

    return &lt;Shape
      d={areaGenerator(data)}
      fill={new LinearGradient({
          '0': '#875CD5',
          '.88': '#A084D4'
        }, 0, 0, 0, CHART_HEIGHT
      )}
      strokeWidth={1}
    /&gt;
  }
</code></pre>

<p>得到效果如下：</p>

<p><img src="./ArtCurveWithGradient.png" alt="Art curve chart with gradient " /></p>

<p>同样的道理，我们可以添加 背景色渐变，更改 X、Y 轴的字体颜色来进一步美化图表，最终效果如下图：</p>

<p><img src="./ArtCurveChartFinal.png" alt="Art curve chart final" /></p>

<p>完整代码可以再 <a href="https://gist.github.com/V-Tom/5e441cba9d3a8ef1366997fff6a64606">GitHub gist</a> 上找到</p>

<blockquote>
<p>似乎这个 chart 有点单调，生硬，我们需要添加一些动画、过渡效果</p>

<p>TODO</p>
</blockquote>

<h3 id="reference">Reference</h3>

<ul>
<li><a href="https://github.com/sebmarkbage/art">sebmarkbage ART</a></li>
<li><a href="https://github.com/reactjs/react-art">React-Art </a></li>
<li><a href="https://github.com/react-native-community/react-native-svg">react-native-svg</a> 让ART支持所有svg标签。</li>
<li><a href="https://github.com/matc4/react-native-svg-uri">react-native-svg-uri</a> 依赖上面的<code>react-native-svg</code>让<code>&lt;Image&gt;</code>标签的source可使用svg的uri。</li>
<li><a href="https://github.com/oblador/react-native-progress">react-native-progress</a> ART做的进度条组件。</li>
<li><a href="https://medium.com/the-react-native-log/animated-charts-in-react-native-using-d3-and-art-21cd9ccf6c58">Animated Charts in React Native using D3 and ART</a></li>
</ul>

    </section>
    <nav class="no-print post-nav">
        
        <a class="prev-post" href="https://t-tom.me/blog/2017-11-02-react-%E6%A8%A1%E5%BC%8F%E6%8A%80%E5%B7%A7%E6%8A%80%E5%B7%A7%E5%92%8C%E7%AA%8D%E9%97%A8/">
            <img class="icon-text" src="/img/prev.svg"/>React 模式，技巧，技巧和窍门</a>
        
        
        <a class="next-post" href="https://t-tom.me/blog/2018-04-02-%E4%BB%8Ejwt%E5%88%B0oauth/">从jwt到OAuth<img class="icon-text" src="/img/next.svg"/>
        </a>
        
    </nav>
</article>
<script src="/js/bundle.js"></script>



<div id="disqus_thread" class="no-print"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'toms-blog-1';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				
<a href="mailto:iamnomand@gmail.com"><img class="icon-social" src="/img/email.svg" alt="Email Me!"/></a>


<a href="https://github.com/v-tom/"><img class="icon-social" src="/img/github.svg" alt="Github"/></a>


<a href="https://twitter.com/iamnomand"><img class="icon-social" src="/img/twitter.svg" alt="Twitter"/></a>

<a href="https://t-tom.me/index.xml" target="_blank"><img class="icon-social" src="/img/feed.svg" alt="Feed"></a>

				<p>
					
					
					&copy; 2017~2018 TOM's Zone
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
		<script>hljs.initHighlightingOnLoad();</script>
		
	</body>
</html>

