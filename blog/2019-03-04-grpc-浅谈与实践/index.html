<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="Keywords" content="">
    <meta name="full-screen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#006cb4">
    <meta name="apple-mobile-web-app-title" content="TOM&#39;s zone">
    <meta name="description" content="TOM&#39;s zone">
    <link rel="dns-prefetch" href="https://hasaki.xyz">
    <link rel="preconnect" href="https://hasaki.xyz">
    <link rel="manifest" href="/sw/manifest.json"/>
<title>gRPC 浅谈与实践 - TOM&#39;s zone</title>

<meta name="description" content="由于不同的环境下面的例子可能会存在一些误差，下面列出本机环境：
 Docker -v ：Docker version 18.09.1, build 4c52b90 docker-compose -v ：docker-compose version 1.23.2, build 1110ad01 go version : go version go1.12.4 darwin/amd64 system_profiler SPSoftwareDataType : macOS 10.14.3 (18D42) Darwin 18.2.0 IDE golang latest  RPC RPC 全名为 Remote procedure call ,直译过来就是 远程过程调用 ，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。
调用的基本流程可以看下图：
RPC 的协议可以简单分成两大类。
一类是通讯层协议，通讯层协议一般是和业务无关的，它的职责是将业务数据打包后，安全、完整的传输给接受方，HSF、Dubbo、gRPC 这些都是属于通讯层协议。
另一类是应用层协议。约定业务数据和二进制串的转换规则，常见的应用层协议有 Hessian，Protobuf，JSON。
why RPC 为什么RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如比如不同的系统间的通讯，甚至不同的组织间的通讯。由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用，
http vs RPC HTTP 调用其实也是一种特殊的 RPC 。RPC 可以基于 HTTP 协议实现，也可以直接在 TCP 协议上实现。
 HTTP 与 RPC 的关系就好比普通话与方言的关系，普通话效率不高，废话较多，但是胜在通用。方言用的人少，短小精炼，理解起来也较为困难（保密性好），效率高。">




    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">


    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/ocean.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/javascript.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/python.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/css.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/swift.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/objectivec.min.js"></script>


    <link rel="stylesheet" href="/css/bundle.min.css"/>
<script src="/js/bundle.min.js"></script>
<style>
	a { color: #ff8181; }
	blockquote {
		border-left-color: #ff8181;
		border-right-color: #ff8181; }
	.bar a:hover {
		color: #ff8181;
		text-decoration: none; }
	.sep {
		margin-top: 2rem;
		margin-bottom: 1rem;
		margin-left:0;
		width: 24rem;
		border-top: 2px solid #ff8181; }
    .bar li.active a{
        color:#ff8181;
    }
</style>

</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li>
		
		<li class="active"><a href="/blog/">Blog</a></li></ul>
</nav>

	</div>
</header>
<main class="container">

<article>
    <header><hgroup id="brand">
	<h1>gRPC 浅谈与实践</h1>
	<h5>
		
		<time datetime="2019-03-04 11:32:40 &#43;0800 CST">Mar 04, 2019</time>
		<span class="no-print">
			-
			
			<a href="/tags/docker">Docker</a>
			
			<a href="/tags/golang">Golang</a>
			
			<a href="/tags/backend">BackEnd</a>
			</span>
	</h5>

	
	
	
</hgroup>
<hr class="sep" /></header>
    <section id="markdown">
        

<p>由于不同的环境下面的例子可能会存在一些误差，下面列出本机环境：</p>

<ul>
<li><code>Docker -v</code> ：Docker version 18.09.1, build 4c52b90</li>
<li><code>docker-compose -v</code> ：docker-compose version 1.23.2, build 1110ad01</li>
<li><code>go version</code> : go version go1.12.4 darwin/amd64</li>
<li><code>system_profiler SPSoftwareDataType</code> : macOS 10.14.3 (18D42) Darwin 18.2.0</li>
<li>IDE golang latest</li>
</ul>

<h2 id="rpc">RPC</h2>

<p>RPC 全名为 <code>Remote procedure call</code> ,直译过来就是 <strong>远程过程调用</strong> ，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p>

<p>调用的基本流程可以看下图：</p>

<p><img src="./rpc-process.png" alt="rpc-process.png" /></p>

<p>RPC 的协议可以简单分成两大类。</p>

<p>一类是通讯层协议，通讯层协议一般是和业务无关的，它的职责是将业务数据打包后，安全、完整的传输给接受方，HSF、Dubbo、gRPC 这些都是属于通讯层协议。</p>

<p>另一类是应用层协议。约定业务数据和二进制串的转换规则，常见的应用层协议有 Hessian，Protobuf，JSON。</p>

<h3 id="why-rpc">why RPC</h3>

<p>为什么RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如比如不同的系统间的通讯，甚至不同的组织间的通讯。由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用，</p>

<h3 id="http-vs-rpc">http vs RPC</h3>

<p>HTTP 调用其实也是一种特殊的 RPC 。RPC 可以基于 HTTP 协议实现，也可以直接在 TCP 协议上实现。</p>

<blockquote>
<p>HTTP 与 RPC 的关系就好比普通话与方言的关系，普通话效率不高，废话较多，但是胜在通用。方言用的人少，短小精炼，理解起来也较为困难（保密性好），效率高。</p>
</blockquote>

<p>HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 <code>KeepAlive</code> 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</p>

<p>但是 HTTP 还是存在很多硬伤，比如通用定义的 http1.1协议的 TCP 报文包含太多废信息、序列化效率不高，以及三次握手四次挥手带来的 RTT 延迟，以及 <code>Head of line blocking</code> 、服务端推送 等等。注定了在高性能要求的下，不适合用做线上分布式服务之间互相使用的通信协议。</p>

<p>当 HTTP 协议进化到 2.0 之后，Google 开源了一个建立在 HTTP2.0 协议之上的通信框架直接取名为 gRPC，也就是 Google RPC，这个 gRPC 也就是本文将要详细介绍的通信框架。</p>

<blockquote>
<p>需要注意的是，gRPC 由于协议还是基于 HTTP 2，HTTP 2 实际上也没有全部解决 HTTP 1 版本的问题，要不然就不会有 QUIC（HTTP3），只是在取舍之间选择了 HTTP 2 作为底层协议再封装 服务发现、 负载均衡 等高级 RPC 特征，这个具体会在下文详细分析</p>

<p>并且由于 gRPC 基于 HTTP 2 ，所以也是不支持 UDP 协议的，只能等待 HTTP 3</p>
</blockquote>

<h2 id="grpc">gRPC</h2>

<p>gRPC 是 google 开源的高性能跨语言的 RPC 方案，并且采用 HTTP 2 作为通信层协议。gRPC 的设计目标是在任何环境下运行，默认使用 protobuf 作为 接口描述语言 (IDL interface description language) 及底层消息通信格式。</p>

<p>支持可插拔的负载均衡，跟踪，运行状况检查和身份验证。</p>

<p>它不仅支持数据中心内部和跨数据中心的服务调用，它也适用于分布式计算的最后一公里，将设备，移动应用程序和浏览器连接到后端服务。</p>

<p>可以看这篇文章 <a href="https://grpc.io/blog/principles/">gRPC动机和设计原则</a></p>

<p>很多主流库以及设施已经在使用 gRPC，比如 k8s 、TensorFlow</p>

<p>在人工智能领域，RPC 也很重要，著名的 TensorFlow 框架如果需要处理上亿的数据，就需要依靠分布式计算力，需要集群化，当多个分布式节点需要集体智慧时，就必须引入 RPC 技术进行通讯。Tensorflow Cluster 的 RPC 通讯框架使用了 Google 内部自研的 gRPC 框架。</p>

<h3 id="protobuf">protobuf</h3>

<p>protobuf 是谷歌推出的一种轻便高效的结构化数据存储格式，把结构化的数据序列化。常用以存储数据、作为网络通信的数据载体。具有提供多种编程语言的 API、跨平台和可扩展的特性。比 JSON 和 XML 更小、解析速度更快、更易于程序员上手。</p>

<p>gRPC 采用 Protobuf 作为应用层协议。</p>

<p><a href="https://developers.google.com/protocol-buffers/">Protobuf</a> 是谷歌提出来的数据交换协议，使用方式可以查看对应文档各个语言的 tutorial 。</p>

<p>你需要在这里下载 <code>protoc binary file</code> 并确保可执行文件在 <code>PATH</code> 当中 : <a href="https://github.com/protocolbuffers/protobuf/releases">protobuf</a></p>

<p>或者也可以通过下面方式安装，默认装在了 <code>$GOPATH/bin</code> 之下，所以也要确保这个目录在 <code>PATH</code> 下：</p>

<pre><code class="language-sh">go get -u github.com/golang/protobuf/protoc-gen-go
</code></pre>

<h3 id="grpc-web">gRPC web</h3>

<p>准确来说 gRPC 设计上是分层的，底层支持不同的协议，下面是 gRPC 支持协议，我们要采用 gRPC web ：</p>

<ul>
<li><a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md">gRPC over HTTP2</a></li>
<li><a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md">gRPC Web</a></li>
</ul>

<p>由于我们是在 web 环境当中测试，所以需要额外下载对应的插件：<a href="https://github.com/grpc/grpc-web/releases">protoc-gen-grpc-web</a></p>

<h3 id="advantage-and-disadvantage">advantage and disadvantage</h3>

<p>我们现在知道 gRPC 是基于 HTTP 2 的，那它有什么优点呢？</p>

<ul>
<li>HTTP/2 是一个公开的标准，并且是一个经过实践检验的标准</li>
<li>HTTP/2 天然支持物联网、手机、浏览器</li>
<li>基于HTTP/2 多语言的实现容易，每个流行的编程语言都会有成熟的HTTP/2 Client</li>
<li>HTTP/2支持 Stream 和 流控</li>
<li>HTTP/2 天然支持 ssl</li>
<li>鉴权成熟，从HTTP/1发展起来的鉴权系统已经很成熟了，可以无缝用在HTTP/2上</li>
</ul>

<p>缺点呢？</p>

<ul>
<li>RPC 的元数据的传输不够高效</li>
<li>HTTP/2 标准本身是只有一个 TCP 连接，但是实际在 gRPC 里是会有多个 TCP 连接</li>
<li>gRPC 选择基于 HTTP/2，那么它的性能肯定不会是最顶尖的。但是对于 gRPC 来说中庸的 QPS 可以接受，通用和兼容性才是最重要的事情。</li>
</ul>

<h2 id="envoy-proxy">envoy proxy</h2>

<p>引用官网的一段描述：</p>

<pre><code class="language-txt">
Envoy is an L7 proxy and communication bus designed for large modern service oriented architectures. The project was born out of the belief that:
&quot;The network should be transparent to applications. When network and application problems do occur it should be easy to determine the source of the problem.&quot;

</code></pre>

<p><img src="./envoy.png" alt="envoy.png" /></p>

<p>具体详情请看本文尾部的 reference</p>

<h3 id="how-and-why">how and why</h3>

<p><a href="https://www.envoyproxy.io/">Envoy</a> 是作为一个主打 Service Mesh(微服务) 方案的 proxy，也是 <a href="https://www.cncf.io/">cloud native</a> 成员之一</p>

<p>为什么不选 nginx 呢？首先 Nginx 的反向代理早期不支持 http2/grpc ，其次 Nginx 的很多微服务功能都是要买 Nginx Plus 才有。</p>

<p>哈哈，对我个人来说还是因为官方推荐，以及深入理解 cloud native</p>

<h2 id="why-golang">why golang</h2>

<p>我们通过上面的介绍已经知道 gRPC 其实是支持多种语言进行开发，比如 <code>Node</code>，<code>Python</code>，<code>Java</code> 等等。</p>

<p>我还是采用了 golang 作为后端语言，主要原因是 golang 语法简单以及部署方便，相对来说易于上手开发</p>

<h2 id="hello-grpc-world">hello gRPC world</h2>

<p>接下来我们会一步步的实现一个简单的 gRPC web 实例</p>

<h3 id="tree">tree</h3>

<p>你可以在这里<a href="./grpc-demo.zip">下载</a>本文项目源代码。</p>

<p>然后我们先看一下当前目录结构：<code>tree -I node_modules</code></p>

<pre><code class="language-txt">
.
├── Docker-compose.yml
├── Dockerfile-envoy
├── Dockerfile-envoy-standalone
├── Dockerfile-server
├── README.md
├── envoy-standalone.yaml
├── envoy.yaml
├── protobuf-spec
│   └── helloworld.proto
├── script
│   ├── bootstrap.sh
│   ├── build-client.sh
│   ├── build-server.sh
│   ├── codegen-clinet.sh
│   ├── codegen-server.sh
│   ├── docker-envoy-standalone.sh
│   └── docker-compose.sh
├── server
│   ├── main.go
│   └── protobuf-spec
│       └── helloworld.pb.go
└── web
    ├── bundle.js
    ├── index.html
    ├── index.js
    ├── package.json
    ├── protobuf
    │   ├── user_grpc_web_pb.js
    │   └── user_pb.js
    └── webpack.config.js

6 directories, 24 files

</code></pre>

<h3 id="environment">environment</h3>

<p>首先我们需要准备本文开头列出的系统环境。</p>

<p>其次下载并以及对应的 <code>protobuf</code> 和 <code>protoc-gen-grpc-web</code> 插件，确保它们都是可执行文件：必须加入 <code>PATH</code> 当中。</p>

<p>根据上面的 tree 建立相应的文件目录即可：<code>script</code> 和 <code>protobuf-spec</code> 和 <code>server</code> 以及 <code>web</code>，其他的目录可选</p>

<h3 id="develop-it">develop it</h3>

<h4 id="define-protoc">define protoc</h4>

<p>首先我们创建一个 <code>protoc</code> 文件来定义 <code>gRPC service</code>：在 <code>protobuf-spec</code> 目录下面创建文件 <code>helloworld.proto</code>。</p>

<p>具体语法请查看 <a href="https://developers.google.com/protocol-buffers/">protocol-buffers</a>，在这文件当中我们定义了 <strong>请求信息</strong> 和 <strong>响应信息</strong>，以及提供了一个 RPC 服务：<code>SayHello</code>：</p>

<pre><code class="language-protoc">
syntax = &quot;proto3&quot;;

package helloworld;

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}

</code></pre>

<p>接下来我们根据定义的 <code>helloworld.proto</code> 文件生成对应的客户端、服务端工作区源代码。</p>

<h4 id="web-code">web code</h4>

<p>首先准备好 <code>web</code> 文件目录，我们准备在这个目录下建立一个 webpack-dev-server 来辅助测试与开发</p>

<p>建立 <code>package.json</code>：</p>

<pre><code class="language-json">
{
  &quot;name&quot;: &quot;web&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;bundle.js&quot;,
  &quot;scripts&quot;: {
    &quot;protobuf:web&quot;: &quot;npx webpack-dev-server --config ./webpack.config.js --watch --port 8081&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot; MIT&quot;,
  &quot;dependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.30.0&quot;,
    &quot;webpack-dev-server&quot;: &quot;^3.3.1&quot;,
    &quot;google-protobuf&quot;: &quot;^3.6.1&quot;,
    &quot;grpc-web&quot;: &quot;^0.4.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;webpack-cli&quot;: &quot;^3.3.1&quot;
  }
}

</code></pre>

<p><code>index.html</code> 文件</p>

<pre><code class="language-html">&lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>以及 <code>webpack.confg.js</code> 文件：</p>

<pre><code class="language-js">
const path = require('path');

module.exports = {
    entry: path.join(__dirname, './index.js'),
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname)
    }
};

</code></pre>

<p>以及最后一个空白的 <code>index.js</code> 来作为代码入口和 webpack 打包入口，最后我们安装 web 依赖：<code>npm i -d</code> 或者 <code>npm i -d --registry=https://registry.npm.taobao.org</code></p>

<p>生成代码我们可以建立 <code>script/codegen-client.sh</code>，不要忘记 <code>chmod +x -R ./script</code>：</p>

<pre><code class="language-sh">
#!/usr/bin/env bash

set -e

proto=$1

if [ -z &quot;$proto&quot; ];then
    echo &quot;please prompt at last one argument for input file&quot;
    exit
fi

# web
rm -rf ./web/protobuf &amp;&amp; mkdir ./web/protobuf

OUT_DIR=./web/protoc-spec

protoc -I=./protobuf-spec $proto.proto \
    --js_out=import_style=commonjs:$OUT_DIR \
    --grpc-web_out=import_style=commonjs,mode=grpcwebtext:$OUT_DIR

echo &quot;generate client success in directory : $OUT_DIR&quot;

</code></pre>

<p>执行 <code>./script/codegen-client.sh hello</code> 在 <code>./web/protoc-spec</code> 目录下生成文件。</p>

<blockquote>
<p>注意第一个参数 <code>hello</code> 是指在 <code>./protobuf-spec</code> 目录当中我们定义的 <code>protoc</code> 文件文件名简写</p>
</blockquote>

<p>接下来来完善我们的 <code>index.js</code>：</p>

<pre><code class="language-js">
const {HelloRequest} = require('./protobuf/helloworld_pb');
const {GreeterClient} = require('./protobuf/helloworld_grpc_web_pb');

const client = new GreeterClient('http://localhost:9090');

const request = new HelloRequest();
request.setName('gRPC World');

client.sayHello(request, {}, (err, response) =&gt; {
    if (err) throw err;
    console.log(response.getMessage());
});

</code></pre>

<h4 id="golang-code">golang code</h4>

<p>golang 上的准备比较简单，首先准备好 <code>GOPATH</code> 在你当前的工作目录下，然后建立 <code>server</code> 目录：</p>

<pre><code class="language-sh">
go get -u google.golang.org/grpc

</code></pre>

<p>在 <code>server</code> 目录下建立我们的空白服务入口文件 <code>main.go</code></p>

<p>同样和 web 一样建立 <code>./script/codegen-server.sh</code> ：</p>

<pre><code class="language-sh">
#!/usr/bin/env bash

set -e

proto=$1

if [ -z &quot;$proto&quot; ];then
    echo &quot;please prompt at last one argument for input file&quot;
    exit
fi

# server
rm -rf ./server/protobuf-spec &amp;&amp; mkdir ./server/protobuf-spec

protoc --go_out=plugins=grpc:./server ./protobuf-spec/$proto.proto

echo &quot;generate server code success with ./server/protobuf-spec/$proto.pb.go&quot;

</code></pre>

<p>执行后我们会在 <code>./server/protobuf-spec/</code> 下得到对应的代码</p>

<p>接下来完善我们的 server 也就是 <code>main.go</code> 文件来实现 gPRC :</p>

<pre><code class="language-go">
package main

import (
	&quot;context&quot;
	&quot;log&quot;
	&quot;net&quot;
    &quot;google.golang.org/grpc&quot;
	// 注意：这里引入生成后的代码，具体路径要根据你的 GOPATH 来定
	pb &quot;grpc/server/protobuf-spec&quot;
)

const (
	port = &quot;:8080&quot;
)

// server is used to implement helloworld.GreeterServer.
type server struct{}

// SayHello implements helloworld.GreeterServer.
func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
	log.Printf(&quot;Received: %v&quot;, in.Name)
	return &amp;pb.HelloReply{Message: &quot;Hello &quot; + in.Name}, nil
}

func main() {
	lis, err := net.Listen(&quot;tcp&quot;, port)

	if err != nil {
		log.Fatalf(&quot;failed to listen: %v&quot;, err)
	}
	s := grpc.NewServer()
	pb.RegisterGreeterServer(s, &amp;server{})
	if err := s.Serve(lis); err != nil {
		log.Fatalf(&quot;failed to serve: %v&quot;, err)
	}
}

</code></pre>

<h3 id="run-it">run it</h3>

<p>在启动我们的 gRPC web 之前我们需要配置好 <code>envoy</code> 代理，先建立 <code>envoy-standalone.yaml</code> 文件：</p>

<pre><code class="language-yaml">
static_resources:
  listeners:
    - name: listener_0
      address:
        socket_address: { address: 0.0.0.0, port_value: 9090 }
      filter_chains:
        - filters:
            - name: envoy.http_connection_manager
              config:

                # print access log to stdout
                access_log:
                  - name: envoy.file_access_log
                    config:
                      path: &quot;/dev/stdout&quot;

                codec_type: auto
                stat_prefix: ingress_http
                route_config:
                  name: local_route
                  virtual_hosts:
                    - name: local_service
                      domains: [&quot;*&quot;]
                      routes:
                        - match: { prefix: &quot;/&quot; }
                          route:
                            cluster: echo_service
                            max_grpc_timeout: 0s
                      cors:
                        allow_origin:
                          - &quot;*&quot;
                        allow_methods: GET, PUT, DELETE, POST, OPTIONS
                        allow_headers: keep-alive,user-agent,cache-control,content-type,content-transfer-encoding,custom-header-1,x-accept-content-transfer-encoding,x-accept-response-streaming,x-user-agent,x-grpc-web,grpc-timeout
                        max_age: &quot;1728000&quot;
                        expose_headers: custom-header-1,grpc-status,grpc-message
                        enabled: true
                http_filters:
                  - name: envoy.grpc_web
                  - name: envoy.cors
                  - name: envoy.router
  clusters:
    - name: echo_service
      connect_timeout: 0.25s
      type: logical_dns
      http2_protocol_options: {}
      lb_policy: round_robin

      # container access host
      # https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container/31328031

      hosts: [{ socket_address: { address: host.docker.internal, port_value: 8080 }}]

admin:
  access_log_path: /tmp/admin_access.log
  address:
    socket_address: { address: 0.0.0.0, port_value: 9091 }

</code></pre>

<blockquote>
<p>如果你之前仔细看过文件目录结构，你会发现有后缀为 <code>standalone</code> envoy 的配置文件。因为本地开发的时候我们的 server 在 docker 容器之外开发比较方便，所以需要把 envoy 单独处理。</p>
</blockquote>

<p>建立 <code>./script/build-client.sh</code> 来启动我们的 web 服务：</p>

<pre><code class="language-sh">
#!/usr/bin/env bash

set -e

cd ../web

npx webpack-dev-server --config ./webpack.config.js --watch --port 8081

</code></pre>

<p>和 <code>./script/docker-envoy-standalone.sh</code> 来方便我们启动 envoy docker 服务</p>

<pre><code class="language-sh">
#!/usr/bin/env bash

set -e

containerName=grpc_envoy_standalone

if [  &quot;$(docker ps -q -f name=grpc_envoy_standalone)&quot; ]; then
    docker container rm $containerName -f
fi


docker build -t grpc_envoy_standalone -f ./Dockerfile-envoy-standalone .

docker run -d -p 9090:9090 -p 9091:9091 --name $containerName grpc_envoy_standalone

</code></pre>

<p>最后 <code>go run ./server/main.go</code> 来启动 server</p>

<p>我们可以在浏览器端访问 <code>localhost:8081</code>，可以在 console 控制台上看到打印出来的 <code>hello gRPC world</code></p>

<blockquote>
<p>具体流程可以大致解释为：8081 为 webpack-dev-server 服务，然后客户端请求 envoy 容器抛出的 9090 端口提供的 restful 服务，envoy 转发到 8080 端口 server 服务上，然后 server 处理后交给 envoy 返回数据。</p>
</blockquote>

<h3 id="deploy-it">deploy it</h3>

<p>上面的例子只是用来本地开发和 debug，真正部署的时候这里由于复杂度没有采用 k8s 而是简单采用了 <code>docker-compose</code> 作为容器编排，我们先建立 <code>docker-compose.yml</code> ：</p>

<pre><code class="language-dockerfile">
version: '3'

services:

  envoy:
    build:
      context: .
      dockerfile: Dockerfile-envoy
    ports:
      - '9090:9090'
      - '9091:9091'
    networks:
      - grpc

  server:
    build:
      context: .
      dockerfile: Dockerfile-server
    #    ports:
    #      - '8080:8080'
    networks:
      - grpc

networks:
  grpc:

</code></pre>

<p>在该文件当中我们指定了 <code>Dockerfile-envoy</code></p>

<pre><code class="language-dockerfile">
FROM envoyproxy/envoy:latest

ADD ./envoy.yaml /etc/envoy.yaml

CMD /usr/local/bin/envoy -c /etc/envoy.yaml

</code></pre>

<p>和 <code>Dockerfile-server</code> 来作为 build entry</p>

<pre><code class="language-dockerfile">
FROM alpine

ADD server/server /app/server

ENTRYPOINT [ &quot;/app/server&quot; ]

</code></pre>

<p>以及 <code>envoy-yaml</code> 来作为 envoy 的 docker-compose 配置文件，这个文件基本上和上面的 <code>envoy-standalone.yaml</code> 一致，只需要修改关键字符串 <code>host.docker.internal</code> 为我们 docker 编排的容器名称 <code>server</code> 就可以了。</p>

<p>建立 <code>./script/build-server.sh</code> 来生成编译我们的服务器：</p>

<pre><code class="language-sh">#!/usr/bin/env bash

set -e

cd $(dirname $0)/..

export GOOS=linux
export GOARCH=amd64
export CGO_ENABLED=0

go build -o ./server/server ./server

</code></pre>

<p>最后直接运行：</p>

<pre><code class="language-sh">
./script/build-server.sh

docker network create grpc

docker-compose pull

docker-compose up --build

</code></pre>

<p>这样我们就简单成功部署成功了 gRPC 服务</p>

<h2 id="think-in-further">think in further</h2>

<p>RPC 框架目前据我所知除了 gRPC 有很多实现，阿里的 java double ，百度的 c++ incubator-brpc，twitchTV 的 go twirp，以及 windows c++ thrift 等等，各有各的优点、缺点，以及擅长处理的痛点。在我看来，没有银弹，性能，接口，易用性都要进行权衡，也要结合实际项目环境去选择。</p>

<h2 id="reference">reference</h2>

<ul>
<li><a href="https://www.zhihu.com/question/41609070/answer/191965937">既然有了 http 请求为什么还要有 RPC</a></li>
<li><a href="https://www.yuque.com/egg/nodejs/dklip5">聊聊 Node RPC</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI4NzEyMjUxMA==&amp;mid=2649068604&amp;idx=1&amp;sn=9d34b782a5d7c147e108f1af1c0fbc23&amp;chksm=f3c3411dc4b4c80b7e8a72013a7b884e21814f6bcbc6f0ea8752ff6c434b93005efc854520ef&amp;xtrack=1&amp;scene=0&amp;subscene=131&amp;clicktime=1552095539&amp;ascene=7&amp;devic">QUIC 简介</a></li>
<li><a href="https://blog.csdn.net/hengyunabc/article/details/81120904">思考gRPC ：为什么是HTTP/2</a></li>
<li><a href="https://github.com/grpc/grpc-web/blob/master/net/grpc/gateway/examples/helloworld/README.md">grpc-web github hellowolrd example</a></li>
<li><a href="https://juejin.im/post/5ad6fb06518825364001f619">envoy 快速入门</a></li>
<li><a href="http://jm.taobao.org/2018/07/05/Mesh%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84Envoy/">浅谈Service Mesh体系中的Envoy</a></li>
</ul>

    </section>
    <nav class="no-print post-nav">
        
        <a class="prev-post" href="https://hasaki.xyz/blog/2019-02-12-%E4%BD%BF%E7%94%A8-nextcloud-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%A7%81%E6%9C%89%E7%BD%91%E7%9B%98/">
            <img class="icon-text" src="/img/prev.svg"/>使用 nextcloud 搭建个人私有网盘</a>
        
        
    </nav>
</article>



<div id="disqus_thread" class="no-print"></div>
<script type="text/javascript">
    'use strict';
    (function () {
        if ('localhost' != window.location.hostname) {
            var a = document.querySelector('#disqus_thread');
            new IntersectionObserver(function (b) {
                b.forEach(function (d) {
                    if (0 < d.intersectionRatio && !a.classList.contains('active')) {
                        var e = document.createElement('script');
                        e.type = 'text/javascript', e.async = !0;
                        e.src = '//' + 'hasaki-xyz' + '.disqus.com/embed.js', (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(e), a.classList.add('active')
                    }
                })
            }, {rootMargin: '0px', threshold: 1}).observe(a)
        }
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>


<style rel="catalog">
    #catalog {
        position: fixed;
        left: 3vw;
        top: 8vh;
    }

    .cl-wrapper {
        position: relative;
    }

    .cl-wrapper ul, .cl-wrapper li {
        margin: 0;
        -moz-padding-start: 12px;
        -webkit-padding-start: 12px;
        list-style: none;
    }

    .cl-wrapper li > .cl-link.cl-link-active {
        color: #ff8181;
        transition: .5s;
    }

    .cl-wrapper li > .cl-transform.cl-link-active {
        transform: translate(3px);
    }

    .cl-wrapper .cl-link {
        cursor: pointer;
        color: rgba(52, 73, 94, 0.5);
        font-size: 13px;
        transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
    }

    .cl-wrapper .cl-marker {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
    }

    .cl-wrapper .cl-marker path {
        transition: all 0.3s ease;
    }
</style>
<main id="catalog"></main>
<script rel="catalog">
    void function () {
        
        if (window.innerWidth < 1024 || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
            return
        }

        const Catalog = (function () {
            return function (opts) {
                let defaultOpts = {
                    linkClass: 'cl-link',                             
                    linkActiveClass: 'cl-link-active',                
                    datasetName: 'data-cata-target',                  
                    selector: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],   
                    scrollWrapper: null,                              
                    activeHook: null,                                 
                    topMargin: 0,
                    bottomMargin: 0,
                    cool: true                                        
                }

                const Opt = Object.assign({}, defaultOpts, opts)

                const $content = document.getElementById(Opt.contentEl)                          
                const $scroll_wrap = window   
                const $catalog = document.getElementById(Opt.catalogEl)                          

                let allCatalogs = $content.querySelectorAll(Opt.selector.join())
                let tree = getCatalogsTree(allCatalogs)

                try {
                    $catalog.innerHTML = `<div class='cl-wrapper'>${generateHtmlTree(tree, {id: -1})}<svg class="cl-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
            <path stroke="#ff8181" stroke-width="3" fill="transparent" stroke-dasharray="0, 0, 0, 1000" stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)" />
            </svg></div>`
                } catch (e) {
                    console.error('error in progress-catalog', e)
                }


                const tocPath = $catalog.querySelector('.cl-marker path')
                let tocItems, pathLength    

                
                window.addEventListener('resize', drawPath)
                $catalog.addEventListener('click', clickHandler)
                Opt.cool && $scroll_wrap.addEventListener('scroll', coolScrollHandler)
                Opt.cool || $scroll_wrap.addEventListener('scroll', simpleScrollHandler)

                setTimeout(drawPath)          

                

                function drawPath() {
                    tocItems = [...$catalog.querySelectorAll('li')]
                    tocItems = tocItems.map(function (liDom) {
                        const anchor = liDom.querySelector(`.${Opt.linkClass}`)
                        const target = document.getElementById(anchor.getAttribute('data-cata-target'))

                        return {
                            listItem: liDom,
                            anchor: anchor,
                            target: target
                        }
                    })
                    tocItems = tocItems.filter(item => !!item.target)

                    const path = []
                    let pathIndent

                    tocItems && tocItems.forEach(function (item, idx) {
                        const {offsetLeft, offsetTop, offsetHeight} = item.anchor,
                            x = Opt.cool ? offsetLeft - 5 : offsetLeft,
                            y = offsetTop,
                            height = offsetHeight

                        if (idx === 0) {
                            path.push('M', x, y, 'L', x, y + height)
                            item.pathStart = 0
                        }
                        else {
                            if (pathIndent !== x) path.push('L', pathIndent, y)     
                            path.push('L', x, y)
                            tocPath.setAttribute('d', path.join(' '))
                            item.pathStart = tocPath.getTotalLength() || 0
                            path.push('L', x, y + height)
                        }
                        pathIndent = x
                        tocPath.setAttribute('d', path.join(' '))
                        item.pathEnd = tocPath.getTotalLength()
                    })
                    pathLength = tocPath.getTotalLength()
                    coolScrollHandler()
                }

                

                function coolScrollHandler() {
                    const wrapHeight = document.documentElement.offsetHeight
                    let pathStart = pathLength,
                        pathEnd = 0,
                        visibleItems = 0
                    tocItems.forEach(function (liItem) {
                        const {bottom, top} = liItem.target.getBoundingClientRect(),
                            firstChild = liItem.listItem.firstChild
                        if (bottom > Opt.topMargin && top < wrapHeight - Opt.bottomMargin) {
                            firstChild.classList.remove(Opt.linkActiveClass)
                            Opt.cool && firstChild.classList.remove('cl-transform')
                        } else {
                            pathStart = Math.min(liItem.pathStart, pathStart)
                            pathEnd = Math.max(liItem.pathEnd, pathEnd)
                            visibleItems += 1
                            firstChild.classList.add(Opt.linkActiveClass)
                            Opt.cool && firstChild.classList.add('cl-transform')
                        }
                    })
                    if (visibleItems > 0 && pathStart < pathEnd && Opt.cool) {
                        tocPath.setAttribute('stroke-dashoffset', '1')
                        tocPath.setAttribute('stroke-dasharray', `1, ${pathStart}, ${pathEnd - pathStart}, ${pathLength}`)
                        tocPath.setAttribute('opacity', '1')
                    }
                    else {
                        tocPath.setAttribute('opacity', '0')
                    }
                }

                

                function simpleScrollHandler(el) {
                    let scrollToEl = null
                    for (let i = allCatalogs.length - 1; i >= 0; i--) {
                        if (allCatalogs[i].offsetTop <= $scroll_wrap.scrollTop) {
                            scrollToEl = allCatalogs[i]
                            break
                        }
                    }
                    if (scrollToEl) setActiveItem(scrollToEl.id)
                    else setActiveItem(null)            
                }

                

                function clickHandler({target}) {
                    const datasetId = target.getAttribute(Opt.datasetName)
                    target.classList.contains(Opt.linkClass) &&
                    document.getElementById(datasetId)
                        .scrollIntoView({behavior: "smooth", block: "start"})
                }

                

                function getCatalogsTree(catalogs) {
                    let title, tagName, tree = [], treeItem = {}, parentItem = {id: -1}, lastTreeItem = null, id

                    for (let i = 0; i < catalogs.length; i++) {
                        title = catalogs[i].innerText || catalogs[i].textContent
                        tagName = catalogs[i].tagName
                        id = 'heading-' + i
                        catalogs[i].id = id
                        treeItem = {
                            name: title,
                            tagName: tagName,
                            id: id,
                            level: +getLevel(tagName),
                            parent: parentItem
                        }
                        if (lastTreeItem) {
                            if (getLevel(treeItem.tagName) > getLevel(lastTreeItem.tagName)) {
                                treeItem.parent = lastTreeItem
                            } else {
                                treeItem.parent = findParent(treeItem, lastTreeItem)
                            }
                        }
                        lastTreeItem = treeItem
                        tree.push(treeItem)
                    }
                    return tree
                }

                

                function findParent(currTreeItem, lastTreeItem) {
                    let lastTreeParent = lastTreeItem.parent
                    while (lastTreeParent && (getLevel(currTreeItem.tagName) <= getLevel(lastTreeParent.tagName))) {
                        lastTreeParent = lastTreeParent.parent
                    }
                    return lastTreeParent || {id: -1}
                }

                

                function getLevel(tagName) {
                    return tagName ? tagName.slice(1) : 0
                }

                

                function generateHtmlTree(tree, _parent) {
                    let ul, hasChild = false
                    if (tree) {
                        ul = `<ul>`
                        for (let i = 0; i < tree.length; i++) {
                            if (isEqual(tree[i].parent, _parent)) {
                                hasChild = true
                                ul += `<li><div class='${ Opt.linkClass } cl-level-${ tree[i].level }' ${Opt.datasetName}='${ tree[i].id }'>${tree[i].name}</div>`
                                ul += generateHtmlTree(tree, tree[i])
                                ul += '</li>'
                            }
                        }
                        ul += `</ul>`
                    }
                    return hasChild ? ul : ''
                }

                /**
                 * 判断是否是相同节点
                 */
                function isEqual(node, node2) {
                    return node && node2 && typeof node === 'object' && typeof node2 === 'object' && node.id === node2.id
                }

                /**
                 *  设置选中的项
                 */
                function setActiveItem(id) {
                    let catas = [...$catalog.querySelectorAll(`[${Opt.datasetName}]`)]

                    catas.forEach(T => {
                        if (T.getAttribute(Opt.datasetName) === id) {
                            typeof Opt.activeHook === 'function' &&
                            !T.classList.contains(Opt.linkActiveClass) &&
                            Opt.activeHook.call(this, T)                    // 执行active钩子
                            T.classList.add(Opt.linkActiveClass)
                        } else {
                            T.classList.remove(Opt.linkActiveClass)
                        }
                    })
                }
            }
        })();
        window.addEventListener('DOMContentLoaded', _ => new Catalog({
            contentEl: 'markdown',
            catalogEl: 'catalog'
        }))
    }();
</script>
			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				
<a href="mailto:iamnomand@gmail.com"><img class="icon-social" src="/img/email.svg" alt="Email Me!"/></a>


<a href="https://github.com/v-tom/"><img class="icon-social" src="/img/github.svg" alt="Github"/></a>


<a href="https://twitter.com/iamnomand"><img class="icon-social" src="/img/twitter.svg" alt="Twitter"/></a>

<a href="https://hasaki.xyz/index.xml" target="_blank"><img class="icon-social" src="/img/feed.svg" alt="Feed"></a>

				<p>
					
					
					Early 2016 ~ 2019 &copy; TOM's Zone
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
		<script>hljs.initHighlightingOnLoad();</script>
		
	</body>
</html>

