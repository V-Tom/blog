<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="Keywords" content="">
    <meta name="full-screen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#006cb4">
    <meta name="apple-mobile-web-app-title" content="TOM&#39;s zone">
    <meta name="description" content="TOM&#39;s zone">
    <link rel="dns-prefetch" href="https://t-tom.me">
    <link rel="preconnect" href="https://t-tom.me">
    <link rel="manifest" href="/sw/manifest.json"/>
    <meta name="generator" content="Hugo 0.37" />
    <title>使用Swift开发React Native组件 - TOM&#39;s zone</title>

    <meta name="description" content="使用Swift开发React Native组件">


    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">

    
    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/ocean.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/javascript.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/python.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/css.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/swift.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/objectivec.min.js"></script>
    
    
    <link rel="stylesheet" href="/css/bundle.min.css"/>
    <style>
	a { color: #ff8181; }
	blockquote {
		border-left-color: #ff8181;
		border-right-color: #ff8181; }
	.bar a:hover {
		color: #ff8181;
		text-decoration: none; }
	.sep {
		margin-top: 2rem;
		margin-bottom: 1rem;
		margin-left:0;
		width: 24rem;
		border-top: 2px solid #ff8181; }
    .bar li.active a{
        color:#ff8181;
    }
</style>

</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li>
		
		<li class="active"><a href="/blog/">Blog</a></li>
		<li class=""><a href="/life/">Life</a></li></ul>
</nav>

	</div>
</header>
<main class="container">

<article>
    <header><hgroup id="brand">
	<h1>使用Swift开发React Native组件</h1>
	<h5>
		
		<time datetime="2018-04-23 14:28:25 &#43;0800 CST">Apr 23, 2018</time>
		<span class="no-print">
			-
				
				<a href="/tags/native">Native</a>
				
				<a href="/tags/frontend">FrontEnd</a>
				
				<a href="/tags/rn">RN</a>
				<span>
	</h5>
	
</hgroup>
<hr class="sep" />
</header>
    <section id="markdown">
        

<blockquote>
<p>本人只是一个前端，偶尔写一点其他语言来拓展开发技能。</p>

<p>因业务当中使用到 RN，所以对如何实现 RN custom module 也比较感兴趣并简单学习实现了一些功能。本文可能有些地方可能比较浅显或者有错误，还望读者海涵并指正。</p>
</blockquote>

<h3 id="环境准备">环境准备</h3>

<p>因为 swift 的断崖式升级以及 RN 不同版本，所以下面的例子可能会存在一些误差。本机环境为：</p>

<ul>
<li>RN：0.45.1</li>
<li>swift：4.1</li>
<li>Xcode：9.3</li>
<li>OS：high sierra 10.13.4</li>
</ul>

<h3 id="cocoapods">CocoaPods</h3>

<p>CocoaPods是专门为 iOS 工程提供对第三方库的依赖的管理工具，通过 CocoaPods ，我们可以更方便地管理每个第三方库的版本，而且不需要我们做太多的配置。直观、集中和自动化地管理我们项目的第三方库。</p>

<p>我们都有这样的经历，当我们添加第三方库的时候，需要导入一堆相关依赖库，更新的时候也要删掉重新导入然后再配置。当我们需要更新某个第三方库的时候，我们又要手动移除该库，导入新的库，然后再配置。这些是很麻烦且没有意义的工作。</p>

<p>安装 CocoaPods 需要用到 gem 。gem 是 <a href="http://rubygems.org/">RubyGems</a> 的缩写，属于 ruby 上的包管理工具。</p>

<p>这里建议切换国内镜像源地址，当然你也可以加上 <code>-p</code> 参数来配置 proxy</p>

<pre><code class="language-bash">gem sources --remove https://rubygems.org/ &amp;&amp; gem sources -a https://gems.ruby-china.org/
</code></pre>

<p>将 RubyGems 升级到最新版本，不然有可能导致配置 CocoaPods 失败。</p>

<pre><code class="language-bash">sudo gem update --system
</code></pre>

<p>可以使用下面命令来查看替换镜像位置是否成功：</p>

<pre><code class="language-bash">gem sources -l
</code></pre>

<p>结果应该是：</p>

<pre><code>*** CURRENT SOURCES ***

https://gems.ruby-china.org/
</code></pre>

<p>接下来就可以放心的安装 CocoaPods了：</p>

<pre><code class="language-bash">sudo gem install cocoapods
</code></pre>

<p>然后继续进行 setUp：</p>

<pre><code class="language-bash">pod setup
</code></pre>

<p>这一步是将Github上的开源库都托管都安装Podspec索引安装到到本地，这一步会很慢，建议添加本地 proxy。</p>

<p>我使用 ShadowsocksR 代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令。</p>

<p>如果你同事电脑上有安装好,你其实可以从你同事电脑上拷贝过来。也可以直接访问 <a href="https://link.jianshu.com/?t=https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a> 这个源地址直接 download 下来。</p>

<blockquote>
<p>如何恢复 git config proxy 可以采用 <code>git config --global --unset http.proxy</code></p>
</blockquote>

<pre><code class="language-bash"># gloabl proxy
git config --global http.proxy socks5://127.0.0.1:1080

# only github proxy
git config --global http.https://github.com.proxy socks5://127.0.0.1:1080
</code></pre>

<p>下载安装完毕后会是如下图：</p>

<p><img src="./pod-setup.png" alt="pod-setup.png" /></p>

<p>然后检测版本：<code>pod --version</code>，我这里显示是 1.5.0，至此 CocoaPods 安装完毕。</p>

<p>接下来 <code>pod install</code> 的时候也会遇到速度较慢的问题，可以切换为<a href="https://mirror.tuna.tsinghua.edu.cn/help/CocoaPods/">国内镜像</a>，我这里直接添加 proxy了。</p>

<h3 id="创建项目">创建项目</h3>

<p>在下面的例子当中我们会创建一个简单的 demo 来实现 custom React Native module。</p>

<h4 id="创建基础模板">创建基础模板</h4>

<p>我们先通 xcode 来创建一个 swift 项目，姑且命令为 <code>pocket</code> ，为了方便测试，我们选择 <code>Tabbed App</code> 来作为模板，并且 language 我们当然选择 swift。并且不选择单元测试功能，这样项目目录看起来会比较简洁一点：</p>

<p><img src="./create-new-project.png" alt="create-new-project.png" /></p>

<h4 id="创建前端工作区">创建前端工作区</h4>

<p>在项目根目录下创建一个名为 RNComponent 的文件夹来放置官方 React Native module 以及前端代码，然后创建一个 <code>package.json</code> 来写入依赖：</p>

<pre><code class="language-bash"># 在当前目录下执行操作
mkdir RNComponent &amp;&amp; cd RNComponent &amp;&amp; touch package.json
</code></pre>

<p><code>package.json</code> 文件内容大致如下：</p>

<blockquote>
<p>当然也可以自定义 React 和 RN 版本，自然少不了需要解决版本兼容性的问题。</p>
</blockquote>

<pre><code class="language-json">{
    &quot;name&quot;: &quot;RNComponent&quot;,
    &quot;version&quot;: &quot;0.0.0&quot;,
    &quot;private&quot;: true,
    &quot;scripts&quot;: {
        &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start --reset-cache&quot;
    },
    &quot;dependencies&quot;: {
        &quot;react&quot;: &quot;16.0.0-alpha.12&quot;,
        &quot;react-native&quot;: &quot;0.45.1&quot;
    }
}

</code></pre>

<p>接下来安装依赖：<code>npm i -d</code> 。</p>

<p>接下来的步骤大家都很熟悉了，我们需要创建一个入口文件 <code>index.ios.js</code>，我们用来跑测试 RN 代码，内容大致如下：</p>

<pre><code class="language-js">import { AppRegistry, NativeModules, View, Text, StyleSheet } from 'react-native';
import React from 'react';

class Root extends React.Component {
    render() {
        return (
            &lt;View style={styles.container}&gt;
            &lt;Text&gt; hello world &lt;/Text&gt;
            &lt;/View&gt;
        );
    }
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});

AppRegistry.registerComponent('App', () =&gt; Root);
</code></pre>

<p>至此，前端目录部分工作完成。</p>

<h4 id="创建-swift-工作区">创建 swift 工作区</h4>

<p>进入项目根目录，初始化 Podfile，不要手动创建 Podfile：</p>

<pre><code class="language-bash">pod init
</code></pre>

<p>我们在刚才生成的 <code>Podfile</code> 文件当中 <code>use_frameworks!</code> 关键词下换行添加以下依赖：</p>

<blockquote>
<p>请注意下面当中的 path 是相对于我们之前的前端工作区安装的 node_modules 的地址。</p>
</blockquote>

<pre><code class="language-txt">   # 请注意这个目录是相对目录地址。
  pod 'Yoga', :path =&gt; './RNComponent/node_modules/react-native/ReactCommon/yoga'
  # 请注意这个目录是相对目录地址。
  pod 'React', :path =&gt; './RNComponent/node_modules/react-native’,:subspecs =&gt; [
      'Core',
      'ART',
      'RCTActionSheet',
      'RCTAdSupport',
      'RCTGeolocation',
      'RCTImage',
      'RCTNetwork',
      'RCTPushNotification',
      'RCTSettings',
      'RCTText',
      'RCTVibration',
      'RCTWebSocket',
      'RCTLinkingIOS',
      'jschelpers_legacy',
      'BatchedBridge',
      'DevSupport',
    ]
</code></pre>

<p>最后执行 <code>pod install</code> 执行安装依赖操作：</p>

<p><img src="./pod-install.png" alt="pod-install.png" /></p>

<p>对于安装依赖后出现的黄色 warning，读者可以自行查阅原因并解决。（暂时不影响项目</p>

<p>项目当中会生成一个 <code>pocket.xcworkspace</code> 文件以及对应的 <code>Podfile.lock</code> 以及 <code>Pods</code> 文件夹。</p>

<blockquote>
<p><strong>注意之后打开项目是通过 <code>pocket.xcworkspace</code> ，而不是之前的 <code>knife.xcodeproj</code></strong></p>
</blockquote>

<p>至此我们的 swift 工作区创建完毕。</p>

<h4 id="设置-rctrootview">设置 RCTRootView</h4>

<p>我们需要设置 <strong>RCTRootView</strong> 来渲染我们的 RN，因为我们创建的是一个 <code>Tabbed App</code>，所以默认项目结构是这样：</p>

<p><img src="./xcode-workspace-overview.png" alt="xcode-workspace-overview.png" /></p>

<p>简单介绍一下项目文件的用途：</p>

<ul>
<li><code>XXViewController.swift</code> 根视图控制器。</li>
<li><code>AppDelegate.swift</code> 继承至 UIApplicationDelegate ，整个应用的一个代理，尽量保持干净、整洁，并且带有生命周期，可以在这里对全局状态进行更新、重置。</li>
<li><code>Main.storyboard</code> 主入口 storyboard，描述软件界面，用来把界面和代码分离。</li>
<li><code>LaunchScreen.storyboard</code> 闪屏 storyboard</li>
<li><code>Info.plist</code> 工程配置文件</li>
</ul>

<p>我们需要在 <code>FirstViewController.swift</code> 当中指定 <strong>RNViewController</strong> ，首先在头部引入 React：</p>

<pre><code class="language-swift">import React
</code></pre>

<p>然后把 <code>viewDidLoad</code> 函数更改为以下代码：</p>

<pre><code class="language-swift">    override func viewDidLoad() {
        super.viewDidLoad() 
        // 这个是我们 RN development 地址，ip 对应本机局域网 ip，建议不要写 localhost
        let strUrl: String = &quot;http://10.0.36.112:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;
        let jsCodeLocation = URL(string: strUrl)
        let rootView = RCTRootView(bundleURL: jsCodeLocation, moduleName: &quot;App&quot;, initialProperties: nil, launchOptions: nil)
        view = rootView
    }
</code></pre>

<h4 id="swift-工作区额外处理">swift 工作区额外处理</h4>

<p>当然 ios 开发会有各种各样的问题需要去处理，我在这里列出一些当前项目可能会出现的一些问题：</p>

<blockquote>
<p>ios9 以上的系统，无法通过http协议连接到localhost主机，会出现错误：Could not connect to development server</p>
</blockquote>

<p>在工程当中的 <code>Info.list</code> 文件当中添加下面配置即可：</p>

<pre><code class="language-xml">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;  
  &lt;dict&gt;  
  &lt;key&gt;NSExceptionDomains&lt;/key&gt;  
  &lt;dict&gt;  
      &lt;key&gt;localhost&lt;/key&gt;  
      &lt;dict&gt;  
      &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt;  
      &lt;true/&gt;  
     &lt;/dict&gt;  
   &lt;/dict&gt;  
  &lt;/dict&gt;  
</code></pre>

<p>配置结果如下：</p>

<p><img src="./info-list.png" alt="info-list.png" /></p>

<blockquote>
<p>Xcode 一直打印：nw_connection_get_connected_socket_block_invoke 3 Connection has no connected handler</p>
</blockquote>

<p>解决办法如下：</p>

<ul>
<li>Xcode menu -&gt; Product -&gt; Edit Scheme&hellip;</li>
<li>Environment Variables -&gt; Add -&gt; Name: &ldquo;OS_ACTIVITY_MODE&rdquo;, Value:&ldquo;disable&rdquo; .</li>
<li>Run your app again. done.</li>
</ul>

<h4 id="hello-world">hello world</h4>

<p>我们首先需要回到我们前面创建的 前端工作区 来运行 RN：</p>

<pre><code class="language-bash">npm run start
</code></pre>

<p>然后在 Xcode 编译刚才的 pocket，我们这里选择模拟器来测试，成功后如下：</p>

<p><img src="./hello-world.png" alt="hello-world.png" /></p>

<h3 id="原生模块开发">原生模块开发</h3>

<blockquote>
<p>有时候App需要访问平台API，但React Native可能还没有相应的模块封装；又或者你需要实现某些高性能、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。所以 RN 提供了封装原生模块方法。</p>
</blockquote>

<p>RN 提供了很多方法来封装原生模块，具体可以查看 <a href="https://github.com/facebook/react-native/blob/master/React/Base/RCTBridgeModule.h">RCTBridgeModule.h</a> ,基本上大致有：</p>

<ul>
<li><code>RCT_EXPORT_METHOD</code> 或者 <code>RCT_EXTERN_MODULE</code> 用来声明给 javascript 导出方法</li>
<li><code>RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD</code>  或者 <code>RCT_EXTERN_BLOCKING_SYNCHRONOUS_METHOD</code>  用来声明给 javascript 导出的同步方法</li>
<li><code>RCT_EXPORT_REMAP_MODULE</code> 和 <code>RCT_EXTERN_REMAP_MODULE</code>  用来改变导出模块和方法的JavaScript 调用名称。</li>
<li>等等一些其他的方法，具体请参阅源码文件。</li>
</ul>

<blockquote>
<p>EXPORT 和 EXTERN 的区别到底是什么？以下是个人理解，可能有偏差，望指正。</p>
</blockquote>

<p>看官方介绍说后者是用来注册 <code>swift class</code> 或者 <code>private object-c class</code>。按照个人的理解：<code>RCT_EXPORT_METHOD</code> 这个宏是用来将原生的方法导出，只有用这个宏包裹的方法，才可以被RN调用，为了实现 RN 调用 swift 方法，所以需要用到 EXTERN 之类的方法，实际上在 EXTERN 内部也是通过 objc <a href="https://github.com/facebook/react-native/blob/master/React/Base/RCTBridgeModule.h#L237-L243">关键方法</a> 来实现混合调用。</p>

<h4 id="需求分析">需求分析</h4>

<p>按照官方提供的说法，我们可以提供给 javascript 调用的方法有以下方式：</p>

<ul>
<li>直接调用</li>
<li>同步调用返回结果</li>
<li>callback 调用</li>
<li>Promise 调用</li>
</ul>

<p>我们希望实现一个命名为 <code>RNDemoModule</code> 的 Native module，然后希望能够实现上诉所有的方法，以及甚至希望能够实现 <code>Event emitter</code>。</p>

<h4 id="准备工作">准备工作</h4>

<p>我们先创建一个命名为 <code>RNDemoModule.swift</code> 的文件来放置我们的模块代码，文件内容大致如下：</p>

<pre><code class="language-swift">import Foundation
import React


@objc(RNDemoModule)
class RNDemoModule: NSObject {
    
    // 自定义我们需要导出的方法
    
}
</code></pre>

<p>因为我们是写的 swift 文件，需要使用 <code>@objc</code> 来指定哪些方法或者属性在 OC当中可以调用。</p>

<p>以及一旦你在项目混用OC和Swift两种语言，那就需要这个 <strong>桥接文件</strong>。</p>

<blockquote>
<p>一般在项目的Supporting Files文件夹里(一般系统会自动生成的，叫做“项目名-Bridging-Header.h”，项目名就是你工程的项目名）</p>
</blockquote>

<p>我们这里直接创建一个命名为 <code>RNDemoModuleBridge.m</code> 的文件来进行桥接，大致如下：</p>

<pre><code class="language-objective-c">#import &lt;React/RCTBridgeModule.h&gt;

@interface RCT_EXTERN_MODULE(RNDemoModule,NSObject)

// 通过RCT_EXTERN_METHOD 来导出我们的自定义方法
    
@end
</code></pre>

<p>我们可以给这个 module 添加一些导出常量：</p>

<pre><code class="language-swift">// ... class RNDemoModule
    
	// 导出常量
    func constantsToExport() -&gt; [AnyHashable: Any]! {
        return [
            &quot;SDKVersion&quot;: &quot;0.45.1&quot;,
            &quot;NativeModuleVersion&quot;:&quot;0.0.0&quot;
        ]
    }   
 
// ... class RNDemoModule   
</code></pre>

<p>我们在 console 打印这个对象可以得到如下结构：</p>

<p><img src="./console-export-const.png" alt="console-export-const.png" /></p>

<h4 id="功能实现-直接调用">功能实现:直接调用</h4>

<p><code>RNDemoModule.swift</code></p>

<pre><code class="language-swift">// ... class RNDemoModule

	// 简单调用
    @objc func call(
        _ name:String
        ) -&gt; Void{
        print(&quot;call with argument name:&quot; + name)
    }

// ... class RNDemoModule
</code></pre>

<p><code>RNDemoModuleBridge.m</code></p>

<pre><code class="language-objective-c">// #import &lt;React/RCTBridgeModule.h&gt;
// @interface RCT_EXTERN_MODULE(RNDemoModule,NSObject)

RCT_EXTERN_METHOD(call:(NSString *)name);

// @end
</code></pre>

<p><code>index.ios.js</code></p>

<pre><code class="language-javascript">import { NativeModules } from 'react-native'
const { RNDemoModule } = NativeModules

RNDemoModule.call('TOM')
</code></pre>

<p>最终在 Xcode console 打印出 <code>call with argument name: TOM</code></p>

<h4 id="功能实现-同步调用返回结果">功能实现:同步调用返回结果</h4>

<p>TODO:尚未完成，存在疑问</p>

<blockquote>
<p>似乎返回结果需要 <code>global.nativeCallSyncHook</code> 来做垫底？？？那怎么知道到底是哪个方法调用返回结果？</p>
</blockquote>

<p>参照这篇文章<a href="https://blog.csdn.net/wangnan8015/article/details/53303899"> React Native技术剖析（二） </a> 以及 <a href="https://github.com/facebook/react-native/blob/v0.45.1/React/Executors/RCTJSCExecutor.mm#L358-L368">RCTJSCExecutor.mm </a>我们知道同步调用返回结果需要设定 <code>global.nativeCallSyncHook</code></p>

<p><a href="https://github.com/facebook/react-native/blob/v0.45.1/React/Executors/RCTJSCExecutor.mm#L358-L368">RCTJSCExecutor.mm </a></p>

<pre><code class="language-objective-c">   
	// 这个 context 是当前 jsCore context
	context[@&quot;nativeCallSyncHook&quot;] = ^id(NSUInteger module, NSUInteger method, NSArray *args) {
      RCTJSCExecutor *strongSelf = weakSelf;
      if (!strongSelf.valid) {
        return nil;
      }

      RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways, @&quot;nativeCallSyncHook&quot;, nil);
      id result = [strongSelf-&gt;_bridge callNativeModule:module method:method params:args];
      RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @&quot;js_call,config&quot;);
      return result;
    };
</code></pre>

<p><code>RNDemoModule.swift</code></p>

<pre><code class="language-swift">// ... class RNDemoModule

	// 同步调用
    @objc func callWithSync( _ name:String)-&gt;String{
        return &quot;hello &quot; + name + &quot;from sync&quot;
    }
// ... class RNDemoModule
</code></pre>

<p><code>RNDemoModuleBridge.m</code></p>

<pre><code class="language-objective-c">// #import &lt;React/RCTBridgeModule.h&gt;
// @interface RCT_EXTERN_MODULE(RNDemoModule,NSObject)

RCT_EXTERN__BLOCKING_SYNCHRONOUS_METHOD(callWithSync:(NSString *)name)

// @end
</code></pre>

<p><code>index.ios.js</code></p>

<pre><code class="language-javascript">import { NativeModules } from 'react-native'
const { RNDemoModule } = NativeModules

// why？
global.nativeCallSyncHook = function () {
    console.info(arguments) // [moduleid,method,'TOM']
}

console.info(RNDemoModule.callWithSync('TOM'))
</code></pre>

<p>参照 jsCore 定义，最终 chrome console 会打印出的数据格式为<code>(Integer,Integer,Array)</code> 最终结果也就是<code>[70, 0,['TOM']]</code></p>

<h4 id="功能实现-callback调用">功能实现:callback调用</h4>

<p><code>RNDemoModule.swift</code></p>

<pre><code class="language-swift">// ... class RNDemoModule

	// 回调
    @objc func callWithCallBack(
        _ name:String,
        callback:@escaping RCTResponseSenderBlock
        ){       
         // 简单实现 setTimeout 1s
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            // callback 参数 name 的值
            // Node.js 风格，error frist argument。这里是 null
            callback([NSNull(),[
                &quot;value&quot;:name
                ]])
        }
    }

// ... class RNDemoModule
</code></pre>

<p><code>RNDemoModuleBridge.m</code></p>

<pre><code class="language-objective-c">// #import &lt;React/RCTBridgeModule.h&gt;
// @interface RCT_EXTERN_MODULE(RNDemoModule,NSObject)

RCT_EXTERN_METHOD(callWithCallBack:(NSString *)name callback:(RCTResponseSenderBlock)callback);

// @end
</code></pre>

<p><code>index.ios.js</code></p>

<pre><code class="language-javascript">import { NativeModules } from 'react-native'
const { RNDemoModule } = NativeModules

RNDemoModule.callWithCallBack('TOM', (err, value) =&gt; console.info(`callWithCallBack:${value}`))
</code></pre>

<p>最终 chrome console 会输出：<code>callWithCallBack:TOM</code></p>

<h4 id="功能实现-promise调用">功能实现:Promise调用</h4>

<p><code>RNDemoModule.swift</code></p>

<pre><code class="language-swift">// ... class RNDemoModule

	// Promise
    @objc func callWithPromise(
        _ name:String,
        resolve:@escaping RCTPromiseResolveBlock,
        reject: @escaping RCTPromiseRejectBlock
        )-&gt; Void{
        
        // 简单实现 setTimeout 1s
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            // 直接 resolve 参数 name 的值
            resolve([name])
        }
    }

// ... class RNDemoModule
</code></pre>

<p><code>RNDemoModuleBridge.m</code></p>

<pre><code class="language-objective-c">// #import &lt;React/RCTBridgeModule.h&gt;
// @interface RCT_EXTERN_MODULE(RNDemoModule,NSObject)
    
RCT_EXTERN_METHOD(callWithPromise:(nonnull NSString *)name resolve:(RCTPromiseResolveBlock)resolve reject:(RCTPromiseRejectBlock)reject);

// @end
</code></pre>

<p><code>index.ios.js</code></p>

<pre><code class="language-javascript">import { NativeModules } from 'react-native'
const { RNDemoModule } = NativeModules

RNDemoModule.callWithPromise('TOM').then(value =&gt; console.info(`callWithPromise:${value}`))
</code></pre>

<p>最终 chrome console 会输出：<code>callWithPromise:TOM</code></p>

<h4 id="功能实现-event-emitter">功能实现:Event Emitter</h4>

<p>实现 Event Emitter 目前好像有两种方案：</p>

<ul>
<li>Bridge.eventDispatcher().sendAppEvent</li>
<li>继承 RCTEventEmitter</li>
</ul>

<p>官方推荐第二种方式来实现。</p>

<blockquote>
<p>新的类需要继承 RCTEventEmitter，其实这个 RCTEventEmitter 也是继承 NSObject，我尝试更改老的 module 继承对象，一直报错。</p>
</blockquote>

<p>我们需要新建一个 swift 文件命名为 <code>RNDemoEventEmitter.swift</code>，内容大致如下：</p>

<pre><code class="language-swift">import Foundation
import React

@objc(RNDemoEventEmitter)
class RNDemoEventEmitter: RCTEventEmitter {

}
</code></pre>

<p>官方要求是通过实现 <code>supportedEvents</code> 方法来指定导出的 event name ，这里我们假设一个命名为 <code>progress</code> 的 event。</p>

<pre><code class="language-swift">// ... class RNDemoEventEmitter

  @objc override func supportedEvents() -&gt; [String]?{
        return [&quot;progress&quot;]
    }

// ... class RNDemoEventEmitter
</code></pre>

<p>还要实现 <code>startObserving</code> 和 <code>stopObserving</code> 方法，用来优化无监听处理的事件，在实现之前我们定义一个变量来表示是否已经开始监听。</p>

<pre><code class="language-swift">var _hasListeners:Bool = false	
</code></pre>

<p>我们希望能够模拟被监听的事件触发的情况。所以我们需要开始监听的时候设定一个定时器，每过特定的时间去调用监听方法：也就是下面的方法 <code>onProgress</code> 来调用 <code>RCTEventEmitter.sendEvent</code>。</p>

<pre><code class="language-swift">// ... class RNDemoEventEmitter
  
  // var _hasListeners:Bool = false
  var timer: Timer?

  @objc func onProgress()-&gt;Void{
       // 如果已经监听了就向 javascript 发送事件
        if self._hasListeners{
            // 发送特定监听名称 withName 的事件并带上自定义数据
            self.sendEvent(withName: &quot;progress&quot;, body: 1232)
        }
    }

  @objc override func startObserving()-&gt;Void{
      
        self._hasListeners = true
        
      	// 类似 setinterval 定时器
        self.timer?.invalidate()
        self.timer = Timer.scheduledTimer(
            timeInterval: 1,
            target: self,
            selector: #selector(self.hello),
            userInfo: nil,
            repeats: true
        )
        
    }
    
    @objc override func stopObserving()-&gt;Void{
        // 关闭 timer
        self.timer?.invalidate()
        self._hasListeners = false
    }
    
// ... class RNDemoEventEmitter    
</code></pre>

<p>我们在前端项目主入口文件 <code>index.ios.js</code> 当中添加监听：</p>

<pre><code class="language-javascript">import { NativeEventEmitter, NativeModules } from 'react-native'

const emitter = new NativeEventEmitter(NativeModules.RNDemoEventEmitter)
const subscription = emitter.addListener('progress', data =&gt; console.info(data))

</code></pre>

<p>我们可以在 chrome console 看到每隔一段时间会输出特定数据，注意别忘记在  RN 的<code>componentWillUnMount</code> 周期内解除这个事件监听。</p>

<h3 id="reference">Reference</h3>

<ul>
<li><a href="https://www.jianshu.com/p/adad5ee721af">CocoaPods最新安装(不使用淘宝镜像)</a></li>
<li><a href="https://www.jianshu.com/p/1711e131987d">看一遍就会的CocoaPods的安装和使用教程</a></li>
<li><a href="https://gems.ruby-china.org/">RubyGems <em>- Ruby China</em></a></li>
<li><a href="https://github.com/facebook/react-native/issues/7775">[IOS/MAC] -Integrating react-native app with existing apps not creating .workspace</a></li>
<li><a href="https://blog.csdn.net/wangnan8015/article/details/53303899">React Native技术剖析（二）</a></li>
<li><a href="http://www.cnblogs.com/kubixuesheng/p/4306395.html">objective-c 语法快速过</a></li>
<li><a href="https://stackoverflow.com/questions/39692230/got-is-not-a-recognized-objective-c-method-when-bridging-swift-to-react-native">Got “is not a recognized Objective-C method” when bridging Swift to React-Native</a></li>
</ul>

    </section>
    <nav class="no-print post-nav">
        
        <a class="prev-post" href="https://t-tom.me/blog/2018-04-08-%E8%B0%88%E8%B0%88node.js%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B/">
            <img class="icon-text" src="/img/prev.svg"/>谈谈 Node.js 的单线程</a>
        
        
        <a class="next-post" href="https://t-tom.me/blog/2018-05-21-javascript%E6%B2%99%E7%AE%B1/">sandbox of javascript<img class="icon-text" src="/img/next.svg"/>
        </a>
        
    </nav>
</article>
<script src="/js/bundle.js"></script>



<div id="disqus_thread" class="no-print"></div>
<script type="text/javascript">

  (function () {
    
    if (window.location.hostname == "localhost")
      return;

    const disqus_thread = document.querySelector('#disqus_thread')
    new IntersectionObserver(function (entries, observer) {
        entries.forEach(entry => {
          if (entry.intersectionRatio > 0 && !disqus_thread.classList.contains('active')) {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            var disqus_shortname = 'toms-blog-1';
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            disqus_thread.classList.add('active')
          }
        })
      }, {
        rootMargin: '0px',
        threshold: 1.0
      }
    ).observe(disqus_thread)

  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>

			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				
<a href="mailto:iamnomand@gmail.com"><img class="icon-social" src="/img/email.svg" alt="Email Me!"/></a>


<a href="https://github.com/v-tom/"><img class="icon-social" src="/img/github.svg" alt="Github"/></a>


<a href="https://twitter.com/iamnomand"><img class="icon-social" src="/img/twitter.svg" alt="Twitter"/></a>

<a href="https://t-tom.me/index.xml" target="_blank"><img class="icon-social" src="/img/feed.svg" alt="Feed"></a>

				<p>
					
					
					Early 2016 ~ 2018 &copy; TOM's Zone
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
		<script>hljs.initHighlightingOnLoad();</script>
		
	</body>
</html>

